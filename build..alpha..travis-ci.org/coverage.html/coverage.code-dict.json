{"/home/travis/build/npmtest/node-npmtest-jsdoc/test.js":"/* istanbul instrument in package npmtest_jsdoc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jsdoc/lib.npmtest_jsdoc.js":"/* istanbul instrument in package npmtest_jsdoc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_jsdoc = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_jsdoc = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-jsdoc/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-jsdoc && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_jsdoc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_jsdoc\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_jsdoc.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_jsdoc.rollup.js'] =\n            local.assetsDict['/assets.npmtest_jsdoc.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_jsdoc.__dirname +\n                    '/lib.npmtest_jsdoc.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/jsdoc.js":"#!/usr/bin/env node\n/* global arguments, require: true */\n/* eslint strict: [2, \"function\"] */\n/**\n * @project jsdoc\n * @author Michael Mathews <micmath@gmail.com>\n * @license See LICENSE.md file included in this distribution.\n */\n\n// initialize the environment for the current JavaScript VM\n(function(args) {\n    'use strict';\n\n    var path;\n\n    if (args[0] && typeof args[0] === 'object') {\n        // we should be on Node.js\n        args = [__dirname, process.cwd()];\n        path = require('path');\n\n        // Create a custom require method that adds `lib/jsdoc` and `node_modules` to the module\n        // lookup path. This makes it possible to `require('jsdoc/foo')` from external templates and\n        // plugins, and within JSDoc itself. It also allows external templates and plugins to\n        // require JSDoc's module dependencies without installing them locally.\n        require = require('requizzle')({\n            requirePaths: {\n                before: [path.join(__dirname, 'lib')],\n                after: [path.join(__dirname, 'node_modules')]\n            },\n            infect: true\n        });\n    }\n\n    require('./lib/jsdoc/util/runtime').initialize(args);\n})( Array.prototype.slice.call(arguments, 0) );\n\n/**\n * Data about the environment in which JSDoc is running, including the configuration settings that\n * were used to run JSDoc.\n *\n * @deprecated As of JSDoc 3.4.0. Use `require('jsdoc/env')` to access the `env` object. The global\n * `env` object will be removed in a future release.\n * @namespace\n * @name env\n */\nglobal.env = (function() {\n    'use strict';\n    return require('./lib/jsdoc/env');\n})();\n\n/**\n * Data that must be shared across the entire application.\n *\n * @deprecated As of JSDoc 3.4.0. Avoid using the `app` object. The global `app` object and the\n * `jsdoc/app` module will be removed in a future release.\n * @namespace\n * @name app\n */\nglobal.app = (function() {\n    'use strict';\n    return require('./lib/jsdoc/app');\n})();\n\n(function() {\n    'use strict';\n\n    var env = global.env;\n    var logger = require('./lib/jsdoc/util/logger');\n    var runtime = require('./lib/jsdoc/util/runtime');\n    var cli = require('./cli');\n\n    function cb(errorCode) {\n        cli.logFinish();\n        cli.exit(errorCode || 0);\n    }\n\n    cli.setVersionInfo()\n        .loadConfig();\n\n    if (!env.opts.test) {\n        cli.configureLogger();\n    }\n\n    cli.logStart();\n\n    if (env.opts.debug) {\n        /**\n         * Recursively print an object's properties to stdout. This method is safe to use with\n         * objects that contain circular references.\n         *\n         * This method is available only when JSDoc is run with the `--debug` option.\n         *\n         * @global\n         * @name dump\n         * @private\n         * @param {...*} obj - Object(s) to print to stdout.\n         */\n        global.dump = function() {\n            console.log(require('./lib/jsdoc/util/dumper').dump(arguments));\n        };\n    }\n\n    cli.runCommand(cb);\n})();\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/util/runtime.js":"/* global java */\n/**\n * Helper functions to enable JSDoc to run on multiple JavaScript runtimes.\n *\n * @module jsdoc/util/runtime\n * @private\n */\n'use strict';\n\nvar env = require('jsdoc/env');\nvar os = require('os');\n\n// This string represents a directory name; do not modify it!\n/** @private */\nvar NODE = exports.NODE = 'node';\n\n/**\n * The JavaScript runtime that is executing JSDoc:\n *\n * + `module:jsdoc/util/runtime~NODE`: Node.js.\n *\n * @private\n */\nvar runtime = (function() {\n    if (require && require.main && module) {\n        return NODE;\n    } else {\n        // unknown runtime\n        throw new Error('Unable to identify the current JavaScript runtime.');\n    }\n})();\n\n/**\n * Check whether Node.js is running JSDoc.\n * @return {boolean} Set to `true` if the current runtime is Node.js.\n */\nexports.isNode = function() {\n    return runtime === NODE;\n};\n\nfunction initializeNode(args) {\n    var fs = require('fs');\n    var path = require('path');\n\n    var jsdocPath = args[0];\n    var pwd = args[1];\n\n    // resolve the path if it's a symlink\n    if ( fs.statSync(jsdocPath).isSymbolicLink() ) {\n        jsdocPath = path.resolve( path.dirname(jsdocPath), fs.readlinkSync(jsdocPath) );\n    }\n\n    env.dirname = jsdocPath;\n    env.pwd = pwd;\n    env.args = process.argv.slice(2);\n}\n\nexports.initialize = function(args) {\n    switch (runtime) {\n        case NODE:\n            initializeNode(args);\n            break;\n        default:\n            throw new Error('Cannot initialize the unknown JavaScript runtime \"' + runtime + '\"!');\n    }\n};\n\n/**\n * Retrieve the identifier for the current JavaScript runtime.\n *\n * @private\n * @return {string} The runtime identifier.\n */\nexports.getRuntime = function() {\n    return runtime;\n};\n\n/**\n * Get the require path for the runtime-specific implementation of a module.\n *\n * @param {string} partialPath - The partial path to the module. Use the same format as when calling\n * `require()`.\n * @return {object} The require path for the runtime-specific implementation of the module.\n */\nexports.getModulePath = function(partialPath) {\n    var path = require('path');\n\n    return path.join(env.dirname, runtime, partialPath);\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/env.js":"'use strict';\n\n/**\n * Data about the environment in which JSDoc is running, including the configuration settings that\n * were used to run JSDoc.\n *\n * @module jsdoc/env\n */\nmodule.exports = {\n    /**\n     * The times at which JSDoc started and finished.\n     *\n     * @type {Object}\n     * @property {Date} start - The time at which JSDoc started running.\n     * @property {Date} finish - The time at which JSDoc finished running.\n     */\n    run: {\n        start: new Date(),\n        finish: null\n    },\n\n    /**\n     * The command-line arguments passed to JSDoc.\n     *\n     * @type {Array<*>}\n     */\n    args: [],\n\n    /**\n     * The data parsed from JSDoc's configuration file.\n     *\n     * @type Object<string, *>\n     */\n    conf: {},\n\n    /**\n     * The absolute path to the base directory in which JSDoc is located. Set at startup.\n     *\n     * @private\n     * @type {string}\n     */\n    dirname: null,\n\n    /**\n     * The user's working directory at the time when JSDoc started running.\n     *\n     * @private\n     * @type {string}\n     */\n    pwd: null,\n\n    /**\n     * The command-line arguments, parsed into a key/value hash.\n     *\n     * @type {Object}\n     * @example if (global.env.opts.help) { console.log('Helpful message.'); }\n    */\n    opts: {},\n\n    /**\n     * The source files that JSDoc will parse.\n     *\n     * @type {Array<string>}\n     * @memberof env\n     */\n    sourceFiles: [],\n\n    /**\n     * The JSDoc version number and revision date.\n     *\n     * @type {Object<string, string>}\n     * @property {string} number - The JSDoc version number.\n     * @property {string} revision - The JSDoc revision number, expressed as a UTC date string.\n     */\n    version: {\n        number: null,\n        revision: null\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/app.js":"'use strict';\n\n/**\n * Objects that are shared across the entire application.\n *\n * @deprecated As of JSDoc 3.4.0. Do not use this module. It will be removed in a future release.\n * @module jsdoc/app\n */\nmodule.exports = {\n    /**\n     * Namespace for shared objects.\n     *\n     * @namespace\n     * @type {Object}\n     */\n    jsdoc: {\n        name: require('jsdoc/name'),\n        parser: null,\n        scanner: new (require('jsdoc/src/scanner').Scanner)()\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/name.js":"/**\n    A collection of functions relating to JSDoc symbol name manipulation.\n    @module jsdoc/name\n    @author Michael Mathews <micmath@gmail.com>\n    @license Apache License 2.0 - See file 'LICENSE.md' in this project.\n */\n'use strict';\n\nvar _ = require('underscore');\nvar escape = require('escape-string-regexp');\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\n/**\n * Longnames that have a special meaning in JSDoc.\n *\n * @enum {string}\n * @static\n * @memberof module:jsdoc/name\n */\nvar LONGNAMES = exports.LONGNAMES = {\n    /** Longname used for doclets that do not have a longname, such as anonymous functions. */\n    ANONYMOUS: '<anonymous>',\n    /** Longname that represents global scope. */\n    GLOBAL: '<global>'\n};\n\n// Module namespace prefix.\nvar MODULE_NAMESPACE = 'module:';\n\n/**\n * Names and punctuation marks that identify doclet scopes.\n *\n * @enum {string}\n * @static\n * @memberof module:jsdoc/name\n */\nvar SCOPE = exports.SCOPE = {\n    NAMES: {\n        GLOBAL: 'global',\n        INNER: 'inner',\n        INSTANCE: 'instance',\n        STATIC: 'static'\n    },\n    PUNC: {\n        INNER: '~',\n        INSTANCE: '#',\n        STATIC: '.'\n    }\n};\n\n// For backwards compatibility, this enum must use lower-case keys\nvar scopeToPunc = exports.scopeToPunc = {\n    'inner': SCOPE.PUNC.INNER,\n    'instance': SCOPE.PUNC.INSTANCE,\n    'static': SCOPE.PUNC.STATIC\n};\nvar puncToScope = exports.puncToScope = _.invert(scopeToPunc);\n\nvar DEFAULT_SCOPE = SCOPE.NAMES.STATIC;\nvar SCOPE_PUNC = _.values(SCOPE.PUNC);\nvar SCOPE_PUNC_STRING = '[' + SCOPE_PUNC.join() + ']';\nvar REGEXP_LEADING_SCOPE = new RegExp('^(' + SCOPE_PUNC_STRING + ')');\nvar REGEXP_TRAILING_SCOPE = new RegExp('(' + SCOPE_PUNC_STRING + ')$');\n\nvar DESCRIPTION = '(?:(?:[ \\\\t]*\\\\-\\\\s*|\\\\s+)(\\\\S[\\\\s\\\\S]*))?$';\nvar REGEXP_DESCRIPTION = new RegExp(DESCRIPTION);\nvar REGEXP_NAME_DESCRIPTION = new RegExp('^(\\\\[[^\\\\]]+\\\\]|\\\\S+)' + DESCRIPTION);\n\nfunction nameIsLongname(name, memberof) {\n    var regexp = new RegExp('^' + escape(memberof) + SCOPE_PUNC_STRING);\n\n    return regexp.test(name);\n}\n\nfunction prototypeToPunc(name) {\n    // don't mangle symbols named \"prototype\"\n    if (name === 'prototype') {\n        return name;\n    }\n\n    return name.replace(/(?:^|\\.)prototype\\.?/g, SCOPE.PUNC.INSTANCE);\n}\n\n// TODO: deprecate exports.resolve in favor of a better name\n/**\n    Resolves the longname, memberof, variation and name values of the given doclet.\n    @param {module:jsdoc/doclet.Doclet} doclet\n */\nexports.resolve = function(doclet) {\n    var about = {};\n    var memberof = doclet.memberof || '';\n    var metaName;\n    var name = doclet.name ? String(doclet.name) : '';\n    var parentDoc;\n    var puncAndName;\n    var puncAndNameIndex;\n\n    // change MyClass.prototype.instanceMethod to MyClass#instanceMethod\n    // (but not in function params, which lack doclet.kind)\n    // TODO: check for specific doclet.kind values (probably function, class, and module)\n    if (name && doclet.kind) {\n        name = prototypeToPunc(name);\n    }\n    doclet.name = name;\n\n    // member of a var in an outer scope?\n    if (name && !memberof && doclet.meta.code && doclet.meta.code.funcscope) {\n        name = doclet.longname = doclet.meta.code.funcscope + SCOPE.PUNC.INNER + name;\n    }\n\n    if (memberof || doclet.forceMemberof) { // @memberof tag given\n        memberof = prototypeToPunc(memberof);\n\n        // the name is a complete longname, like @name foo.bar, @memberof foo\n        if (name && nameIsLongname(name, memberof) && name !== memberof) {\n            about = exports.shorten(name, (doclet.forceMemberof ? memberof : undefined));\n        }\n        // the name and memberof are identical and refer to a module,\n        // like @name module:foo, @memberof module:foo (probably a member like 'var exports')\n        else if (name && name === memberof && name.indexOf(MODULE_NAMESPACE) === 0) {\n            about = exports.shorten(name, (doclet.forceMemberof ? memberof : undefined));\n        }\n        // the name and memberof are identical, like @name foo, @memberof foo\n        else if (name && name === memberof) {\n            doclet.scope = doclet.scope || DEFAULT_SCOPE;\n            name = memberof + scopeToPunc[doclet.scope] + name;\n            about = exports.shorten(name, (doclet.forceMemberof ? memberof : undefined));\n        }\n        // like @memberof foo# or @memberof foo~\n        else if (name && REGEXP_TRAILING_SCOPE.test(memberof) ) {\n            about = exports.shorten(memberof + name, (doclet.forceMemberof ? memberof : undefined));\n        }\n        else if (name && doclet.scope) {\n            about = exports.shorten(memberof + (scopeToPunc[doclet.scope] || '') + name,\n                (doclet.forceMemberof ? memberof : undefined));\n        }\n    }\n    else { // no @memberof\n        about = exports.shorten(name);\n    }\n\n    if (about.name) {\n        doclet.name = about.name;\n    }\n\n    if (about.memberof) {\n        doclet.setMemberof(about.memberof);\n    }\n\n    if (about.longname && (!doclet.longname || doclet.longname === doclet.name)) {\n        doclet.setLongname(about.longname);\n    }\n\n    if (doclet.scope === SCOPE.NAMES.GLOBAL) { // via @global tag?\n        doclet.setLongname(doclet.name);\n        delete doclet.memberof;\n    }\n    else if (about.scope) {\n        if (about.memberof === LONGNAMES.GLOBAL) { // via @memberof <global> ?\n            doclet.scope = SCOPE.NAMES.GLOBAL;\n        }\n        else {\n            doclet.scope = puncToScope[about.scope];\n        }\n    }\n    else if (doclet.name && doclet.memberof && !doclet.longname) {\n        if ( REGEXP_LEADING_SCOPE.test(doclet.name) ) {\n            doclet.scope = puncToScope[RegExp.$1];\n            doclet.name = doclet.name.substr(1);\n        }\n        else if (doclet.meta.code && doclet.meta.code.name) {\n            // HACK: Handle cases where an ES 2015 class is a static memberof something else, and\n            // the class has instance members. In these cases, we have to detect the instance\n            // members' scope by looking at the meta info. There's almost certainly a better way to\n            // do this...\n            metaName = String(doclet.meta.code.name);\n            puncAndName = SCOPE.PUNC.INSTANCE + doclet.name;\n            puncAndNameIndex = metaName.indexOf(puncAndName);\n            if ( puncAndNameIndex !== -1 &&\n                (puncAndNameIndex === metaName.length - puncAndName.length) ) {\n                doclet.scope = SCOPE.NAMES.INSTANCE;\n            }\n        }\n\n        doclet.scope = doclet.scope || DEFAULT_SCOPE;\n        doclet.setLongname(doclet.memberof + scopeToPunc[doclet.scope] + doclet.name);\n    }\n\n    if (about.variation) {\n        doclet.variation = about.variation;\n    }\n\n    // if we never found a longname, just use an empty string\n    if (!doclet.longname) {\n        doclet.longname = '';\n    }\n};\n\n/**\n    @method module:jsdoc/name.applyNamespace\n    @param {string} longname The full longname of the symbol.\n    @param {string} ns The namespace to be applied.\n    @returns {string} The longname with the namespace applied.\n */\nexports.applyNamespace = function(longname, ns) {\n    var nameParts = exports.shorten(longname);\n    var name = nameParts.name;\n\n    longname = nameParts.longname;\n\n    if ( !/^[a-zA-Z]+?:.+$/i.test(name) ) {\n        longname = longname.replace( new RegExp(escape(name) + '$'), ns + ':' + name );\n    }\n\n    return longname;\n};\n\n// TODO: docs\nexports.stripNamespace = function(longname) {\n    return longname.replace(/^[a-zA-Z]+:/, '');\n};\n\n/**\n * Check whether a parent longname is an ancestor of a child longname.\n *\n * @param {string} parent - The parent longname.\n * @param {string} child - The child longname.\n * @return {boolean} `true` if the parent is an ancestor of the child; otherwise, `false`.\n */\nexports.hasAncestor = function(parent, child) {\n    var hasAncestor = false;\n    var memberof = child;\n\n    if (!parent || !child) {\n        return hasAncestor;\n    }\n\n    // fast path for obvious non-ancestors\n    if (child.indexOf(parent) !== 0) {\n        return hasAncestor;\n    }\n\n    do {\n        memberof = exports.shorten(memberof).memberof;\n\n        if (memberof === parent) {\n            hasAncestor = true;\n        }\n    } while (!hasAncestor && memberof);\n\n    return hasAncestor;\n};\n\n// TODO: docs\nfunction atomize(longname, sliceChars, forcedMemberof) {\n    var i;\n    var memberof = '';\n    var name = '';\n    var parts;\n    var partsRegExp;\n    var scopePunc = '';\n    var token;\n    var tokens = [];\n    var variation;\n\n    // quoted strings in a longname are atomic, so we convert them to tokens:\n    // foo[\"bar\"] => foo.@{1}@\n    // Foo.prototype[\"bar\"] => Foo#@{1}\n    longname = longname.replace(/(prototype|#)?(\\[?[\"'].+?[\"']\\]?)/g, function($, p1, p2) {\n        var punc = '';\n\n        // is there a leading bracket?\n        if ( /^\\[/.test(p2) ) {\n            // is it a static or instance member?\n            punc = p1 ? SCOPE.PUNC.INSTANCE : SCOPE.PUNC.STATIC;\n            p2 = p2.replace(/^\\[/g, '')\n                .replace(/\\]$/g, '');\n        }\n\n        token = '@{' + tokens.length + '}@';\n        tokens.push(p2);\n\n        return punc + token;\n    });\n\n    longname = prototypeToPunc(longname);\n\n    if (typeof forcedMemberof !== 'undefined') {\n        partsRegExp = new RegExp('^(.*?)([' + sliceChars.join() + ']?)$');\n        name = longname.substr(forcedMemberof.length);\n        parts = forcedMemberof.match(partsRegExp);\n\n        if (parts[1]) {\n            memberof = parts[1] || forcedMemberof;\n        }\n        if (parts[2]) {\n            scopePunc = parts[2];\n        }\n    }\n    else if (longname) {\n        parts = (longname.match(new RegExp('^(:?(.+)([' + sliceChars.join() + ']))?(.+?)$')) || [])\n            .reverse();\n        name = parts[0] || '';\n        scopePunc = parts[1] || '';\n        memberof = parts[2] || '';\n    }\n\n    // like /** @name foo.bar(2) */\n    if ( /(.+)\\(([^)]+)\\)$/.test(name) ) {\n        name = RegExp.$1;\n        variation = RegExp.$2;\n    }\n\n    // restore quoted strings\n    i = tokens.length;\n    while (i--) {\n        longname = longname.replace('@{' + i + '}@', tokens[i]);\n        memberof = memberof.replace('@{' + i + '}@', tokens[i]);\n        scopePunc = scopePunc.replace('@{' + i + '}@', tokens[i]);\n        name = name.replace('@{' + i + '}@', tokens[i]);\n    }\n\n    return {\n        longname: longname,\n        memberof: memberof,\n        scope: scopePunc,\n        name: name,\n        variation: variation\n    };\n}\n\n// TODO: deprecate exports.shorten in favor of a better name\n/**\n    Given a longname like \"a.b#c(2)\", slice it up into an object\n    containing the memberof, the scope, the name, and variation.\n    @param {string} longname\n    @param {string} forcedMemberof\n    @returns {object} Representing the properties of the given name.\n */\nexports.shorten = function(longname, forcedMemberof) {\n    return atomize(longname, SCOPE_PUNC, forcedMemberof);\n};\n\n// TODO: docs\nexports.combine = function(parts) {\n    return [\n        (parts.memberof || ''),\n        (parts.scope || ''),\n        (parts.name || ''),\n        (parts.variation || '')\n    ].join('');\n};\n\n// TODO: docs\nexports.stripVariation = function(name) {\n    var parts = exports.shorten(name);\n\n    parts.variation = '';\n\n    return exports.combine(parts);\n};\n\nfunction splitLongname(longname, options) {\n    var chunks = [];\n    var currentNameInfo;\n    var nameInfo = {};\n    var previousName = longname;\n    var splitters = SCOPE_PUNC.concat('/');\n\n    options = _.defaults(options || {}, {\n        includeVariation: true\n    });\n\n    do {\n        if (!options.includeVariation) {\n            previousName = exports.stripVariation(previousName);\n        }\n        currentNameInfo = nameInfo[previousName] = atomize(previousName, splitters);\n        previousName = currentNameInfo.memberof;\n        chunks.push(currentNameInfo.scope + currentNameInfo.name);\n    } while (previousName);\n\n    return {\n        chunks: chunks.reverse(),\n        nameInfo: nameInfo\n    };\n}\n\n// TODO: docs\nexports.longnamesToTree = function longnamesToTree(longnames, doclets) {\n    var splitOptions = { includeVariation: false };\n    var tree = {};\n\n    longnames.forEach(function(longname) {\n        var currentLongname = '';\n        var currentParent = tree;\n        var nameInfo;\n        var processed;\n\n        // don't try to add empty longnames to the tree\n        if (!longname) {\n            return;\n        }\n\n        processed = splitLongname(longname, splitOptions);\n        nameInfo = processed.nameInfo;\n\n        processed.chunks.forEach(function(chunk) {\n            currentLongname += chunk;\n\n            if (currentParent !== tree) {\n                currentParent.children = currentParent.children || {};\n                currentParent = currentParent.children;\n            }\n\n            if (!hasOwnProp.call(currentParent, chunk)) {\n                currentParent[chunk] = nameInfo[currentLongname];\n            }\n\n            if (currentParent[chunk]) {\n                currentParent[chunk].doclet = doclets ? doclets[currentLongname] : null;\n                currentParent = currentParent[chunk];\n            }\n        });\n    });\n\n    return tree;\n};\n\n/**\n    Split a string that starts with a name and ends with a description into its parts.\n    Allows the defaultvalue (if present) to contain brackets. If the name is found to have\n    mismatched brackets, null is returned.\n    @param {string} nameDesc\n    @returns {object} Hash with \"name\" and \"description\" properties.\n */\nfunction splitNameMatchingBrackets(nameDesc) {\n    var buffer = [];\n    var c;\n    var stack = 0;\n    var stringEnd = null;\n\n    for (var i = 0; i < nameDesc.length; ++i) {\n        c = nameDesc[i];\n        buffer.push(c);\n\n        if (stringEnd) {\n            if (c === '\\\\' && i + 1 < nameDesc.length) {\n                buffer.push(nameDesc[++i]);\n            } else if (c === stringEnd) {\n                stringEnd = null;\n            }\n        } else if (c === '\"' || c === \"'\") {\n            stringEnd = c;\n        } else if (c === '[') {\n            ++stack;\n        } else if (c === ']') {\n            if (--stack === 0) {\n                break;\n            }\n        }\n    }\n\n    if (stack || stringEnd) {\n        return null;\n    }\n\n    nameDesc.substr(i).match(REGEXP_DESCRIPTION);\n    return {\n        name: buffer.join(''),\n        description: RegExp.$1\n    };\n}\n\n\n// TODO: deprecate exports.splitName in favor of a better name\n/**\n    Split a string that starts with a name and ends with a description into its parts.\n    @param {string} nameDesc\n    @returns {object} Hash with \"name\" and \"description\" properties.\n */\nexports.splitName = function(nameDesc) {\n    // like: name, [name], name text, [name] text, name - text, or [name] - text\n    // the hyphen must be on the same line as the name; this prevents us from treating a Markdown\n    // dash as a separator\n\n    // optional values get special treatment\n    var result = null;\n    if (nameDesc[0] === '[') {\n        result = splitNameMatchingBrackets(nameDesc);\n        if (result !== null) {\n            return result;\n        }\n    }\n\n    nameDesc.match(REGEXP_NAME_DESCRIPTION);\n    return {\n        name: RegExp.$1,\n        description: RegExp.$2\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/src/scanner.js":"/**\n    @module jsdoc/src/scanner\n    @requires module:fs\n\n    @author Michael Mathews <micmath@gmail.com>\n    @license Apache License 2.0 - See file 'LICENSE.md' in this project.\n */\n'use strict';\n\nvar env = require('jsdoc/env');\nvar fs = require('jsdoc/fs');\nvar logger = require('jsdoc/util/logger');\nvar path = require('jsdoc/path');\n\n/**\n    @constructor\n    @mixes module:events\n */\nexports.Scanner = function() {};\nexports.Scanner.prototype = Object.create( require('events').EventEmitter.prototype );\n\n/**\n    Recursively searches the given searchPaths for js files.\n    @param {Array.<string>} searchPaths\n    @param {number} [depth=1]\n    @fires sourceFileFound\n */\nexports.Scanner.prototype.scan = function(searchPaths, depth, filter) {\n    var currentFile;\n    var filePaths = [];\n    var isFile;\n    var self = this;\n\n    searchPaths = searchPaths || [];\n    depth = depth || 1;\n\n    searchPaths.forEach(function($) {\n        var filepath = path.resolve( env.pwd, decodeURIComponent($) );\n\n        try {\n            currentFile = fs.statSync(filepath);\n        }\n        catch (e) {\n            logger.error('Unable to find the source file or directory %s', filepath);\n            return;\n        }\n\n        if ( currentFile.isFile() ) {\n            filePaths.push(filepath);\n        }\n        else {\n            filePaths = filePaths.concat( fs.ls(filepath, depth) );\n        }\n    });\n\n    filePaths = filePaths.filter(function($) {\n        return filter.isIncluded($);\n    });\n\n    filePaths = filePaths.filter(function($) {\n        var e = { fileName: $ };\n        self.emit('sourceFileFound', e);\n\n        return !e.defaultPrevented;\n    });\n\n    return filePaths;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/fs.js":"/**\n * Extended version of the standard `fs` module.\n * @module jsdoc/fs\n */\n'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar stream = require('stream');\nvar mkdirp = require('mkdirp');\n\nvar ls = exports.ls = function(dir, recurse, _allFiles, _path) {\n    var file;\n    var files;\n    var isFile;\n\n    // first pass\n    if (_path === undefined) {\n        _allFiles = [];\n        _path = [dir];\n    }\n\n    if (!_path.length) {\n        return _allFiles;\n    }\n\n    if (recurse === undefined) {\n        recurse = 1;\n    }\n\n    try {\n        isFile = fs.statSync(dir).isFile();\n    }\n    catch (e) {\n        isFile = false;\n    }\n    if (isFile) {\n        files = [dir];\n    }\n    else {\n        files = fs.readdirSync(dir);\n    }\n\n    for (var i = 0, l = files.length; i < l; i++) {\n        file = String(files[i]);\n\n        // skip dot files\n        if (file.match(/^\\.[^\\.\\/\\\\]/)) {\n            continue;\n        }\n\n        if ( fs.statSync(path.join(_path.join('/'), file)).isDirectory() ) {\n            // it's a directory\n            _path.push(file);\n\n            if (_path.length - 1 < recurse) {\n                ls(_path.join('/'), recurse, _allFiles, _path);\n            }\n            _path.pop();\n        }\n        else {\n            // it's a file\n            _allFiles.push( path.normalize(path.join(_path.join('/'), file)) );\n        }\n    }\n\n    return _allFiles;\n};\n\nvar toDir = exports.toDir = function(_path) {\n    var isDirectory;\n\n    _path = path.normalize(_path);\n\n    try {\n        isDirectory = fs.statSync(_path).isDirectory();\n    }\n    catch (e) {\n        isDirectory = false;\n    }\n\n    if (isDirectory) {\n       return _path;\n    } else {\n        return path.dirname(_path);\n    }\n};\n\nexports.mkPath = function(_path) {\n    if ( Array.isArray(_path) ) {\n        _path = _path.join('');\n    }\n\n    mkdirp.sync(_path);\n};\n\n// adapted from http://procbits.com/2011/11/15/synchronous-file-copy-in-node-js\nexports.copyFileSync = function(inFile, outDir, fileName) {\n    var BUF_LENGTH = 64 * 1024;\n\n    var read;\n    var write;\n\n    var buffer = new Buffer(BUF_LENGTH);\n    var bytesRead = 1;\n    var outFile = path.join( outDir, fileName || path.basename(inFile) );\n    var pos = 0;\n\n    mkdirp.sync(outDir);\n    read = fs.openSync(inFile, 'r');\n    write = fs.openSync(outFile, 'w');\n\n    while (bytesRead > 0) {\n        bytesRead = fs.readSync(read, buffer, 0, BUF_LENGTH, pos);\n        fs.writeSync(write, buffer, 0, bytesRead);\n        pos += bytesRead;\n    }\n\n    fs.closeSync(read);\n    return fs.closeSync(write);\n};\n\nObject.keys(fs).forEach(function(member) {\n    exports[member] = fs[member];\n});\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/util/logger.js":"/**\n * Logging tools for JSDoc.\n *\n * Log messages are printed to the console based on the current logging level. By default, messages\n * at level `{@link module:jsdoc/util/logger.LEVELS.ERROR}` or above are logged; all other messages\n * are ignored.\n *\n * In addition, the module object emits an event whenever a logger method is called, regardless of\n * the current logging level. The event's name is the string `logger:` followed by the logger's name\n * (for example, `logger:error`). The event handler receives an array of arguments that were passed\n * to the logger method.\n *\n * Each logger method accepts a `message` parameter that may contain zero or more placeholders. Each\n * placeholder is replaced by the corresponding argument following the message. If the placeholder\n * does not have a corresponding argument, the placeholder is not replaced.\n *\n * The following placeholders are supported:\n *\n * + `%s`: String.\n * + `%d`: Number.\n * + `%j`: JSON.\n *\n * @module jsdoc/util/logger\n * @extends module:events.EventEmitter\n * @example\n * var logger = require('jsdoc/util/logger');\n *\n * var data = {\n *   foo: 'bar'\n * };\n * var name = 'baz';\n *\n * logger.warn('%j %s', data, name);  // prints '{\"foo\":\"bar\"} baz'\n * @see http://nodejs.org/api/util.html#util_util_format_format\n */\n'use strict';\n\nvar util = require('util');\n\nfunction Logger() {}\nutil.inherits(Logger, require('events').EventEmitter);\n\nvar logger = module.exports = new Logger();\n\n/**\n * Logging levels for the JSDoc logger. The default logging level is\n * {@link module:jsdoc/util/logger.LEVELS.ERROR}.\n *\n * @alias module:jsdoc/util/logger.LEVELS\n * @enum\n * @type {number}\n */\nvar LEVELS = logger.LEVELS = {\n    /**\n     * Do not log any messages.\n     *\n     * @alias module:jsdoc/util/logger.LEVELS.SILENT\n     */\n    SILENT: 0,\n    /**\n     * Log fatal errors that prevent JSDoc from running.\n     *\n     * @alias module:jsdoc/util/logger.LEVELS.FATAL\n     */\n    FATAL: 10,\n    /**\n     * Log all errors, including errors from which JSDoc can recover.\n     *\n     * @alias module:jsdoc/util/logger.LEVELS.ERROR\n     */\n    ERROR: 20,\n    /**\n     * Log the following messages:\n     *\n     * + Warnings\n     * + Errors\n     *\n     * @alias module:jsdoc/util/logger.LEVELS.WARN\n     */\n    WARN: 30,\n    /**\n     * Log the following messages:\n     *\n     * + Informational messages\n     * + Warnings\n     * + Errors\n     *\n     * @alias module:jsdoc/util/logger.LEVELS.INFO\n     */\n    INFO: 40,\n    /**\n     * Log the following messages:\n     *\n     * + Debugging messages\n     * + Informational messages\n     * + Warnings\n     * + Errors\n     *\n     * @alias module:jsdoc/util/logger.LEVELS.DEBUG\n     */\n    DEBUG: 50,\n    /**\n     * Log all messages.\n     *\n     * @alias module:jsdoc/util/logger.LEVELS.VERBOSE\n     */\n    VERBOSE: 1000\n};\n\nvar DEFAULT_LEVEL = LEVELS.WARN;\nvar logLevel = DEFAULT_LEVEL;\n\nvar PREFIXES = {\n    DEBUG: 'DEBUG: ',\n    ERROR: 'ERROR: ',\n    FATAL: 'FATAL: ',\n    WARN: 'WARNING: '\n};\n\n// Add a prefix to a log message if necessary.\nfunction addPrefix(args, prefix) {\n    var updatedArgs;\n\n    if (prefix && typeof args[0] === 'string') {\n        updatedArgs = args.slice(0);\n        updatedArgs[0] = prefix + updatedArgs[0];\n    }\n\n    return updatedArgs || args;\n}\n\n// TODO: document events\nfunction wrapLogFunction(name, func) {\n    var eventName = 'logger:' + name;\n    var upperCaseName = name.toUpperCase();\n    var level = LEVELS[upperCaseName];\n    var prefix = PREFIXES[upperCaseName];\n\n    return function() {\n        var loggerArgs;\n\n        var args = Array.prototype.slice.call(arguments, 0);\n\n        if (logLevel >= level) {\n            loggerArgs = addPrefix(args, prefix);\n            func.apply(null, loggerArgs);\n        }\n\n        args.unshift(eventName);\n        logger.emit.apply(logger, args);\n    };\n}\n\n// Print a message to STDOUT without a terminating newline.\nfunction printToStdout() {\n    var args = Array.prototype.slice.call(arguments, 0);\n\n    process.stdout.write( util.format.apply(util, args) );\n}\n\n/**\n * Log a message at log level {@link module:jsdoc/util/logger.LEVELS.DEBUG}.\n *\n * @alias module:jsdoc/util/logger.debug\n * @param {string} message - The message to log.\n * @param {...*=} values - The values that will replace the message's placeholders.\n */\nlogger.debug = wrapLogFunction('debug', console.info);\n/**\n * Print a string at log level {@link module:jsdoc/util/logger.LEVELS.DEBUG}. The string is not\n * terminated by a newline.\n *\n * @alias module:jsdoc/util/logger.printDebug\n * @param {string} message - The message to log.\n * @param {...*=} values - The values that will replace the message's placeholders.\n */\nlogger.printDebug = wrapLogFunction('debug', printToStdout);\n/**\n * Log a message at log level {@link module:jsdoc/util/logger.LEVELS.ERROR}.\n *\n * @alias module:jsdoc/util/logger.error\n * @param {string} message - The message to log.\n * @param {...*=} values - The values that will replace the message's placeholders.\n */\nlogger.error = wrapLogFunction('error', console.error);\n/**\n * Log a message at log level {@link module:jsdoc/util/logger.LEVELS.FATAL}.\n *\n * @alias module:jsdoc/util/logger.fatal\n * @param {string} message - The message to log.\n * @param {...*=} values - The values that will replace the message's placeholders.\n */\nlogger.fatal = wrapLogFunction('fatal', console.error);\n/**\n * Log a message at log level {@link module:jsdoc/util/logger.LEVELS.INFO}.\n *\n * @alias module:jsdoc/util/logger.info\n * @param {string} message - The message to log.\n * @param {...*=} values - The values that will replace the message's placeholders.\n */\nlogger.info = wrapLogFunction('info', console.info);\n/**\n * Print a string at log level {@link module:jsdoc/util/logger.LEVELS.INFO}. The string is not\n * terminated by a newline.\n *\n * @alias module:jsdoc/util/logger.printInfo\n * @param {string} message - The message to log.\n * @param {...*=} values - The values that will replace the message's placeholders.\n */\nlogger.printInfo = wrapLogFunction('info', printToStdout);\n/**\n * Log a message at log level {@link module:jsdoc/util/logger.LEVELS.VERBOSE}.\n *\n * @alias module:jsdoc/util/logger.verbose\n * @param {string} message - The message to log.\n * @param {...*=} values - The values that will replace the message's placeholders.\n */\nlogger.verbose = wrapLogFunction('verbose', console.info);\n/**\n * Print a string at log level {@link module:jsdoc/util/logger.LEVELS.VERBOSE}. The string is not\n * terminated by a newline.\n *\n * @alias module:jsdoc/util/logger.printVerbose\n * @param {string} message - The message to log.\n * @param {...*=} values - The values that will replace the message's placeholders.\n */\nlogger.printVerbose = wrapLogFunction('verbose', printToStdout);\n/**\n * Log a message at log level {@link module:jsdoc/util/logger.LEVELS.WARN}.\n *\n * @alias module:jsdoc/util/logger.warn\n * @param {string} message - The message to log.\n * @param {...*=} values - The values that will replace the message's placeholders.\n */\nlogger.warn = wrapLogFunction('warn', console.warn);\n\n/**\n * Set the log level.\n *\n * @alias module:jsdoc/util/logger.setLevel\n * @param {module:jsdoc/util/logger.LEVELS} level - The log level to use.\n */\nlogger.setLevel = function setLevel(level) {\n    logLevel = (level !== undefined) ? level : DEFAULT_LEVEL;\n};\n\n/**\n * Get the current log level.\n *\n * @alias module:jsdoc/util/logger.getLevel\n * @return {module:jsdoc/util/logger.LEVELS} The current log level.\n */\nlogger.getLevel = function getLevel() {\n    return logLevel;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/path.js":"/**\n * Extended version of the standard `path` module.\n * @module jsdoc/path\n */\n'use strict';\n\nvar env = require('jsdoc/env');\nvar fs = require('fs');\nvar path = require('path');\n\nfunction prefixReducer(previousPath, current) {\n    var currentPath = [];\n\n    // if previousPath is defined, but has zero length, there's no common prefix; move along\n    if (previousPath && !previousPath.length) {\n        return currentPath;\n    }\n\n    currentPath = path.resolve(env.pwd, current).split(path.sep) || [];\n\n    if (previousPath && currentPath.length) {\n        // remove chunks that exceed the previous path's length\n        currentPath = currentPath.slice(0, previousPath.length);\n\n        // if a chunk doesn't match the previous path, remove everything from that chunk on\n        for (var i = 0, l = currentPath.length; i < l; i++) {\n            if (currentPath[i] !== previousPath[i]) {\n                currentPath.splice(i, currentPath.length - i);\n                break;\n            }\n        }\n    }\n\n    return currentPath;\n}\n\n/**\n * Find the common prefix for an array of paths. If there is a common prefix, a trailing separator\n * is appended to the prefix. Relative paths are resolved relative to the current working directory.\n *\n * For example, assuming that the current working directory is `/Users/jsdoc`:\n *\n * + For the single path `foo/bar/baz/qux.js`, the common prefix is `foo/bar/baz/`.\n * + For paths `foo/bar/baz/qux.js`, `foo/bar/baz/quux.js`, and `foo/bar/baz.js`, the common prefix\n * is `/Users/jsdoc/foo/bar/`.\n * + For paths `../jsdoc/foo/bar/baz/qux/quux/test.js`, `/Users/jsdoc/foo/bar/bazzy.js`, and\n * `../../Users/jsdoc/foo/bar/foobar.js`, the common prefix is `/Users/jsdoc/foo/bar/`.\n * + For paths `foo/bar/baz/qux.js` and `../../Library/foo/bar/baz.js`, there is no common prefix,\n * and an empty string is returned.\n *\n * @param {Array.<string>} paths - The paths to search for a common prefix.\n * @return {string} The common prefix, or an empty string if there is no common prefix.\n */\nexports.commonPrefix = function(paths) {\n    var segments;\n\n    var prefix = '';\n\n    paths = paths || [];\n\n    // if there's only one path, its resolved dirname (plus a trailing slash) is the common prefix\n    if (paths.length === 1) {\n        prefix = path.resolve(env.pwd, paths[0]);\n        if ( path.extname(prefix) ) {\n            prefix = path.dirname(prefix);\n        }\n\n        prefix += path.sep;\n    }\n    else {\n        segments = paths.reduce(prefixReducer, undefined) || [];\n\n        // if there's anything left (other than a placeholder for a leading slash), add a\n        // placeholder for a trailing slash\n        if ( segments.length && (segments.length > 1 || segments[0] !== '') ) {\n            segments.push('');\n        }\n\n        prefix = segments.join(path.sep);\n    }\n\n    return prefix;\n};\n\n/**\n * Retrieve the fully qualified path to the requested resource.\n *\n * If the resource path is specified as a relative path, JSDoc searches for the path in the\n * directory where the JSDoc configuration file is located, then in the current working directory,\n * and finally in the JSDoc directory.\n *\n * If the resource path is specified as a fully qualified path, JSDoc uses the path as-is.\n *\n * @param {string} filepath - The path to the requested resource. May be an absolute path; a path\n * relative to the JSDoc directory; or a path relative to the current working directory.\n * @param {string} [filename] - The filename of the requested resource.\n * @return {string} The fully qualified path to the requested resource.\n * Includes the filename if one was provided.\n */\nexports.getResourcePath = function(filepath, filename) {\n    var result = null;\n\n    function pathExists(_path) {\n        try {\n            fs.readdirSync(_path);\n        }\n        catch (e) {\n            return false;\n        }\n\n        return true;\n    }\n\n    // absolute paths are normalized by path.resolve on the first pass\n    [path.dirname(env.opts.configure || ''), env.pwd, env.dirname].forEach(function(_path) {\n        if (!result && _path) {\n            _path = path.resolve(_path, filepath);\n            if ( pathExists(_path) ) {\n                result = _path;\n            }\n        }\n    });\n\n    if (result) {\n        result = filename ? path.join(result, filename) : result;\n    }\n\n    return result;\n};\n\nObject.keys(path).forEach(function(member) {\n    exports[member] = path[member];\n});\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/cli.js":"/* global java */\n/* eslint no-process-exit:0, strict: [2, \"function\"] */\n/**\n * Helper methods for running JSDoc on the command line.\n *\n * A few critical notes for anyone who works on this module:\n *\n * + The module should really export an instance of `cli`, and `props` should be properties of a\n * `cli` instance.\n *\n * @private\n */\nmodule.exports = (function() {\n'use strict';\n\nvar app = require('jsdoc/app');\nvar env = require('jsdoc/env');\nvar logger = require('jsdoc/util/logger');\nvar stripJsonComments = require('strip-json-comments');\nvar Promise = require('bluebird');\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\nvar props = {\n    docs: [],\n    packageJson: null,\n    shouldExitWithError: false,\n    tmpdir: null\n};\n\nvar FATAL_ERROR_MESSAGE = 'Exiting JSDoc because an error occurred. See the previous log ' +\n    'messages for details.';\nvar cli = {};\n\n// TODO: docs\ncli.setVersionInfo = function() {\n    var fs = require('fs');\n    var path = require('path');\n\n    // allow this to throw--something is really wrong if we can't read our own package file\n    var info = JSON.parse( fs.readFileSync(path.join(env.dirname, 'package.json'), 'utf8') );\n\n    env.version = {\n        number: info.version,\n        revision: new Date( parseInt(info.revision, 10) ).toUTCString()\n    };\n\n    return cli;\n};\n\n// TODO: docs\ncli.loadConfig = function() {\n    var _ = require('underscore');\n    var args = require('jsdoc/opts/args');\n    var Config = require('jsdoc/config');\n    var fs = require('jsdoc/fs');\n    var path = require('jsdoc/path');\n\n    var confPath;\n    var isFile;\n\n    var defaultOpts = {\n        destination: './out/',\n        encoding: 'utf8'\n    };\n\n    try {\n        env.opts = args.parse(env.args);\n    }\n    catch (e) {\n        console.error(e.message + '\\n');\n        cli.printHelp().then(function () {\n            cli.exit(1);\n        });\n    }\n\n    confPath = env.opts.configure || path.join(env.dirname, 'conf.json');\n    try {\n        isFile = fs.statSync(confPath).isFile();\n    }\n    catch (e) {\n        isFile = false;\n    }\n\n    if ( !isFile && !env.opts.configure ) {\n        confPath = path.join(env.dirname, 'conf.json.EXAMPLE');\n    }\n\n    try {\n        env.conf = new Config( stripJsonComments(fs.readFileSync(confPath, 'utf8')) )\n            .get();\n    }\n    catch (e) {\n        cli.exit(1, 'Cannot parse the config file ' + confPath + ': ' + e + '\\n' +\n            FATAL_ERROR_MESSAGE);\n    }\n\n    // look for options on the command line, in the config file, and in the defaults, in that order\n    env.opts = _.defaults(env.opts, env.conf.opts, defaultOpts);\n\n    return cli;\n};\n\n// TODO: docs\ncli.configureLogger = function() {\n    function recoverableError() {\n        props.shouldExitWithError = true;\n    }\n\n    function fatalError() {\n        cli.exit(1);\n    }\n\n    if (env.opts.debug) {\n        logger.setLevel(logger.LEVELS.DEBUG);\n    }\n    else if (env.opts.verbose) {\n        logger.setLevel(logger.LEVELS.INFO);\n    }\n\n    if (env.opts.pedantic) {\n        logger.once('logger:warn', recoverableError);\n        logger.once('logger:error', fatalError);\n    }\n    else {\n        logger.once('logger:error', recoverableError);\n    }\n\n    logger.once('logger:fatal', fatalError);\n\n    return cli;\n};\n\n// TODO: docs\ncli.logStart = function() {\n    logger.debug( cli.getVersion() );\n\n    logger.debug('Environment info: %j', {\n        env: {\n            conf: env.conf,\n            opts: env.opts\n        }\n    });\n};\n\n// TODO: docs\ncli.logFinish = function() {\n    var delta;\n    var deltaSeconds;\n\n    if (env.run.finish && env.run.start) {\n        delta = env.run.finish.getTime() - env.run.start.getTime();\n    }\n\n    if (delta !== undefined) {\n        deltaSeconds = (delta / 1000).toFixed(2);\n        logger.info('Finished running in %s seconds.', deltaSeconds);\n    }\n};\n\n// TODO: docs\ncli.runCommand = function(cb) {\n    var cmd;\n\n    var opts = env.opts;\n\n    if (opts.help) {\n        cmd = cli.printHelp;\n    }\n    else if (opts.test) {\n        cmd = cli.runTests;\n    }\n    else if (opts.version) {\n        cmd = cli.printVersion;\n    }\n    else {\n        cmd = cli.main;\n    }\n\n    cmd().then(function (errorCode) {\n        if (!errorCode && props.shouldExitWithError) {\n            errorCode = 1;\n        }\n        cb(errorCode);\n    });\n};\n\n// TODO: docs\ncli.printHelp = function() {\n    cli.printVersion();\n    console.log( '\\n' + require('jsdoc/opts/args').help() + '\\n' );\n    console.log('Visit http://usejsdoc.org for more information.');\n    return Promise.resolve(0);\n};\n\n// TODO: docs\ncli.runTests = function() {\n    var path = require('jsdoc/path');\n\n    var runner = Promise.promisify(require( path.join(env.dirname, 'test/runner') ));\n\n    console.log('Running tests...');\n    return runner();\n};\n\n// TODO: docs\ncli.getVersion = function() {\n    return 'JSDoc ' + env.version.number + ' (' + env.version.revision + ')';\n};\n\n// TODO: docs\ncli.printVersion = function() {\n    console.log( cli.getVersion() );\n    return Promise.resolve(0);\n};\n\n// TODO: docs\ncli.main = function() {\n    cli.scanFiles();\n\n    if (env.sourceFiles.length === 0) {\n        console.log('There are no input files to process.\\n');\n        return cli.printHelp();\n    } else {\n        return cli.createParser()\n            .parseFiles()\n            .processParseResults()\n            .then(function () {\n                env.run.finish = new Date();\n                return 0;\n            });\n    }\n};\n\nfunction readPackageJson(filepath) {\n    var fs = require('jsdoc/fs');\n\n    try {\n        return stripJsonComments( fs.readFileSync(filepath, 'utf8') );\n    }\n    catch (e) {\n        logger.error('Unable to read the package file \"%s\"', filepath);\n        return null;\n    }\n}\n\nfunction buildSourceList() {\n    var fs = require('jsdoc/fs');\n    var Readme = require('jsdoc/readme');\n\n    var packageJson;\n    var readmeHtml;\n    var sourceFile;\n    var sourceFiles = env.opts._ ? env.opts._.slice(0) : [];\n\n    if (env.conf.source && env.conf.source.include) {\n        sourceFiles = sourceFiles.concat(env.conf.source.include);\n    }\n\n    // load the user-specified package/README files, if any\n    if (env.opts.package) {\n        packageJson = readPackageJson(env.opts.package);\n    }\n    if (env.opts.readme) {\n        readmeHtml = new Readme(env.opts.readme).html;\n    }\n\n    // source files named `package.json` or `README.md` get special treatment, unless the user\n    // explicitly specified a package and/or README file\n    for (var i = 0, l = sourceFiles.length; i < l; i++) {\n        sourceFile = sourceFiles[i];\n\n        if ( !env.opts.package && /\\bpackage\\.json$/i.test(sourceFile) ) {\n            packageJson = readPackageJson(sourceFile);\n            sourceFiles.splice(i--, 1);\n        }\n\n        if ( !env.opts.readme && /(\\bREADME|\\.md)$/i.test(sourceFile) ) {\n            readmeHtml = new Readme(sourceFile).html;\n            sourceFiles.splice(i--, 1);\n        }\n    }\n\n    props.packageJson = packageJson;\n    env.opts.readme = readmeHtml;\n\n    return sourceFiles;\n}\n\n// TODO: docs\ncli.scanFiles = function() {\n    var Filter = require('jsdoc/src/filter').Filter;\n\n    var filter;\n\n    env.opts._ = buildSourceList();\n\n    // are there any files to scan and parse?\n    if (env.conf.source && env.opts._.length) {\n        filter = new Filter(env.conf.source);\n\n        env.sourceFiles = app.jsdoc.scanner.scan(env.opts._, (env.opts.recurse ? 10 : undefined),\n            filter);\n    }\n\n    return cli;\n};\n\nfunction resolvePluginPaths(paths) {\n    var path = require('jsdoc/path');\n\n    var pluginPaths = [];\n\n    paths.forEach(function(plugin) {\n        var basename = path.basename(plugin);\n        var dirname = path.dirname(plugin);\n        var pluginPath = path.getResourcePath(dirname);\n\n        if (!pluginPath) {\n            logger.error('Unable to find the plugin \"%s\"', plugin);\n            return;\n        }\n\n        pluginPaths.push( path.join(pluginPath, basename) );\n    });\n\n    return pluginPaths;\n}\n\ncli.createParser = function() {\n    var handlers = require('jsdoc/src/handlers');\n    var parser = require('jsdoc/src/parser');\n    var path = require('jsdoc/path');\n    var plugins = require('jsdoc/plugins');\n\n    app.jsdoc.parser = parser.createParser(env.conf.parser);\n\n    if (env.conf.plugins) {\n        env.conf.plugins = resolvePluginPaths(env.conf.plugins);\n        plugins.installPlugins(env.conf.plugins, app.jsdoc.parser);\n    }\n\n    handlers.attachTo(app.jsdoc.parser);\n\n    return cli;\n};\n\ncli.parseFiles = function() {\n    var augment = require('jsdoc/augment');\n    var borrow = require('jsdoc/borrow');\n    var Package = require('jsdoc/package').Package;\n\n    var docs;\n    var packageDocs;\n\n    props.docs = docs = app.jsdoc.parser.parse(env.sourceFiles, env.opts.encoding);\n\n    // If there is no package.json, just create an empty package\n    packageDocs = new Package(props.packageJson);\n    packageDocs.files = env.sourceFiles || [];\n    docs.push(packageDocs);\n\n    logger.debug('Indexing doclets...');\n    borrow.indexAll(docs);\n    logger.debug('Adding inherited symbols, mixins, and interface implementations...');\n    augment.augmentAll(docs);\n    logger.debug('Adding borrowed doclets...');\n    borrow.resolveBorrows(docs);\n    logger.debug('Post-processing complete.');\n\n    app.jsdoc.parser.fireProcessingComplete(docs);\n\n    return cli;\n};\n\ncli.processParseResults = function() {\n    if (env.opts.explain) {\n        cli.dumpParseResults();\n        return Promise.resolve();\n    }\n    else {\n        cli.resolveTutorials();\n        return cli.generateDocs();\n    }\n};\n\ncli.dumpParseResults = function() {\n    console.log(require('jsdoc/util/dumper').dump(props.docs));\n\n    return cli;\n};\n\ncli.resolveTutorials = function() {\n    var resolver = require('jsdoc/tutorial/resolver');\n\n    if (env.opts.tutorials) {\n        resolver.load(env.opts.tutorials);\n        resolver.resolve();\n    }\n\n    return cli;\n};\n\ncli.generateDocs = function() {\n    var path = require('jsdoc/path');\n    var resolver = require('jsdoc/tutorial/resolver');\n    var taffy = require('taffydb').taffy;\n\n    var template;\n\n    env.opts.template = (function() {\n        var publish = env.opts.template || 'templates/default';\n        var templatePath = path.getResourcePath(publish);\n\n        // if we didn't find the template, keep the user-specified value so the error message is\n        // useful\n        return templatePath || env.opts.template;\n    })();\n\n    try {\n        template = require(env.opts.template + '/publish');\n    }\n    catch (e) {\n        logger.fatal('Unable to load template: ' + e.message || e);\n    }\n\n    // templates should include a publish.js file that exports a \"publish\" function\n    if (template.publish && typeof template.publish === 'function') {\n        logger.info('Generating output files...');\n        var publishPromise = template.publish(\n            taffy(props.docs),\n            env.opts,\n            resolver.root\n        );\n\n        return Promise.resolve(publishPromise);\n    }\n    else {\n        logger.fatal(env.opts.template + ' does not export a \"publish\" function. Global ' +\n            '\"publish\" functions are no longer supported.');\n    }\n    return Promise.resolve();\n};\n\n// TODO: docs\ncli.exit = function(exitCode, message) {\n    if (exitCode > 0) {\n        if (message) {\n            console.error(message);\n        }\n        process.exit(exitCode);\n    }\n};\n\nreturn cli;\n})();\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/opts/args.js":"/**\n * @module jsdoc/opts/args\n * @requires jsdoc/opts/argparser\n * @author Michael Mathews <micmath@gmail.com>\n * @license Apache License 2.0 - See file 'LICENSE.md' in this project.\n */\n'use strict';\n\nvar ArgParser = require('jsdoc/opts/argparser');\nvar cast = require('jsdoc/util/cast').cast;\nvar querystring = require('querystring');\nvar util = require('util');\n\nvar ourOptions;\n\nvar argParser = new ArgParser();\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\nfunction parseQuery(str) {\n    return cast( querystring.parse(str) );\n}\n\n/* eslint-disable no-multi-spaces */\nargParser.addOption('a', 'access',      true,  'Only display symbols with the given access: \"public\", \"protected\", \"private\" or \"undefined\", or \"all\" for all access levels. Default: all except \"private\"', true);\nargParser.addOption('c', 'configure',   true,  'The path to the configuration file. Default: path/to/jsdoc/conf.json');\nargParser.addOption('d', 'destination', true,  'The path to the output folder. Use \"console\" to dump data to the console. Default: ./out/');\nargParser.addOption('',  'debug',       false, 'Log information for debugging JSDoc.');\nargParser.addOption('e', 'encoding',    true,  'Assume this encoding when reading all source files. Default: utf8');\nargParser.addOption('h', 'help',        false, 'Print this message and quit.');\nargParser.addOption('',  'match',       true,  'When running tests, only use specs whose names contain <value>.', true);\nargParser.addOption('',  'nocolor',     false, 'When running tests, do not use color in console output.');\nargParser.addOption('p', 'private',     false, 'Display symbols marked with the @private tag. Equivalent to \"--access all\". Default: false');\nargParser.addOption('P', 'package',     true,  'The path to the project\\'s package file. Default: path/to/sourcefiles/package.json');\nargParser.addOption('',  'pedantic',    false, 'Treat errors as fatal errors, and treat warnings as errors. Default: false');\nargParser.addOption('q', 'query',       true,  'A query string to parse and store in jsdoc.env.opts.query. Example: foo=bar&baz=true', false, parseQuery);\nargParser.addOption('r', 'recurse',     false, 'Recurse into subdirectories when scanning for source files and tutorials.');\nargParser.addOption('R', 'readme',      true,  'The path to the project\\'s README file. Default: path/to/sourcefiles/README.md');\nargParser.addOption('t', 'template',    true,  'The path to the template to use. Default: path/to/jsdoc/templates/default');\nargParser.addOption('T', 'test',        false, 'Run all tests and quit.');\nargParser.addOption('u', 'tutorials',   true,  'Directory in which JSDoc should search for tutorials.');\nargParser.addOption('v', 'version',     false, 'Display the version number and quit.');\nargParser.addOption('',  'verbose',     false, 'Log detailed information to the console as JSDoc runs.');\nargParser.addOption('X', 'explain',     false, 'Dump all found doclet internals to console and quit.');\n/* eslint-enable no-multi-spaces */\n\n// Options that are no longer supported and should be ignored\nargParser.addIgnoredOption('l', 'lenient'); // removed in JSDoc 3.3.0\n\n/**\n * Set the options for this app.\n * @throws {Error} Illegal arguments will throw errors.\n * @param {string|String[]} args The command line arguments for this app.\n */\nexports.parse = function(args) {\n    args = args || [];\n\n    if (typeof args === 'string' || args.constructor === String) {\n        args = String(args).split(/\\s+/g);\n    }\n\n    ourOptions = argParser.parse(args);\n\n    return ourOptions;\n};\n\n/**\n * Retrieve help message for options.\n */\nexports.help = function() {\n    return argParser.help();\n};\n\n/**\n * Get a named option.\n * @variation name\n * @param {string} name The name of the option.\n * @return {string} The value associated with the given name.\n *//**\n * Get all the options for this app.\n * @return {Object} A collection of key/values representing all the options.\n */\nexports.get = function(name) {\n    if (typeof name === 'undefined') {\n        return ourOptions;\n    }\n    else if ( hasOwnProp.call(ourOptions, name) ) {\n        return ourOptions[name];\n    }\n    return undefined;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/opts/argparser.js":"/**\n * Parse the command line arguments.\n * @module jsdoc/opts/argparser\n * @author Michael Mathews <micmath@gmail.com>\n * @license Apache License 2.0 - See file 'LICENSE.md' in this project.\n */\n'use strict';\n\nvar _ = require('underscore');\nvar util = require('util');\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\n/**\n * Create an instance of the parser.\n * @classdesc A parser to interpret the key-value pairs entered on the command line.\n * @constructor\n * @alias module:jsdoc/opts/argparser\n */\nvar ArgParser = function() {\n    this._options = [];\n    this._shortNameIndex = {};\n    this._longNameIndex = {};\n};\n\nArgParser.prototype._getOptionByShortName = function(name) {\n    if (hasOwnProp.call(this._shortNameIndex, name)) {\n        return this._options[this._shortNameIndex[name]];\n    }\n    return null;\n};\n\nArgParser.prototype._getOptionByLongName = function(name) {\n    if (hasOwnProp.call(this._longNameIndex, name)) {\n        return this._options[this._longNameIndex[name]];\n    }\n    return null;\n};\n\nArgParser.prototype._addOption = function(option) {\n    var currentIndex;\n\n    var longName = option.longName;\n    var shortName = option.shortName;\n\n    this._options.push(option);\n    currentIndex = this._options.length - 1;\n\n    if (shortName) {\n        this._shortNameIndex[shortName] = currentIndex;\n    }\n    if (longName) {\n        this._longNameIndex[longName] = currentIndex;\n    }\n\n    return this;\n};\n\n/**\n * Provide information about a legal option.\n * @param {character} shortName The short name of the option, entered like: -T.\n * @param {string}    longName The equivalent long name of the option, entered like: --test.\n * @param {boolean}   hasValue Does this option require a value? Like: -t templatename\n * @param {string}    helpText A brief description of the option.\n * @param {boolean}   [canHaveMultiple=false] Set to `true` if the option can be provided more than once.\n * @param {function}  [coercer] A function to coerce the given value to a specific type.\n * @return {this}\n * @example\n * myParser.addOption('t', 'template', true, 'The path to the template.');\n * myParser.addOption('h', 'help', false, 'Show the help message.');\n */\nArgParser.prototype.addOption = function(shortName, longName, hasValue, helpText, canHaveMultiple, coercer) {\n    var option = {\n        shortName: shortName,\n        longName: longName,\n        hasValue: hasValue,\n        helpText: helpText,\n        canHaveMultiple: (canHaveMultiple || false),\n        coercer: coercer\n    };\n\n    return this._addOption(option);\n};\n\n// TODO: refactor addOption to accept objects, then get rid of this method\n/**\n * Provide information about an option that should not cause an error if present, but that is always\n * ignored (for example, an option that was used in previous versions but is no longer supported).\n *\n * @private\n * @param {string} shortName - The short name of the option with a leading hyphen (for example,\n * `-v`).\n * @param {string} longName - The long name of the option with two leading hyphens (for example,\n * `--version`).\n */\nArgParser.prototype.addIgnoredOption = function(shortName, longName) {\n    var option = {\n        shortName: shortName,\n        longName: longName,\n        ignore: true\n    };\n\n    return this._addOption(option);\n};\n\nfunction padding(length) {\n    return new Array(length + 1).join(' ');\n}\n\nfunction padLeft(str, length) {\n    return padding(length) + str;\n}\n\nfunction padRight(str, length) {\n    return str + padding(length);\n}\n\nfunction findMaxLength(arr) {\n    var max = 0;\n\n    arr.forEach(function(item) {\n        if (item.length > max) {\n            max = item.length;\n        }\n    });\n\n    return max;\n}\n\nfunction concatWithMaxLength(items, maxLength) {\n    var result = '';\n    // to prevent endless loops, always use the first item, regardless of length\n    result += items.shift();\n\n    while ( items.length && (result.length + items[0].length < maxLength) ) {\n        result += ' ' + items.shift();\n    }\n\n    return result;\n}\n\n// we want to format names and descriptions like this:\n// |    -f, --foo    Very long description very long description very long    |\n// |                 description very long description.                       |\nfunction formatHelpInfo(options) {\n    var MARGIN_LENGTH = 4;\n    var results = [];\n\n    var maxLength = process.stdout.columns;\n    var maxNameLength = findMaxLength(options.names);\n    var maxDescriptionLength = findMaxLength(options.descriptions);\n\n    var wrapDescriptionAt = maxLength - (MARGIN_LENGTH * 3) - maxNameLength;\n    // build the string for each option\n    options.names.forEach(function(name, i) {\n        var result;\n        var partialDescription;\n        var words;\n\n        // add a left margin to the name\n        result = padLeft(options.names[i], MARGIN_LENGTH);\n        // and a right margin, with extra padding so the descriptions line up with one another\n        result = padRight(result, maxNameLength - options.names[i].length + MARGIN_LENGTH);\n\n        // split the description on spaces\n        words = options.descriptions[i].split(' ');\n        // add as much of the description as we can fit on the first line\n        result += concatWithMaxLength(words, wrapDescriptionAt);\n        // if there's anything left, keep going until we've consumed the description\n        while (words.length) {\n            partialDescription = padding( maxNameLength + (MARGIN_LENGTH * 2) );\n            partialDescription += concatWithMaxLength(words, wrapDescriptionAt);\n            result += '\\n' + partialDescription;\n        }\n\n        results.push(result);\n    });\n\n    return results;\n}\n\n/**\n * Generate a summary of all the options with corresponding help text.\n * @returns {string}\n */\nArgParser.prototype.help = function() {\n    var options = {\n        names: [],\n        descriptions: []\n    };\n\n    this._options.forEach(function(option) {\n        var name = '';\n\n        // don't show ignored options\n        if (option.ignore) {\n            return;\n        }\n\n        if (option.shortName) {\n            name += '-' + option.shortName + (option.longName ? ', ' : '');\n        }\n\n        if (option.longName) {\n            name += '--' + option.longName;\n        }\n\n        if (option.hasValue) {\n            name += ' <value>';\n        }\n\n        options.names.push(name);\n        options.descriptions.push(option.helpText);\n    });\n\n    return 'Options:\\n' + formatHelpInfo(options).join('\\n');\n};\n\n/**\n * Get the options.\n * @param {Array.<string>} args An array, like ['-x', 'hello']\n * @param {Object} [defaults={}] An optional collection of default values.\n * @returns {Object} The keys will be the longNames, or the shortName if no longName is defined for\n * that option. The values will be the values provided, or `true` if the option accepts no value.\n */\nArgParser.prototype.parse = function(args, defaults) {\n    var result = defaults && _.defaults({}, defaults) || {};\n\n    result._ = [];\n    for (var i = 0, leni = args.length; i < leni; i++) {\n        var arg = '' + args[i],\n            next = (i < leni - 1) ? '' + args[i + 1] : null,\n            option,\n            shortName = null,\n            longName,\n            name,\n            value = null;\n\n        // like -t\n        if (arg.charAt(0) === '-') {\n            // like --template\n            if (arg.charAt(1) === '-') {\n                name = longName = arg.slice(2);\n                option = this._getOptionByLongName(longName);\n            }\n            else {\n                name = shortName = arg.slice(1);\n                option = this._getOptionByShortName(shortName);\n            }\n\n            if (option === null) {\n                throw new Error( util.format('Unknown command-line option \"%s\".', name) );\n            }\n\n            if (option.hasValue) {\n                value = next;\n                i++;\n\n                if (value === null || value.charAt(0) === '-') {\n                    throw new Error( util.format('The command-line option \"%s\" requires a value.', name) );\n                }\n            }\n            else {\n                value = true;\n            }\n\n            // skip ignored options now that we've consumed the option text\n            if (option.ignore) {\n                continue;\n            }\n\n            if (option.longName && shortName) {\n                name = option.longName;\n            }\n\n            if (typeof option.coercer === 'function') {\n                value = option.coercer(value);\n            }\n\n            // Allow for multiple options of the same type to be present\n            if (option.canHaveMultiple && hasOwnProp.call(result, name)) {\n                var val = result[name];\n\n                if (val instanceof Array) {\n                    val.push(value);\n                } else {\n                    result[name] = [val, value];\n                }\n            }\n            else {\n                result[name] = value;\n            }\n        }\n        else {\n            result._.push(arg);\n        }\n    }\n\n    return result;\n};\n\nmodule.exports = ArgParser;\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/util/cast.js":"'use strict';\n\n/**\n * Module to convert values between various JavaScript types.\n * @module\n * @private\n */\n\n/**\n * Check whether a string contains a boolean or numeric value, and convert the string to the\n * appropriate type if necessary.\n *\n * @private\n * @param {string} str - The string to convert.\n * @return {(string|number|boolean)} The converted value.\n */\nfunction castString(str) {\n    var number;\n    var result;\n\n    switch (str) {\n        case 'true':\n            result = true;\n            break;\n\n        case 'false':\n            result = false;\n            break;\n\n        case 'NaN':\n            result = NaN;\n            break;\n\n        case 'null':\n            result = null;\n            break;\n\n        case 'undefined':\n            result = undefined;\n            break;\n\n        default:\n            if (typeof str === 'string') {\n                if (str.indexOf('.') !== -1) {\n                    number = parseFloat(str);\n                }\n                else {\n                    number = parseInt(str, 10);\n                }\n\n                if ( String(number) === str && !isNaN(number) ) {\n                    result = number;\n                }\n                else {\n                    result = str;\n                }\n            }\n    }\n\n    return result;\n}\n\n/**\n * Check whether a string contains a boolean or numeric value, and convert the string to the\n * appropriate type if necessary.\n *\n * If an object or array is passed to this method, the object or array's values will be recursively\n * converted to the appropriate types. The original object or array is not modified.\n *\n * @private\n * @param {(string|Object|Array)} item - The item whose type will be converted.\n * @return {(string|number|boolean|Object|Array)} The converted value.\n */\nexports.cast = function cast(item) {\n    var result;\n\n    if ( Array.isArray(item) ) {\n        result = [];\n        for (var i = 0, l = item.length; i < l; i++) {\n            result[i] = cast(item[i]);\n        }\n    }\n    else if (typeof item === 'object' && item !== null) {\n        result = {};\n        Object.keys(item).forEach(function(prop) {\n            result[prop] = cast(item[prop]);\n        });\n    }\n    else if (typeof item === 'string') {\n        result = castString(item);\n    }\n    else {\n        result = item;\n    }\n\n    return result;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/config.js":"/**\n    @overview\n    @author Michael Mathews <micmath@gmail.com>\n    @license Apache License 2.0 - See file 'LICENSE.md' in this project.\n */\n\n/**\n    @module jsdoc/config\n */\n'use strict';\n\nfunction mergeRecurse(target, source) {\n    Object.keys(source).forEach(function(p) {\n        if ( source[p].constructor === Object ) {\n            if ( !target[p] ) {\n                target[p] = {};\n            }\n            mergeRecurse(target[p], source[p]);\n        }\n        else {\n            target[p] = source[p];\n        }\n    });\n\n    return target;\n}\n\n// required config values, override these defaults in your config.json if necessary\nvar defaults = {\n    tags: {\n        allowUnknownTags: true,\n        dictionaries: ['jsdoc', 'closure']\n    },\n    templates: {\n        monospaceLinks: false,\n        cleverLinks: false\n    },\n    source: {\n        includePattern: '.+\\\\.js(doc|x)?$',\n        excludePattern: ''\n    },\n    plugins: []\n};\n\n/**\n    @class\n    @classdesc Represents a JSDoc application configuration.\n    @param {string} [json] - The contents of config.json.\n */\nfunction Config(json) {\n    json = JSON.parse( (json || '{}') );\n    this._config = mergeRecurse(defaults, json);\n}\n\nmodule.exports = Config;\n\n/**\n    Get the merged configuration values.\n */\nConfig.prototype.get = function() {\n    return this._config;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/src/filter.js":"/**\n    @module jsdoc/src/filter\n\n    @author Michael Mathews <micmath@gmail.com>\n    @license Apache License 2.0 - See file 'LICENSE.md' in this project.\n */\n'use strict';\n\nvar env = require('jsdoc/env');\nvar path = require('jsdoc/path');\n\nfunction makeRegExp(config) {\n    var regExp = null;\n\n    if (config) {\n        regExp = (typeof config === 'string') ? new RegExp(config) : config;\n    }\n\n    return regExp;\n}\n\n/**\n    @constructor\n    @param {object} opts\n    @param {string[]} opts.exclude - Specific files to exclude.\n    @param {string|RegExp} opts.includePattern\n    @param {string|RegExp} opts.excludePattern\n */\nexports.Filter = function(opts) {\n    this.exclude = opts.exclude && Array.isArray(opts.exclude) ?\n        opts.exclude.map(function($) {\n            return path.resolve(env.pwd, $);\n        }) :\n        null;\n    this.includePattern = makeRegExp(opts.includePattern);\n    this.excludePattern = makeRegExp(opts.excludePattern);\n};\n\n/**\n    @param {string} filepath - The filepath to check.\n    @returns {boolean} Should the given file be included?\n */\nexports.Filter.prototype.isIncluded = function(filepath) {\n    var included = true;\n\n    filepath = path.resolve(env.pwd, filepath);\n\n    if ( this.includePattern && !this.includePattern.test(filepath) ) {\n        included = false;\n    }\n\n    if ( this.excludePattern && this.excludePattern.test(filepath) ) {\n        included = false;\n    }\n\n    if (this.exclude) {\n        this.exclude.forEach(function(exclude) {\n            if ( filepath.indexOf(exclude) === 0 ) {\n                included = false;\n            }\n        });\n    }\n\n    return included;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/readme.js":"/**\n * Make the contents of a README file available to include in the output.\n * @module jsdoc/readme\n * @author Michael Mathews <micmath@gmail.com>\n * @author Ben Blank <ben.blank@gmail.com>\n */\n'use strict';\n\nvar env = require('jsdoc/env');\nvar fs = require('jsdoc/fs');\nvar markdown = require('jsdoc/util/markdown');\n\n/**\n * @class\n * @classdesc Represents a README file.\n * @param {string} path - The filepath to the README.\n */\nfunction ReadMe(path) {\n    var content = fs.readFileSync(path, env.opts.encoding);\n    var parse = markdown.getParser();\n\n    this.html = parse(content);\n}\n\nmodule.exports = ReadMe;\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/util/markdown.js":"/**\n * Provides access to Markdown-related functions.\n * @module jsdoc/util/markdown\n * @author Michael Mathews <micmath@gmail.com>\n * @author Ben Blank <ben.blank@gmail.com>\n */\n'use strict';\n\nvar env = require('jsdoc/env');\nvar util = require('util');\n\n/**\n * Enumeration of Markdown parsers that are available.\n * @enum {String}\n */\nvar parserNames = {\n    /**\n     * The \"[markdown-js](https://github.com/evilstreak/markdown-js)\" (aka \"evilstreak\") parser.\n     *\n     * @deprecated Replaced by \"marked,\" as markdown-js does not support inline HTML.\n     */\n    evilstreak: 'marked',\n    /**\n     * The \"GitHub-flavored Markdown\" parser.\n     * @deprecated Replaced by \"marked.\"\n     */\n    gfm: 'marked',\n    /**\n     * The \"[Marked](https://github.com/chjj/marked)\" parser.\n     */\n    marked: 'marked'\n};\n\n/**\n * Escape underscores that occur within {@ ... } in order to protect them\n * from the markdown parser(s).\n * @param {String} source the source text to sanitize.\n * @returns {String} `source` where underscores within {@ ... } have been\n * protected with a preceding backslash (i.e. \\_) -- the markdown parsers\n * will strip the backslash and protect the underscore.\n */\nfunction escapeUnderscores(source) {\n    return source.replace(/\\{@[^}\\r\\n]+\\}/g, function (wholeMatch) {\n        return wholeMatch.replace(/(^|[^\\\\])_/g, '$1\\\\_');\n    });\n}\n\n/**\n * Escape HTTP/HTTPS URLs so that they are not automatically converted to HTML links.\n *\n * @param {string} source - The source text to escape.\n * @return {string} The source text with escape characters added to HTTP/HTTPS URLs.\n */\nfunction escapeUrls(source) {\n    return source.replace(/(https?)\\:\\/\\//g, '$1:\\\\/\\\\/');\n}\n\n/**\n * Unescape HTTP/HTTPS URLs after Markdown parsing is complete.\n *\n * @param {string} source - The source text to unescape.\n * @return {string} The source text with escape characters removed from HTTP/HTTPS URLs.\n */\nfunction unescapeUrls(source) {\n    return source.replace(/(https?)\\:\\\\\\/\\\\\\//g, '$1://');\n}\n\n/**\n * Escape characters in text within a code block.\n *\n * @param {string} source - The source text to escape.\n * @return {string} The escaped source text.\n */\nfunction escapeCode(source) {\n    return source.replace(/</g, '&lt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&#39;');\n}\n\n/**\n * Unencode quotes that occur within {@ ... } after the markdown parser has turned them\n * into html entities (unfortunately it isn't possible to escape them before parsing)\n *\n * @param {string} source - The source text to unencode.\n * @return {string} The source text with html entity `&quot;` converted back to standard quotes\n */\nfunction unencodeQuotes(source) {\n    return source.replace(/\\{@[^}\\r\\n]+\\}/g, function (wholeMatch) {\n        return wholeMatch.replace(/&quot;/g, '\"');\n    });\n}\n\n\n/**\n * Retrieve a function that accepts a single parameter containing Markdown source. The function uses\n * the specified parser to transform the Markdown source to HTML, then returns the HTML as a string.\n *\n * @private\n * @param {String} parserName The name of the selected parser.\n * @param {Object} [conf] Configuration for the selected parser, if any.\n * @returns {Function} A function that accepts Markdown source, feeds it to the selected parser, and\n * returns the resulting HTML.\n */\nfunction getParseFunction(parserName, conf) {\n    var logger = require('jsdoc/util/logger');\n    var marked = require('marked');\n\n    var markedRenderer;\n    var parserFunction;\n\n    conf = conf || {};\n\n    if (parserName === parserNames.marked) {\n        if (conf.hardwrap) {\n            marked.setOptions({breaks: true});\n        }\n\n        // Marked generates an \"id\" attribute for headers; this custom renderer suppresses it\n        markedRenderer = new marked.Renderer();\n\n        if (!conf.idInHeadings) {\n            markedRenderer.heading = function(text, level) {\n                return util.format('<h%s>%s</h%s>', level, text, level);\n            };\n        }\n\n        // Allow prettyprint to work on inline code samples\n        markedRenderer.code = function(code, language) {\n            var langClass = language ? ' lang-' + language : '';\n\n            return util.format( '<pre class=\"prettyprint source%s\"><code>%s</code></pre>',\n                langClass, escapeCode(code) );\n        };\n\n        parserFunction = function(source) {\n            var result;\n\n            source = escapeUnderscores(source);\n            source = escapeUrls(source);\n\n            result = marked(source, { renderer: markedRenderer })\n                .replace(/\\s+$/, '')\n                .replace(/&#39;/g, \"'\");\n\n            result = unescapeUrls(result);\n            result = unencodeQuotes(result);\n\n            return result;\n        };\n        parserFunction._parser = parserNames.marked;\n        return parserFunction;\n    }\n    else {\n        logger.error('Unrecognized Markdown parser \"%s\". Markdown support is disabled.',\n            parserName);\n        return undefined;\n    }\n}\n\n/**\n * Retrieve a Markdown parsing function based on the value of the `conf.json` file's\n * `env.conf.markdown` property. The parsing function accepts a single parameter containing Markdown\n * source. The function uses the parser specified in `conf.json` to transform the Markdown source to\n * HTML, then returns the HTML as a string.\n *\n * @returns {function} A function that accepts Markdown source, feeds it to the selected parser, and\n * returns the resulting HTML.\n */\nexports.getParser = function() {\n    var conf = env.conf.markdown;\n    if (conf && conf.parser) {\n        return getParseFunction(parserNames[conf.parser], conf);\n    }\n    else {\n        // marked is the default parser\n        return getParseFunction(parserNames.marked, conf);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/plugins/commentConvert.js":"/**\n    @overview Demonstrate how to modify the source code before the parser sees it.\n    @module plugins/commentConvert\n    @author Michael Mathews <micmath@gmail.com>\n */\n'use strict';\n\n/* eslint spaced-comment: 0 */\n\nexports.handlers = {\n    ///\n    /// Convert ///-style comments into jsdoc comments.\n    /// @param e\n    /// @param e.filename\n    /// @param e.source\n    ///\n    beforeParse: function(e) {\n        e.source = e.source.replace(/(\\n[ \\t]*\\/\\/\\/[^\\n]*)+/g, function($) {\n            var replacement = '\\n/**' + $.replace(/^[ \\t]*\\/\\/\\//mg, '').replace(/(\\n$|$)/, '*/$1');\n            return replacement;\n        });\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/plugins/commentsOnly.js":"/**\n * @overview Remove everything in a file except JSDoc-style comments. By enabling this plugin, you\n * can document source files that are not valid JavaScript (including source files for other\n * languages).\n * @module plugins/commentsOnly\n * @author Jeff Williams <jeffrey.l.williams@gmail.com>\n */\n'use strict';\n\nexports.handlers = {\n    beforeParse: function(e) {\n        // a JSDoc comment looks like: /**[one or more chars]*/\n        var comments = e.source.match(/\\/\\*\\*[\\s\\S]+?\\*\\//g);\n        if (comments) {\n            e.source = comments.join('\\n\\n');\n        } else {\n            e.source = ''; // If file has no comments, parser should still receive no code\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/plugins/escapeHtml.js":"/**\n    @overview Escape HTML tags in descriptions.\n    @module plugins/escapeHtml\n    @author Michael Mathews <micmath@gmail.com>\n */\n'use strict';\n\nexports.handlers = {\n    /**\n        Translate HTML tags in descriptions into safe entities.\n        Replaces <, & and newlines\n     */\n    newDoclet: function(e) {\n        if (e.doclet.description) {\n            e.doclet.description = e.doclet.description\n                                   .replace(/&/g, '&amp;')\n                                   .replace(/</g, '&lt;')\n                                   .replace(/\\r\\n|\\n|\\r/g, '<br>');\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/plugins/eventDumper.js":"/**\n * @overview Dump information about parser events to the console.\n * @module plugins/eventDumper\n * @author Jeff Williams <jeffrey.l.williams@gmail.com>\n */\n'use strict';\n\nvar _ = require('underscore');\nvar dump = require('jsdoc/util/dumper').dump;\nvar env = require('jsdoc/env');\nvar util = require('util');\n\nvar conf = env.conf.eventDumper || {};\n\n// Dump the included parser events (defaults to all events)\nvar events = conf.include || [\n    'parseBegin',\n    'fileBegin',\n    'beforeParse',\n    'jsdocCommentFound',\n    'symbolFound',\n    'newDoclet',\n    'fileComplete',\n    'parseComplete',\n    'processingComplete'\n];\n// Don't dump the excluded parser events\nif (conf.exclude) {\n    events = _.difference(events, conf.exclude);\n}\n\n/**\n * Replace AST node objects in events with a placeholder.\n *\n * @param {Object} o - An object whose properties may contain AST node objects.\n * @return {Object} The modified object.\n */\nfunction replaceNodeObjects(o) {\n    var doop = require('jsdoc/util/doop');\n\n    var OBJECT_PLACEHOLDER = '<Object>';\n\n    if (o.code && o.code.node) {\n        // don't break the original object!\n        o.code = doop(o.code);\n        o.code.node = OBJECT_PLACEHOLDER;\n    }\n\n    if (o.doclet && o.doclet.meta && o.doclet.meta.code && o.doclet.meta.code.node) {\n        // don't break the original object!\n        o.doclet.meta.code = doop(o.doclet.meta.code);\n        o.doclet.meta.code.node = OBJECT_PLACEHOLDER;\n    }\n\n    if (o.astnode) {\n        o.astnode = OBJECT_PLACEHOLDER;\n    }\n\n    return o;\n}\n\n/**\n * Get rid of unwanted crud in an event object.\n *\n * @param {object} e The event object.\n * @return {object} The fixed-up object.\n */\nfunction cleanse(e) {\n    var result = {};\n\n    Object.keys(e).forEach(function(prop) {\n        // by default, don't stringify properties that contain an array of functions\n        if (!conf.includeFunctions && util.isArray(e[prop]) && e[prop][0] &&\n            String(typeof e[prop][0]) === 'function') {\n            result[prop] = 'function[' + e[prop].length + ']';\n        }\n        // never include functions that belong to the object\n        else if (typeof e[prop] !== 'function') {\n            result[prop] = e[prop];\n        }\n    });\n\n    // allow users to omit node objects, which can be enormous\n    if (conf.omitNodes) {\n        result = replaceNodeObjects(result);\n    }\n\n    return result;\n}\n\nexports.handlers = {};\n\nevents.forEach(function(eventType) {\n    exports.handlers[eventType] = function(e) {\n        console.log( dump({\n            type: eventType,\n            content: cleanse(e)\n        }) );\n    };\n});\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/plugins/markdown.js":"/**\n * @overview Translate doclet descriptions from MarkDown into HTML.\n * @module plugins/markdown\n * @author Michael Mathews <micmath@gmail.com>\n * @author Ben Blank <ben.blank@gmail.com>\n */\n'use strict';\n\nvar env = require('jsdoc/env');\n\nvar config = env.conf.markdown || {};\nvar defaultTags = [\n    'author',\n    'classdesc',\n    'description',\n    'exceptions',\n    'params',\n    'properties',\n    'returns',\n    'see'\n];\nvar hasOwnProp = Object.prototype.hasOwnProperty;\nvar parse = require('jsdoc/util/markdown').getParser();\nvar tags = [];\nvar excludeTags = [];\n\nfunction shouldProcessString(tagName, text) {\n    var shouldProcess = true;\n\n    // we only want to process `@author` and `@see` tags that contain Markdown links\n    if ( (tagName === 'author' || tagName === 'see') && text.indexOf('[') === -1 ) {\n        shouldProcess = false;\n    }\n\n    return shouldProcess;\n}\n\n/**\n * Process the markdown source in a doclet. The properties that should be\n * processed are configurable, but always include \"classdesc\", \"description\",\n * \"params\", \"properties\", and \"returns\".  Handled properties can be bare\n * strings, objects, or arrays of objects.\n */\nfunction process(doclet) {\n    tags.forEach(function(tag) {\n        if ( !hasOwnProp.call(doclet, tag) ) {\n            return;\n        }\n\n        if (typeof doclet[tag] === 'string' && shouldProcessString(tag, doclet[tag]) ) {\n            doclet[tag] = parse(doclet[tag]);\n        }\n        else if ( Array.isArray(doclet[tag]) ) {\n            doclet[tag].forEach(function(value, index, original) {\n                var inner = {};\n                inner[tag] = value;\n                process(inner);\n                original[index] = inner[tag];\n            });\n        }\n        else if (doclet[tag]) {\n            process(doclet[tag]);\n        }\n    });\n}\n\n// set up the list of \"tags\" (properties) to process\nif (config.tags) {\n    tags = config.tags.slice();\n}\n// set up the list of default tags to exclude from processing\nif (config.excludeTags) {\n    excludeTags = config.excludeTags.slice();\n}\ndefaultTags.forEach(function(tag) {\n    if (excludeTags.indexOf(tag) === -1 && tags.indexOf(tag) === -1) {\n        tags.push(tag);\n    }\n});\n\nexports.handlers = {\n    /**\n     * Translate markdown syntax in a new doclet's description into HTML. Is run\n     * by JSDoc 3 whenever a \"newDoclet\" event fires.\n     */\n    newDoclet: function(e) {\n        process(e.doclet);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/plugins/overloadHelper.js":"/**\n * The Overload Helper plugin automatically adds a signature-like string to the longnames of\n * overloaded functions and methods. In JSDoc, this string is known as a _variation_. (The longnames\n * of overloaded constructor functions are _not_ updated, so that JSDoc can identify the class'\n * members correctly.)\n *\n * Using this plugin allows you to link to overloaded functions without manually adding `@variation`\n * tags to your documentation.\n *\n * For example, suppose your code includes a function named `foo` that you can call in the\n * following ways:\n *\n * + `foo()`\n * + `foo(bar)`\n * + `foo(bar, baz)` (where `baz` is repeatable)\n *\n * This plugin assigns the following variations and longnames to each version of `foo`:\n *\n * + `foo()` gets the variation `()` and the longname `foo()`.\n * + `foo(bar)` gets the variation `(bar)` and the longname `foo(bar)`.\n * + `foo(bar, baz)` (where `baz` is repeatable) gets the variation `(bar, ...baz)` and the longname\n * `foo(bar, ...baz)`.\n *\n * You can then link to these functions with `{@link foo()}`, `{@link foo(bar)}`, and\n * `{@link foo(bar, ...baz)`. Note that the variation is based on the names of the function\n * parameters, _not_ their types.\n *\n * If you prefer to manually assign variations to certain functions, you can still do so with the\n * `@variation` tag. This plugin will not change these variations or add more variations for that\n * function, as long as the variations you've defined result in unique longnames.\n *\n * If an overloaded function includes multiple signatures with the same parameter names, the plugin\n * will assign numeric variations instead, starting at `(1)` and counting upwards.\n *\n * @module plugins/overloadHelper\n * @author Jeff Williams <jeffrey.l.williams@gmail.com>\n * @license Apache License 2.0\n */\n'use strict';\n\n// lookup table of function doclets by longname\nvar functionDoclets;\n\nfunction hasUniqueValues(obj) {\n    var isUnique = true;\n    var seen = [];\n    Object.keys(obj).forEach(function(key) {\n        if (seen.indexOf(obj[key]) !== -1) {\n            isUnique = false;\n        }\n\n        seen.push(obj[key]);\n    });\n\n    return isUnique;\n}\n\nfunction getParamNames(params) {\n    var names = [];\n\n    params.forEach(function(param) {\n        var name = param.name || '';\n        if (param.variable) {\n            name = '...' + name;\n        }\n        if (name !== '') {\n            names.push(name);\n        }\n    });\n\n    return names.length ? names.join(', ') : '';\n}\n\nfunction getParamVariation(doclet) {\n    return getParamNames(doclet.params || []);\n}\n\nfunction getUniqueVariations(doclets) {\n    var counter = 0;\n    var variations = {};\n    var docletKeys = Object.keys(doclets);\n\n    function getUniqueNumbers() {\n        var format = require('util').format;\n\n        docletKeys.forEach(function(doclet) {\n            var newLongname;\n\n            while (true) {\n                counter++;\n                variations[doclet] = String(counter);\n\n                // is this longname + variation unique?\n                newLongname = format('%s(%s)', doclets[doclet].longname, variations[doclet]);\n                if ( !functionDoclets[newLongname] ) {\n                    break;\n                }\n            }\n        });\n    }\n\n    function getUniqueNames() {\n        // start by trying to preserve existing variations\n        docletKeys.forEach(function(doclet) {\n            variations[doclet] = doclets[doclet].variation || getParamVariation(doclets[doclet]);\n        });\n\n        // if they're identical, try again, without preserving existing variations\n        if ( !hasUniqueValues(variations) ) {\n            docletKeys.forEach(function(doclet) {\n                variations[doclet] = getParamVariation(doclets[doclet]);\n            });\n\n            // if they're STILL identical, switch to numeric variations\n            if ( !hasUniqueValues(variations) ) {\n                getUniqueNumbers();\n            }\n        }\n    }\n\n    // are we already using numeric variations? if so, keep doing that\n    if (functionDoclets[doclets.newDoclet.longname + '(1)']) {\n        getUniqueNumbers();\n    }\n    else {\n        getUniqueNames();\n    }\n\n    return variations;\n}\n\nfunction ensureUniqueLongname(newDoclet) {\n    var doclets = {\n        oldDoclet: functionDoclets[newDoclet.longname],\n        newDoclet: newDoclet\n    };\n    var docletKeys = Object.keys(doclets);\n    var oldDocletLongname;\n    var variations = {};\n\n    if (doclets.oldDoclet) {\n        oldDocletLongname = doclets.oldDoclet.longname;\n        // if the shared longname has a variation, like MyClass#myLongname(variation),\n        // remove the variation\n        if (doclets.oldDoclet.variation || doclets.oldDoclet.variation === '') {\n            docletKeys.forEach(function(doclet) {\n                doclets[doclet].longname = doclets[doclet].longname.replace(/\\([\\s\\S]*\\)$/, '');\n                doclets[doclet].variation = null;\n            });\n        }\n\n        variations = getUniqueVariations(doclets);\n\n        // update the longnames/variations\n        docletKeys.forEach(function(doclet) {\n            doclets[doclet].longname += '(' + variations[doclet] + ')';\n            doclets[doclet].variation = variations[doclet];\n        });\n\n        // update the old doclet in the lookup table\n        functionDoclets[oldDocletLongname] = null;\n        functionDoclets[doclets.oldDoclet.longname] = doclets.oldDoclet;\n    }\n\n    // always store the new doclet in the lookup table\n    functionDoclets[doclets.newDoclet.longname] = doclets.newDoclet;\n\n    return doclets.newDoclet;\n}\n\nexports.handlers = {\n    parseBegin: function() {\n        functionDoclets = {};\n    },\n\n    newDoclet: function(e) {\n        if (e.doclet.kind === 'function') {\n            e.doclet = ensureUniqueLongname(e.doclet);\n        }\n    },\n\n    parseComplete: function() {\n        functionDoclets = null;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/plugins/partial.js":"/**\n    @overview Adds support for reusable partial jsdoc files.\n    @module plugins/partial\n    @author Ludo Antonov <ludo@hulu.com>\n */\n'use strict';\n\nvar env = require('jsdoc/env');\nvar fs = require('jsdoc/fs');\nvar path = require('path');\n\nexports.handlers = {\n    /**\n     * Include a partial jsdoc\n     *\n     * @param e\n     * @param e.filename\n     * @param e.source\n     * @example\n     *     @partial \"partial_doc.jsdoc\"\n     */\n    beforeParse: function(e) {\n        e.source = e.source.replace(/(@partial \\\".*\\\")+/g, function($) {\n            var pathArg = $.match(/\\\".*\\\"/)[0].replace(/\"/g, '');\n            var fullPath = path.join(e.filename, '..', pathArg);\n\n            var partialData = fs.readFileSync(fullPath, env.opts.encoding);\n\n            return partialData;\n        });\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/plugins/railsTemplate.js":"/**\n    @overview Strips the rails template tags from a js.erb file\n    @module plugins/railsTemplate\n    @author Jannon Frank <jannon@jannon.net>\n */\n'use strict';\n\nexports.handlers = {\n    /**\n     * Remove rails tags from the source input (e.g. <% foo bar %>)\n     * @param e\n     * @param e.filename\n     * @param e.source\n     */\n    beforeParse: function(e) {\n        if (e.filename.match(/\\.erb$/)) {\n            e.source = e.source.replace(/<%.*%>/g, '');\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/plugins/shout.js":"/**\n    @overview This is just an example.\n    @module plugins/shout\n    @author Michael Mathews <micmath@gmail.com>\n */\n'use strict';\n\nexports.handlers = {\n    /**\n        Make your descriptions more shoutier.\n     */\n    newDoclet: function(e) {\n        if (typeof e.doclet.description === 'string') {\n            e.doclet.description = e.doclet.description.toUpperCase();\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/plugins/sourcetag.js":"/**\n    @module plugins/sourcetag\n    @author Michael Mathews <micmath@gmail.com>\n */\n'use strict';\n\nvar logger = require('jsdoc/util/logger');\n\nexports.handlers = {\n    /**\n        Support @source tag. Expected value like:\n            { \"filename\": \"myfile.js\", \"lineno\": 123 }\n        Modifies the corresponding meta values on the given doclet.\n\n        WARNING: If you are using a JSDoc template that generates pretty-printed source files,\n        such as JSDoc's default template, this plugin can cause JSDoc to crash. To fix this issue,\n        update your template settings to disable pretty-printed source files.\n\n        @source { \"filename\": \"sourcetag.js\", \"lineno\": 13 }\n     */\n    newDoclet: function(e) {\n        var tags = e.doclet.tags,\n            tag,\n            value;\n\n        // any user-defined tags in this doclet?\n        if (typeof tags !== 'undefined') {\n            // only interested in the @source tags\n            tags = tags.filter(function($) {\n                return $.title === 'source';\n            });\n\n            if (tags.length) {\n                // take the first one\n                tag = tags[0];\n\n                try {\n                    value = JSON.parse(tag.value);\n                }\n                catch (ex) {\n                    logger.error('@source tag expects a valid JSON value, like { \"filename\": \"myfile.js\", \"lineno\": 123 }.');\n                    return;\n                }\n\n                e.doclet.meta = e.doclet.meta || {};\n                e.doclet.meta.filename = value.filename || '';\n                e.doclet.meta.lineno = value.lineno || '';\n            }\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/plugins/summarize.js":"/**\n * @overview This plugin creates a summary tag, if missing, from the first sentence in the\n * description.\n * @module plugins/summarize\n * @author Mads Bondo Dydensborg <mbd@dbc.dk>\n */\n'use strict';\n\nexports.handlers = {\n    /**\n     * Autogenerate summaries, if missing, from the description, if present.\n     */\n    newDoclet: function(e) {\n        var endTag;\n        var tags;\n        var stack;\n\n        // If the summary is missing, grab the first sentence from the description\n        // and use that.\n        if (e.doclet && !e.doclet.summary && e.doclet.description) {\n            // The summary may end with `.$`, `. `, or `.<` (a period followed by an HTML tag).\n            e.doclet.summary = e.doclet.description.split(/\\.$|\\.\\s|\\.</)[0];\n            // Append `.` as it was removed in both cases, or is possibly missing.\n            e.doclet.summary += '.';\n\n            // This is an excerpt of something that is possibly HTML.\n            // Balance it using a stack. Assume it was initially balanced.\n            tags = e.doclet.summary.match(/<[^>]+>/g) || [];\n            stack = [];\n\n            tags.forEach(function(tag) {\n                var idx = tag.indexOf('/');\n\n                if (idx === -1) {\n                    // start tag -- push onto the stack\n                    stack.push(tag);\n                } else if (idx === 1) {\n                    // end tag -- pop off of the stack\n                    stack.pop();\n                }\n\n                // otherwise, it's a self-closing tag; don't modify the stack\n            });\n\n            // stack should now contain only the start tags that lack end tags,\n            // with the most deeply nested start tag at the top\n            while (stack.length > 0) {\n                // pop the unmatched tag off the stack\n                endTag = stack.pop();\n                // get just the tag name\n                endTag = endTag.substring(1, endTag.search(/[ >]/));\n                // append the end tag\n                e.doclet.summary += '</' + endTag + '>';\n            }\n\n            // and, finally, if the summary starts and ends with a <p> tag, remove it; let the\n            // template decide whether to wrap the summary in a <p> tag\n            e.doclet.summary = e.doclet.summary.replace(/^<p>(.*)<\\/p>$/i, '$1');\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/plugins/underscore.js":"'use strict';\n\n/**\n * Removes all symbols that begin with an underscore from the doc output. If\n * you're using underscores to denote private variables in modules, this\n * automatically hides them.\n *\n * @module plugins/underscore\n * @author Daniel Ellis <coug36@gmail.com>\n */\n\nexports.handlers = {\n    newDoclet: function(e) {\n        var doclet = e.doclet;\n\n        // Ignore comment blocks for all symbols that begin with underscore\n        if (doclet.name.charAt(0) === '_' || doclet.name.substr(0, 6) === 'this._') {\n            doclet.access = 'private';\n        }\n    }\n};\n"}