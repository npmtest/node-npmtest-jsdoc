{"/home/travis/build/npmtest/node-npmtest-jsdoc/test.js":"/* istanbul instrument in package npmtest_jsdoc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jsdoc/lib.npmtest_jsdoc.js":"/* istanbul instrument in package npmtest_jsdoc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_jsdoc = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_jsdoc = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-jsdoc/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-jsdoc && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_jsdoc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_jsdoc\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_jsdoc.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_jsdoc.rollup.js'] =\n            local.assetsDict['/assets.npmtest_jsdoc.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_jsdoc.__dirname + '/lib.npmtest_jsdoc.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/jsdoc.js":"#!/usr/bin/env node\n/* global arguments, require: true */\n/* eslint strict: [2, \"function\"] */\n/**\n * @project jsdoc\n * @author Michael Mathews <micmath@gmail.com>\n * @license See LICENSE.md file included in this distribution.\n */\n\n// initialize the environment for the current JavaScript VM\n(function(args) {\n    'use strict';\n\n    var path;\n\n    if (args[0] && typeof args[0] === 'object') {\n        // we should be on Node.js\n        args = [__dirname, process.cwd()];\n        path = require('path');\n\n        // Create a custom require method that adds `lib/jsdoc` and `node_modules` to the module\n        // lookup path. This makes it possible to `require('jsdoc/foo')` from external templates and\n        // plugins, and within JSDoc itself. It also allows external templates and plugins to\n        // require JSDoc's module dependencies without installing them locally.\n        require = require('requizzle')({\n            requirePaths: {\n                before: [path.join(__dirname, 'lib')],\n                after: [path.join(__dirname, 'node_modules')]\n            },\n            infect: true\n        });\n    }\n\n    require('./lib/jsdoc/util/runtime').initialize(args);\n})( Array.prototype.slice.call(arguments, 0) );\n\n/**\n * Data about the environment in which JSDoc is running, including the configuration settings that\n * were used to run JSDoc.\n *\n * @deprecated As of JSDoc 3.4.0. Use `require('jsdoc/env')` to access the `env` object. The global\n * `env` object will be removed in a future release.\n * @namespace\n * @name env\n */\nglobal.env = (function() {\n    'use strict';\n    return require('./lib/jsdoc/env');\n})();\n\n/**\n * Data that must be shared across the entire application.\n *\n * @deprecated As of JSDoc 3.4.0. Avoid using the `app` object. The global `app` object and the\n * `jsdoc/app` module will be removed in a future release.\n * @namespace\n * @name app\n */\nglobal.app = (function() {\n    'use strict';\n    return require('./lib/jsdoc/app');\n})();\n\n(function() {\n    'use strict';\n\n    var env = global.env;\n    var logger = require('./lib/jsdoc/util/logger');\n    var runtime = require('./lib/jsdoc/util/runtime');\n    var cli = require('./cli');\n\n    function cb(errorCode) {\n        cli.logFinish();\n        cli.exit(errorCode || 0);\n    }\n\n    cli.setVersionInfo()\n        .loadConfig();\n\n    if (!env.opts.test) {\n        cli.configureLogger();\n    }\n\n    cli.logStart();\n\n    if (env.opts.debug) {\n        /**\n         * Recursively print an object's properties to stdout. This method is safe to use with\n         * objects that contain circular references.\n         *\n         * This method is available only when JSDoc is run with the `--debug` option.\n         *\n         * @global\n         * @name dump\n         * @private\n         * @param {...*} obj - Object(s) to print to stdout.\n         */\n        global.dump = function() {\n            console.log(require('./lib/jsdoc/util/dumper').dump(arguments));\n        };\n    }\n\n    cli.runCommand(cb);\n})();\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/util/runtime.js":"/* global java */\n/**\n * Helper functions to enable JSDoc to run on multiple JavaScript runtimes.\n *\n * @module jsdoc/util/runtime\n * @private\n */\n'use strict';\n\nvar env = require('jsdoc/env');\nvar os = require('os');\n\n// This string represents a directory name; do not modify it!\n/** @private */\nvar NODE = exports.NODE = 'node';\n\n/**\n * The JavaScript runtime that is executing JSDoc:\n *\n * + `module:jsdoc/util/runtime~NODE`: Node.js.\n *\n * @private\n */\nvar runtime = (function() {\n    if (require && require.main && module) {\n        return NODE;\n    } else {\n        // unknown runtime\n        throw new Error('Unable to identify the current JavaScript runtime.');\n    }\n})();\n\n/**\n * Check whether Node.js is running JSDoc.\n * @return {boolean} Set to `true` if the current runtime is Node.js.\n */\nexports.isNode = function() {\n    return runtime === NODE;\n};\n\nfunction initializeNode(args) {\n    var fs = require('fs');\n    var path = require('path');\n\n    var jsdocPath = args[0];\n    var pwd = args[1];\n\n    // resolve the path if it's a symlink\n    if ( fs.statSync(jsdocPath).isSymbolicLink() ) {\n        jsdocPath = path.resolve( path.dirname(jsdocPath), fs.readlinkSync(jsdocPath) );\n    }\n\n    env.dirname = jsdocPath;\n    env.pwd = pwd;\n    env.args = process.argv.slice(2);\n}\n\nexports.initialize = function(args) {\n    switch (runtime) {\n        case NODE:\n            initializeNode(args);\n            break;\n        default:\n            throw new Error('Cannot initialize the unknown JavaScript runtime \"' + runtime + '\"!');\n    }\n};\n\n/**\n * Retrieve the identifier for the current JavaScript runtime.\n *\n * @private\n * @return {string} The runtime identifier.\n */\nexports.getRuntime = function() {\n    return runtime;\n};\n\n/**\n * Get the require path for the runtime-specific implementation of a module.\n *\n * @param {string} partialPath - The partial path to the module. Use the same format as when calling\n * `require()`.\n * @return {object} The require path for the runtime-specific implementation of the module.\n */\nexports.getModulePath = function(partialPath) {\n    var path = require('path');\n\n    return path.join(env.dirname, runtime, partialPath);\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/env.js":"'use strict';\n\n/**\n * Data about the environment in which JSDoc is running, including the configuration settings that\n * were used to run JSDoc.\n *\n * @module jsdoc/env\n */\nmodule.exports = {\n    /**\n     * The times at which JSDoc started and finished.\n     *\n     * @type {Object}\n     * @property {Date} start - The time at which JSDoc started running.\n     * @property {Date} finish - The time at which JSDoc finished running.\n     */\n    run: {\n        start: new Date(),\n        finish: null\n    },\n\n    /**\n     * The command-line arguments passed to JSDoc.\n     *\n     * @type {Array<*>}\n     */\n    args: [],\n\n    /**\n     * The data parsed from JSDoc's configuration file.\n     *\n     * @type Object<string, *>\n     */\n    conf: {},\n\n    /**\n     * The absolute path to the base directory in which JSDoc is located. Set at startup.\n     *\n     * @private\n     * @type {string}\n     */\n    dirname: null,\n\n    /**\n     * The user's working directory at the time when JSDoc started running.\n     *\n     * @private\n     * @type {string}\n     */\n    pwd: null,\n\n    /**\n     * The command-line arguments, parsed into a key/value hash.\n     *\n     * @type {Object}\n     * @example if (global.env.opts.help) { console.log('Helpful message.'); }\n    */\n    opts: {},\n\n    /**\n     * The source files that JSDoc will parse.\n     *\n     * @type {Array<string>}\n     * @memberof env\n     */\n    sourceFiles: [],\n\n    /**\n     * The JSDoc version number and revision date.\n     *\n     * @type {Object<string, string>}\n     * @property {string} number - The JSDoc version number.\n     * @property {string} revision - The JSDoc revision number, expressed as a UTC date string.\n     */\n    version: {\n        number: null,\n        revision: null\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/app.js":"'use strict';\n\n/**\n * Objects that are shared across the entire application.\n *\n * @deprecated As of JSDoc 3.4.0. Do not use this module. It will be removed in a future release.\n * @module jsdoc/app\n */\nmodule.exports = {\n    /**\n     * Namespace for shared objects.\n     *\n     * @namespace\n     * @type {Object}\n     */\n    jsdoc: {\n        name: require('jsdoc/name'),\n        parser: null,\n        scanner: new (require('jsdoc/src/scanner').Scanner)()\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/name.js":"/**\n    A collection of functions relating to JSDoc symbol name manipulation.\n    @module jsdoc/name\n    @author Michael Mathews <micmath@gmail.com>\n    @license Apache License 2.0 - See file 'LICENSE.md' in this project.\n */\n'use strict';\n\nvar _ = require('underscore');\nvar escape = require('escape-string-regexp');\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\n/**\n * Longnames that have a special meaning in JSDoc.\n *\n * @enum {string}\n * @static\n * @memberof module:jsdoc/name\n */\nvar LONGNAMES = exports.LONGNAMES = {\n    /** Longname used for doclets that do not have a longname, such as anonymous functions. */\n    ANONYMOUS: '<anonymous>',\n    /** Longname that represents global scope. */\n    GLOBAL: '<global>'\n};\n\n// Module namespace prefix.\nvar MODULE_NAMESPACE = 'module:';\n\n/**\n * Names and punctuation marks that identify doclet scopes.\n *\n * @enum {string}\n * @static\n * @memberof module:jsdoc/name\n */\nvar SCOPE = exports.SCOPE = {\n    NAMES: {\n        GLOBAL: 'global',\n        INNER: 'inner',\n        INSTANCE: 'instance',\n        STATIC: 'static'\n    },\n    PUNC: {\n        INNER: '~',\n        INSTANCE: '#',\n        STATIC: '.'\n    }\n};\n\n// For backwards compatibility, this enum must use lower-case keys\nvar scopeToPunc = exports.scopeToPunc = {\n    'inner': SCOPE.PUNC.INNER,\n    'instance': SCOPE.PUNC.INSTANCE,\n    'static': SCOPE.PUNC.STATIC\n};\nvar puncToScope = exports.puncToScope = _.invert(scopeToPunc);\n\nvar DEFAULT_SCOPE = SCOPE.NAMES.STATIC;\nvar SCOPE_PUNC = _.values(SCOPE.PUNC);\nvar SCOPE_PUNC_STRING = '[' + SCOPE_PUNC.join() + ']';\nvar REGEXP_LEADING_SCOPE = new RegExp('^(' + SCOPE_PUNC_STRING + ')');\nvar REGEXP_TRAILING_SCOPE = new RegExp('(' + SCOPE_PUNC_STRING + ')$');\n\nvar DESCRIPTION = '(?:(?:[ \\\\t]*\\\\-\\\\s*|\\\\s+)(\\\\S[\\\\s\\\\S]*))?$';\nvar REGEXP_DESCRIPTION = new RegExp(DESCRIPTION);\nvar REGEXP_NAME_DESCRIPTION = new RegExp('^(\\\\[[^\\\\]]+\\\\]|\\\\S+)' + DESCRIPTION);\n\nfunction nameIsLongname(name, memberof) {\n    var regexp = new RegExp('^' + escape(memberof) + SCOPE_PUNC_STRING);\n\n    return regexp.test(name);\n}\n\nfunction prototypeToPunc(name) {\n    // don't mangle symbols named \"prototype\"\n    if (name === 'prototype') {\n        return name;\n    }\n\n    return name.replace(/(?:^|\\.)prototype\\.?/g, SCOPE.PUNC.INSTANCE);\n}\n\n// TODO: deprecate exports.resolve in favor of a better name\n/**\n    Resolves the longname, memberof, variation and name values of the given doclet.\n    @param {module:jsdoc/doclet.Doclet} doclet\n */\nexports.resolve = function(doclet) {\n    var about = {};\n    var memberof = doclet.memberof || '';\n    var metaName;\n    var name = doclet.name ? String(doclet.name) : '';\n    var parentDoc;\n    var puncAndName;\n    var puncAndNameIndex;\n\n    // change MyClass.prototype.instanceMethod to MyClass#instanceMethod\n    // (but not in function params, which lack doclet.kind)\n    // TODO: check for specific doclet.kind values (probably function, class, and module)\n    if (name && doclet.kind) {\n        name = prototypeToPunc(name);\n    }\n    doclet.name = name;\n\n    // member of a var in an outer scope?\n    if (name && !memberof && doclet.meta.code && doclet.meta.code.funcscope) {\n        name = doclet.longname = doclet.meta.code.funcscope + SCOPE.PUNC.INNER + name;\n    }\n\n    if (memberof || doclet.forceMemberof) { // @memberof tag given\n        memberof = prototypeToPunc(memberof);\n\n        // the name is a complete longname, like @name foo.bar, @memberof foo\n        if (name && nameIsLongname(name, memberof) && name !== memberof) {\n            about = exports.shorten(name, (doclet.forceMemberof ? memberof : undefined));\n        }\n        // the name and memberof are identical and refer to a module,\n        // like @name module:foo, @memberof module:foo (probably a member like 'var exports')\n        else if (name && name === memberof && name.indexOf(MODULE_NAMESPACE) === 0) {\n            about = exports.shorten(name, (doclet.forceMemberof ? memberof : undefined));\n        }\n        // the name and memberof are identical, like @name foo, @memberof foo\n        else if (name && name === memberof) {\n            doclet.scope = doclet.scope || DEFAULT_SCOPE;\n            name = memberof + scopeToPunc[doclet.scope] + name;\n            about = exports.shorten(name, (doclet.forceMemberof ? memberof : undefined));\n        }\n        // like @memberof foo# or @memberof foo~\n        else if (name && REGEXP_TRAILING_SCOPE.test(memberof) ) {\n            about = exports.shorten(memberof + name, (doclet.forceMemberof ? memberof : undefined));\n        }\n        else if (name && doclet.scope) {\n            about = exports.shorten(memberof + (scopeToPunc[doclet.scope] || '') + name,\n                (doclet.forceMemberof ? memberof : undefined));\n        }\n    }\n    else { // no @memberof\n        about = exports.shorten(name);\n    }\n\n    if (about.name) {\n        doclet.name = about.name;\n    }\n\n    if (about.memberof) {\n        doclet.setMemberof(about.memberof);\n    }\n\n    if (about.longname && (!doclet.longname || doclet.longname === doclet.name)) {\n        doclet.setLongname(about.longname);\n    }\n\n    if (doclet.scope === SCOPE.NAMES.GLOBAL) { // via @global tag?\n        doclet.setLongname(doclet.name);\n        delete doclet.memberof;\n    }\n    else if (about.scope) {\n        if (about.memberof === LONGNAMES.GLOBAL) { // via @memberof <global> ?\n            doclet.scope = SCOPE.NAMES.GLOBAL;\n        }\n        else {\n            doclet.scope = puncToScope[about.scope];\n        }\n    }\n    else if (doclet.name && doclet.memberof && !doclet.longname) {\n        if ( REGEXP_LEADING_SCOPE.test(doclet.name) ) {\n            doclet.scope = puncToScope[RegExp.$1];\n            doclet.name = doclet.name.substr(1);\n        }\n        else if (doclet.meta.code && doclet.meta.code.name) {\n            // HACK: Handle cases where an ES 2015 class is a static memberof something else, and\n            // the class has instance members. In these cases, we have to detect the instance\n            // members' scope by looking at the meta info. There's almost certainly a better way to\n            // do this...\n            metaName = String(doclet.meta.code.name);\n            puncAndName = SCOPE.PUNC.INSTANCE + doclet.name;\n            puncAndNameIndex = metaName.indexOf(puncAndName);\n            if ( puncAndNameIndex !== -1 &&\n                (puncAndNameIndex === metaName.length - puncAndName.length) ) {\n                doclet.scope = SCOPE.NAMES.INSTANCE;\n            }\n        }\n\n        doclet.scope = doclet.scope || DEFAULT_SCOPE;\n        doclet.setLongname(doclet.memberof + scopeToPunc[doclet.scope] + doclet.name);\n    }\n\n    if (about.variation) {\n        doclet.variation = about.variation;\n    }\n\n    // if we never found a longname, just use an empty string\n    if (!doclet.longname) {\n        doclet.longname = '';\n    }\n};\n\n/**\n    @method module:jsdoc/name.applyNamespace\n    @param {string} longname The full longname of the symbol.\n    @param {string} ns The namespace to be applied.\n    @returns {string} The longname with the namespace applied.\n */\nexports.applyNamespace = function(longname, ns) {\n    var nameParts = exports.shorten(longname);\n    var name = nameParts.name;\n\n    longname = nameParts.longname;\n\n    if ( !/^[a-zA-Z]+?:.+$/i.test(name) ) {\n        longname = longname.replace( new RegExp(escape(name) + '$'), ns + ':' + name );\n    }\n\n    return longname;\n};\n\n// TODO: docs\nexports.stripNamespace = function(longname) {\n    return longname.replace(/^[a-zA-Z]+:/, '');\n};\n\n/**\n * Check whether a parent longname is an ancestor of a child longname.\n *\n * @param {string} parent - The parent longname.\n * @param {string} child - The child longname.\n * @return {boolean} `true` if the parent is an ancestor of the child; otherwise, `false`.\n */\nexports.hasAncestor = function(parent, child) {\n    var hasAncestor = false;\n    var memberof = child;\n\n    if (!parent || !child) {\n        return hasAncestor;\n    }\n\n    // fast path for obvious non-ancestors\n    if (child.indexOf(parent) !== 0) {\n        return hasAncestor;\n    }\n\n    do {\n        memberof = exports.shorten(memberof).memberof;\n\n        if (memberof === parent) {\n            hasAncestor = true;\n        }\n    } while (!hasAncestor && memberof);\n\n    return hasAncestor;\n};\n\n// TODO: docs\nfunction atomize(longname, sliceChars, forcedMemberof) {\n    var i;\n    var memberof = '';\n    var name = '';\n    var parts;\n    var partsRegExp;\n    var scopePunc = '';\n    var token;\n    var tokens = [];\n    var variation;\n\n    // quoted strings in a longname are atomic, so we convert them to tokens:\n    // foo[\"bar\"] => foo.@{1}@\n    // Foo.prototype[\"bar\"] => Foo#@{1}\n    longname = longname.replace(/(prototype|#)?(\\[?[\"'].+?[\"']\\]?)/g, function($, p1, p2) {\n        var punc = '';\n\n        // is there a leading bracket?\n        if ( /^\\[/.test(p2) ) {\n            // is it a static or instance member?\n            punc = p1 ? SCOPE.PUNC.INSTANCE : SCOPE.PUNC.STATIC;\n            p2 = p2.replace(/^\\[/g, '')\n                .replace(/\\]$/g, '');\n        }\n\n        token = '@{' + tokens.length + '}@';\n        tokens.push(p2);\n\n        return punc + token;\n    });\n\n    longname = prototypeToPunc(longname);\n\n    if (typeof forcedMemberof !== 'undefined') {\n        partsRegExp = new RegExp('^(.*?)([' + sliceChars.join() + ']?)$');\n        name = longname.substr(forcedMemberof.length);\n        parts = forcedMemberof.match(partsRegExp);\n\n        if (parts[1]) {\n            memberof = parts[1] || forcedMemberof;\n        }\n        if (parts[2]) {\n            scopePunc = parts[2];\n        }\n    }\n    else if (longname) {\n        parts = (longname.match(new RegExp('^(:?(.+)([' + sliceChars.join() + ']))?(.+?)$')) || [])\n            .reverse();\n        name = parts[0] || '';\n        scopePunc = parts[1] || '';\n        memberof = parts[2] || '';\n    }\n\n    // like /** @name foo.bar(2) */\n    if ( /(.+)\\(([^)]+)\\)$/.test(name) ) {\n        name = RegExp.$1;\n        variation = RegExp.$2;\n    }\n\n    // restore quoted strings\n    i = tokens.length;\n    while (i--) {\n        longname = longname.replace('@{' + i + '}@', tokens[i]);\n        memberof = memberof.replace('@{' + i + '}@', tokens[i]);\n        scopePunc = scopePunc.replace('@{' + i + '}@', tokens[i]);\n        name = name.replace('@{' + i + '}@', tokens[i]);\n    }\n\n    return {\n        longname: longname,\n        memberof: memberof,\n        scope: scopePunc,\n        name: name,\n        variation: variation\n    };\n}\n\n// TODO: deprecate exports.shorten in favor of a better name\n/**\n    Given a longname like \"a.b#c(2)\", slice it up into an object\n    containing the memberof, the scope, the name, and variation.\n    @param {string} longname\n    @param {string} forcedMemberof\n    @returns {object} Representing the properties of the given name.\n */\nexports.shorten = function(longname, forcedMemberof) {\n    return atomize(longname, SCOPE_PUNC, forcedMemberof);\n};\n\n// TODO: docs\nexports.combine = function(parts) {\n    return [\n        (parts.memberof || ''),\n        (parts.scope || ''),\n        (parts.name || ''),\n        (parts.variation || '')\n    ].join('');\n};\n\n// TODO: docs\nexports.stripVariation = function(name) {\n    var parts = exports.shorten(name);\n\n    parts.variation = '';\n\n    return exports.combine(parts);\n};\n\nfunction splitLongname(longname, options) {\n    var chunks = [];\n    var currentNameInfo;\n    var nameInfo = {};\n    var previousName = longname;\n    var splitters = SCOPE_PUNC.concat('/');\n\n    options = _.defaults(options || {}, {\n        includeVariation: true\n    });\n\n    do {\n        if (!options.includeVariation) {\n            previousName = exports.stripVariation(previousName);\n        }\n        currentNameInfo = nameInfo[previousName] = atomize(previousName, splitters);\n        previousName = currentNameInfo.memberof;\n        chunks.push(currentNameInfo.scope + currentNameInfo.name);\n    } while (previousName);\n\n    return {\n        chunks: chunks.reverse(),\n        nameInfo: nameInfo\n    };\n}\n\n// TODO: docs\nexports.longnamesToTree = function longnamesToTree(longnames, doclets) {\n    var splitOptions = { includeVariation: false };\n    var tree = {};\n\n    longnames.forEach(function(longname) {\n        var currentLongname = '';\n        var currentParent = tree;\n        var nameInfo;\n        var processed;\n\n        // don't try to add empty longnames to the tree\n        if (!longname) {\n            return;\n        }\n\n        processed = splitLongname(longname, splitOptions);\n        nameInfo = processed.nameInfo;\n\n        processed.chunks.forEach(function(chunk) {\n            currentLongname += chunk;\n\n            if (currentParent !== tree) {\n                currentParent.children = currentParent.children || {};\n                currentParent = currentParent.children;\n            }\n\n            if (!hasOwnProp.call(currentParent, chunk)) {\n                currentParent[chunk] = nameInfo[currentLongname];\n            }\n\n            if (currentParent[chunk]) {\n                currentParent[chunk].doclet = doclets ? doclets[currentLongname] : null;\n                currentParent = currentParent[chunk];\n            }\n        });\n    });\n\n    return tree;\n};\n\n/**\n    Split a string that starts with a name and ends with a description into its parts.\n    Allows the defaultvalue (if present) to contain brackets. If the name is found to have\n    mismatched brackets, null is returned.\n    @param {string} nameDesc\n    @returns {object} Hash with \"name\" and \"description\" properties.\n */\nfunction splitNameMatchingBrackets(nameDesc) {\n    var buffer = [];\n    var c;\n    var stack = 0;\n    var stringEnd = null;\n\n    for (var i = 0; i < nameDesc.length; ++i) {\n        c = nameDesc[i];\n        buffer.push(c);\n\n        if (stringEnd) {\n            if (c === '\\\\' && i + 1 < nameDesc.length) {\n                buffer.push(nameDesc[++i]);\n            } else if (c === stringEnd) {\n                stringEnd = null;\n            }\n        } else if (c === '\"' || c === \"'\") {\n            stringEnd = c;\n        } else if (c === '[') {\n            ++stack;\n        } else if (c === ']') {\n            if (--stack === 0) {\n                break;\n            }\n        }\n    }\n\n    if (stack || stringEnd) {\n        return null;\n    }\n\n    nameDesc.substr(i).match(REGEXP_DESCRIPTION);\n    return {\n        name: buffer.join(''),\n        description: RegExp.$1\n    };\n}\n\n\n// TODO: deprecate exports.splitName in favor of a better name\n/**\n    Split a string that starts with a name and ends with a description into its parts.\n    @param {string} nameDesc\n    @returns {object} Hash with \"name\" and \"description\" properties.\n */\nexports.splitName = function(nameDesc) {\n    // like: name, [name], name text, [name] text, name - text, or [name] - text\n    // the hyphen must be on the same line as the name; this prevents us from treating a Markdown\n    // dash as a separator\n\n    // optional values get special treatment\n    var result = null;\n    if (nameDesc[0] === '[') {\n        result = splitNameMatchingBrackets(nameDesc);\n        if (result !== null) {\n            return result;\n        }\n    }\n\n    nameDesc.match(REGEXP_NAME_DESCRIPTION);\n    return {\n        name: RegExp.$1,\n        description: RegExp.$2\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/src/scanner.js":"/**\n    @module jsdoc/src/scanner\n    @requires module:fs\n\n    @author Michael Mathews <micmath@gmail.com>\n    @license Apache License 2.0 - See file 'LICENSE.md' in this project.\n */\n'use strict';\n\nvar env = require('jsdoc/env');\nvar fs = require('jsdoc/fs');\nvar logger = require('jsdoc/util/logger');\nvar path = require('jsdoc/path');\n\n/**\n    @constructor\n    @mixes module:events\n */\nexports.Scanner = function() {};\nexports.Scanner.prototype = Object.create( require('events').EventEmitter.prototype );\n\n/**\n    Recursively searches the given searchPaths for js files.\n    @param {Array.<string>} searchPaths\n    @param {number} [depth=1]\n    @fires sourceFileFound\n */\nexports.Scanner.prototype.scan = function(searchPaths, depth, filter) {\n    var currentFile;\n    var filePaths = [];\n    var isFile;\n    var self = this;\n\n    searchPaths = searchPaths || [];\n    depth = depth || 1;\n\n    searchPaths.forEach(function($) {\n        var filepath = path.resolve( env.pwd, decodeURIComponent($) );\n\n        try {\n            currentFile = fs.statSync(filepath);\n        }\n        catch (e) {\n            logger.error('Unable to find the source file or directory %s', filepath);\n            return;\n        }\n\n        if ( currentFile.isFile() ) {\n            filePaths.push(filepath);\n        }\n        else {\n            filePaths = filePaths.concat( fs.ls(filepath, depth) );\n        }\n    });\n\n    filePaths = filePaths.filter(function($) {\n        return filter.isIncluded($);\n    });\n\n    filePaths = filePaths.filter(function($) {\n        var e = { fileName: $ };\n        self.emit('sourceFileFound', e);\n\n        return !e.defaultPrevented;\n    });\n\n    return filePaths;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/fs.js":"/**\n * Extended version of the standard `fs` module.\n * @module jsdoc/fs\n */\n'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar stream = require('stream');\nvar mkdirp = require('mkdirp');\n\nvar ls = exports.ls = function(dir, recurse, _allFiles, _path) {\n    var file;\n    var files;\n    var isFile;\n\n    // first pass\n    if (_path === undefined) {\n        _allFiles = [];\n        _path = [dir];\n    }\n\n    if (!_path.length) {\n        return _allFiles;\n    }\n\n    if (recurse === undefined) {\n        recurse = 1;\n    }\n\n    try {\n        isFile = fs.statSync(dir).isFile();\n    }\n    catch (e) {\n        isFile = false;\n    }\n    if (isFile) {\n        files = [dir];\n    }\n    else {\n        files = fs.readdirSync(dir);\n    }\n\n    for (var i = 0, l = files.length; i < l; i++) {\n        file = String(files[i]);\n\n        // skip dot files\n        if (file.match(/^\\.[^\\.\\/\\\\]/)) {\n            continue;\n        }\n\n        if ( fs.statSync(path.join(_path.join('/'), file)).isDirectory() ) {\n            // it's a directory\n            _path.push(file);\n\n            if (_path.length - 1 < recurse) {\n                ls(_path.join('/'), recurse, _allFiles, _path);\n            }\n            _path.pop();\n        }\n        else {\n            // it's a file\n            _allFiles.push( path.normalize(path.join(_path.join('/'), file)) );\n        }\n    }\n\n    return _allFiles;\n};\n\nvar toDir = exports.toDir = function(_path) {\n    var isDirectory;\n\n    _path = path.normalize(_path);\n\n    try {\n        isDirectory = fs.statSync(_path).isDirectory();\n    }\n    catch (e) {\n        isDirectory = false;\n    }\n\n    if (isDirectory) {\n       return _path;\n    } else {\n        return path.dirname(_path);\n    }\n};\n\nexports.mkPath = function(_path) {\n    if ( Array.isArray(_path) ) {\n        _path = _path.join('');\n    }\n\n    mkdirp.sync(_path);\n};\n\n// adapted from http://procbits.com/2011/11/15/synchronous-file-copy-in-node-js\nexports.copyFileSync = function(inFile, outDir, fileName) {\n    var BUF_LENGTH = 64 * 1024;\n\n    var read;\n    var write;\n\n    var buffer = new Buffer(BUF_LENGTH);\n    var bytesRead = 1;\n    var outFile = path.join( outDir, fileName || path.basename(inFile) );\n    var pos = 0;\n\n    mkdirp.sync(outDir);\n    read = fs.openSync(inFile, 'r');\n    write = fs.openSync(outFile, 'w');\n\n    while (bytesRead > 0) {\n        bytesRead = fs.readSync(read, buffer, 0, BUF_LENGTH, pos);\n        fs.writeSync(write, buffer, 0, bytesRead);\n        pos += bytesRead;\n    }\n\n    fs.closeSync(read);\n    return fs.closeSync(write);\n};\n\nObject.keys(fs).forEach(function(member) {\n    exports[member] = fs[member];\n});\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/util/logger.js":"/**\n * Logging tools for JSDoc.\n *\n * Log messages are printed to the console based on the current logging level. By default, messages\n * at level `{@link module:jsdoc/util/logger.LEVELS.ERROR}` or above are logged; all other messages\n * are ignored.\n *\n * In addition, the module object emits an event whenever a logger method is called, regardless of\n * the current logging level. The event's name is the string `logger:` followed by the logger's name\n * (for example, `logger:error`). The event handler receives an array of arguments that were passed\n * to the logger method.\n *\n * Each logger method accepts a `message` parameter that may contain zero or more placeholders. Each\n * placeholder is replaced by the corresponding argument following the message. If the placeholder\n * does not have a corresponding argument, the placeholder is not replaced.\n *\n * The following placeholders are supported:\n *\n * + `%s`: String.\n * + `%d`: Number.\n * + `%j`: JSON.\n *\n * @module jsdoc/util/logger\n * @extends module:events.EventEmitter\n * @example\n * var logger = require('jsdoc/util/logger');\n *\n * var data = {\n *   foo: 'bar'\n * };\n * var name = 'baz';\n *\n * logger.warn('%j %s', data, name);  // prints '{\"foo\":\"bar\"} baz'\n * @see http://nodejs.org/api/util.html#util_util_format_format\n */\n'use strict';\n\nvar util = require('util');\n\nfunction Logger() {}\nutil.inherits(Logger, require('events').EventEmitter);\n\nvar logger = module.exports = new Logger();\n\n/**\n * Logging levels for the JSDoc logger. The default logging level is\n * {@link module:jsdoc/util/logger.LEVELS.ERROR}.\n *\n * @alias module:jsdoc/util/logger.LEVELS\n * @enum\n * @type {number}\n */\nvar LEVELS = logger.LEVELS = {\n    /**\n     * Do not log any messages.\n     *\n     * @alias module:jsdoc/util/logger.LEVELS.SILENT\n     */\n    SILENT: 0,\n    /**\n     * Log fatal errors that prevent JSDoc from running.\n     *\n     * @alias module:jsdoc/util/logger.LEVELS.FATAL\n     */\n    FATAL: 10,\n    /**\n     * Log all errors, including errors from which JSDoc can recover.\n     *\n     * @alias module:jsdoc/util/logger.LEVELS.ERROR\n     */\n    ERROR: 20,\n    /**\n     * Log the following messages:\n     *\n     * + Warnings\n     * + Errors\n     *\n     * @alias module:jsdoc/util/logger.LEVELS.WARN\n     */\n    WARN: 30,\n    /**\n     * Log the following messages:\n     *\n     * + Informational messages\n     * + Warnings\n     * + Errors\n     *\n     * @alias module:jsdoc/util/logger.LEVELS.INFO\n     */\n    INFO: 40,\n    /**\n     * Log the following messages:\n     *\n     * + Debugging messages\n     * + Informational messages\n     * + Warnings\n     * + Errors\n     *\n     * @alias module:jsdoc/util/logger.LEVELS.DEBUG\n     */\n    DEBUG: 50,\n    /**\n     * Log all messages.\n     *\n     * @alias module:jsdoc/util/logger.LEVELS.VERBOSE\n     */\n    VERBOSE: 1000\n};\n\nvar DEFAULT_LEVEL = LEVELS.WARN;\nvar logLevel = DEFAULT_LEVEL;\n\nvar PREFIXES = {\n    DEBUG: 'DEBUG: ',\n    ERROR: 'ERROR: ',\n    FATAL: 'FATAL: ',\n    WARN: 'WARNING: '\n};\n\n// Add a prefix to a log message if necessary.\nfunction addPrefix(args, prefix) {\n    var updatedArgs;\n\n    if (prefix && typeof args[0] === 'string') {\n        updatedArgs = args.slice(0);\n        updatedArgs[0] = prefix + updatedArgs[0];\n    }\n\n    return updatedArgs || args;\n}\n\n// TODO: document events\nfunction wrapLogFunction(name, func) {\n    var eventName = 'logger:' + name;\n    var upperCaseName = name.toUpperCase();\n    var level = LEVELS[upperCaseName];\n    var prefix = PREFIXES[upperCaseName];\n\n    return function() {\n        var loggerArgs;\n\n        var args = Array.prototype.slice.call(arguments, 0);\n\n        if (logLevel >= level) {\n            loggerArgs = addPrefix(args, prefix);\n            func.apply(null, loggerArgs);\n        }\n\n        args.unshift(eventName);\n        logger.emit.apply(logger, args);\n    };\n}\n\n// Print a message to STDOUT without a terminating newline.\nfunction printToStdout() {\n    var args = Array.prototype.slice.call(arguments, 0);\n\n    process.stdout.write( util.format.apply(util, args) );\n}\n\n/**\n * Log a message at log level {@link module:jsdoc/util/logger.LEVELS.DEBUG}.\n *\n * @alias module:jsdoc/util/logger.debug\n * @param {string} message - The message to log.\n * @param {...*=} values - The values that will replace the message's placeholders.\n */\nlogger.debug = wrapLogFunction('debug', console.info);\n/**\n * Print a string at log level {@link module:jsdoc/util/logger.LEVELS.DEBUG}. The string is not\n * terminated by a newline.\n *\n * @alias module:jsdoc/util/logger.printDebug\n * @param {string} message - The message to log.\n * @param {...*=} values - The values that will replace the message's placeholders.\n */\nlogger.printDebug = wrapLogFunction('debug', printToStdout);\n/**\n * Log a message at log level {@link module:jsdoc/util/logger.LEVELS.ERROR}.\n *\n * @alias module:jsdoc/util/logger.error\n * @param {string} message - The message to log.\n * @param {...*=} values - The values that will replace the message's placeholders.\n */\nlogger.error = wrapLogFunction('error', console.error);\n/**\n * Log a message at log level {@link module:jsdoc/util/logger.LEVELS.FATAL}.\n *\n * @alias module:jsdoc/util/logger.fatal\n * @param {string} message - The message to log.\n * @param {...*=} values - The values that will replace the message's placeholders.\n */\nlogger.fatal = wrapLogFunction('fatal', console.error);\n/**\n * Log a message at log level {@link module:jsdoc/util/logger.LEVELS.INFO}.\n *\n * @alias module:jsdoc/util/logger.info\n * @param {string} message - The message to log.\n * @param {...*=} values - The values that will replace the message's placeholders.\n */\nlogger.info = wrapLogFunction('info', console.info);\n/**\n * Print a string at log level {@link module:jsdoc/util/logger.LEVELS.INFO}. The string is not\n * terminated by a newline.\n *\n * @alias module:jsdoc/util/logger.printInfo\n * @param {string} message - The message to log.\n * @param {...*=} values - The values that will replace the message's placeholders.\n */\nlogger.printInfo = wrapLogFunction('info', printToStdout);\n/**\n * Log a message at log level {@link module:jsdoc/util/logger.LEVELS.VERBOSE}.\n *\n * @alias module:jsdoc/util/logger.verbose\n * @param {string} message - The message to log.\n * @param {...*=} values - The values that will replace the message's placeholders.\n */\nlogger.verbose = wrapLogFunction('verbose', console.info);\n/**\n * Print a string at log level {@link module:jsdoc/util/logger.LEVELS.VERBOSE}. The string is not\n * terminated by a newline.\n *\n * @alias module:jsdoc/util/logger.printVerbose\n * @param {string} message - The message to log.\n * @param {...*=} values - The values that will replace the message's placeholders.\n */\nlogger.printVerbose = wrapLogFunction('verbose', printToStdout);\n/**\n * Log a message at log level {@link module:jsdoc/util/logger.LEVELS.WARN}.\n *\n * @alias module:jsdoc/util/logger.warn\n * @param {string} message - The message to log.\n * @param {...*=} values - The values that will replace the message's placeholders.\n */\nlogger.warn = wrapLogFunction('warn', console.warn);\n\n/**\n * Set the log level.\n *\n * @alias module:jsdoc/util/logger.setLevel\n * @param {module:jsdoc/util/logger.LEVELS} level - The log level to use.\n */\nlogger.setLevel = function setLevel(level) {\n    logLevel = (level !== undefined) ? level : DEFAULT_LEVEL;\n};\n\n/**\n * Get the current log level.\n *\n * @alias module:jsdoc/util/logger.getLevel\n * @return {module:jsdoc/util/logger.LEVELS} The current log level.\n */\nlogger.getLevel = function getLevel() {\n    return logLevel;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/path.js":"/**\n * Extended version of the standard `path` module.\n * @module jsdoc/path\n */\n'use strict';\n\nvar env = require('jsdoc/env');\nvar fs = require('fs');\nvar path = require('path');\n\nfunction prefixReducer(previousPath, current) {\n    var currentPath = [];\n\n    // if previousPath is defined, but has zero length, there's no common prefix; move along\n    if (previousPath && !previousPath.length) {\n        return currentPath;\n    }\n\n    currentPath = path.resolve(env.pwd, current).split(path.sep) || [];\n\n    if (previousPath && currentPath.length) {\n        // remove chunks that exceed the previous path's length\n        currentPath = currentPath.slice(0, previousPath.length);\n\n        // if a chunk doesn't match the previous path, remove everything from that chunk on\n        for (var i = 0, l = currentPath.length; i < l; i++) {\n            if (currentPath[i] !== previousPath[i]) {\n                currentPath.splice(i, currentPath.length - i);\n                break;\n            }\n        }\n    }\n\n    return currentPath;\n}\n\n/**\n * Find the common prefix for an array of paths. If there is a common prefix, a trailing separator\n * is appended to the prefix. Relative paths are resolved relative to the current working directory.\n *\n * For example, assuming that the current working directory is `/Users/jsdoc`:\n *\n * + For the single path `foo/bar/baz/qux.js`, the common prefix is `foo/bar/baz/`.\n * + For paths `foo/bar/baz/qux.js`, `foo/bar/baz/quux.js`, and `foo/bar/baz.js`, the common prefix\n * is `/Users/jsdoc/foo/bar/`.\n * + For paths `../jsdoc/foo/bar/baz/qux/quux/test.js`, `/Users/jsdoc/foo/bar/bazzy.js`, and\n * `../../Users/jsdoc/foo/bar/foobar.js`, the common prefix is `/Users/jsdoc/foo/bar/`.\n * + For paths `foo/bar/baz/qux.js` and `../../Library/foo/bar/baz.js`, there is no common prefix,\n * and an empty string is returned.\n *\n * @param {Array.<string>} paths - The paths to search for a common prefix.\n * @return {string} The common prefix, or an empty string if there is no common prefix.\n */\nexports.commonPrefix = function(paths) {\n    var segments;\n\n    var prefix = '';\n\n    paths = paths || [];\n\n    // if there's only one path, its resolved dirname (plus a trailing slash) is the common prefix\n    if (paths.length === 1) {\n        prefix = path.resolve(env.pwd, paths[0]);\n        if ( path.extname(prefix) ) {\n            prefix = path.dirname(prefix);\n        }\n\n        prefix += path.sep;\n    }\n    else {\n        segments = paths.reduce(prefixReducer, undefined) || [];\n\n        // if there's anything left (other than a placeholder for a leading slash), add a\n        // placeholder for a trailing slash\n        if ( segments.length && (segments.length > 1 || segments[0] !== '') ) {\n            segments.push('');\n        }\n\n        prefix = segments.join(path.sep);\n    }\n\n    return prefix;\n};\n\n/**\n * Retrieve the fully qualified path to the requested resource.\n *\n * If the resource path is specified as a relative path, JSDoc searches for the path in the\n * directory where the JSDoc configuration file is located, then in the current working directory,\n * and finally in the JSDoc directory.\n *\n * If the resource path is specified as a fully qualified path, JSDoc uses the path as-is.\n *\n * @param {string} filepath - The path to the requested resource. May be an absolute path; a path\n * relative to the JSDoc directory; or a path relative to the current working directory.\n * @param {string} [filename] - The filename of the requested resource.\n * @return {string} The fully qualified path to the requested resource.\n * Includes the filename if one was provided.\n */\nexports.getResourcePath = function(filepath, filename) {\n    var result = null;\n\n    function pathExists(_path) {\n        try {\n            fs.readdirSync(_path);\n        }\n        catch (e) {\n            return false;\n        }\n\n        return true;\n    }\n\n    // absolute paths are normalized by path.resolve on the first pass\n    [path.dirname(env.opts.configure || ''), env.pwd, env.dirname].forEach(function(_path) {\n        if (!result && _path) {\n            _path = path.resolve(_path, filepath);\n            if ( pathExists(_path) ) {\n                result = _path;\n            }\n        }\n    });\n\n    if (result) {\n        result = filename ? path.join(result, filename) : result;\n    }\n\n    return result;\n};\n\nObject.keys(path).forEach(function(member) {\n    exports[member] = path[member];\n});\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/cli.js":"/* global java */\n/* eslint no-process-exit:0, strict: [2, \"function\"] */\n/**\n * Helper methods for running JSDoc on the command line.\n *\n * A few critical notes for anyone who works on this module:\n *\n * + The module should really export an instance of `cli`, and `props` should be properties of a\n * `cli` instance.\n *\n * @private\n */\nmodule.exports = (function() {\n'use strict';\n\nvar app = require('jsdoc/app');\nvar env = require('jsdoc/env');\nvar logger = require('jsdoc/util/logger');\nvar stripJsonComments = require('strip-json-comments');\nvar Promise = require('bluebird');\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\nvar props = {\n    docs: [],\n    packageJson: null,\n    shouldExitWithError: false,\n    tmpdir: null\n};\n\nvar FATAL_ERROR_MESSAGE = 'Exiting JSDoc because an error occurred. See the previous log ' +\n    'messages for details.';\nvar cli = {};\n\n// TODO: docs\ncli.setVersionInfo = function() {\n    var fs = require('fs');\n    var path = require('path');\n\n    // allow this to throw--something is really wrong if we can't read our own package file\n    var info = JSON.parse( fs.readFileSync(path.join(env.dirname, 'package.json'), 'utf8') );\n\n    env.version = {\n        number: info.version,\n        revision: new Date( parseInt(info.revision, 10) ).toUTCString()\n    };\n\n    return cli;\n};\n\n// TODO: docs\ncli.loadConfig = function() {\n    var _ = require('underscore');\n    var args = require('jsdoc/opts/args');\n    var Config = require('jsdoc/config');\n    var fs = require('jsdoc/fs');\n    var path = require('jsdoc/path');\n\n    var confPath;\n    var isFile;\n\n    var defaultOpts = {\n        destination: './out/',\n        encoding: 'utf8'\n    };\n\n    try {\n        env.opts = args.parse(env.args);\n    }\n    catch (e) {\n        console.error(e.message + '\\n');\n        cli.printHelp().then(function () {\n            cli.exit(1);\n        });\n    }\n\n    confPath = env.opts.configure || path.join(env.dirname, 'conf.json');\n    try {\n        isFile = fs.statSync(confPath).isFile();\n    }\n    catch (e) {\n        isFile = false;\n    }\n\n    if ( !isFile && !env.opts.configure ) {\n        confPath = path.join(env.dirname, 'conf.json.EXAMPLE');\n    }\n\n    try {\n        env.conf = new Config( stripJsonComments(fs.readFileSync(confPath, 'utf8')) )\n            .get();\n    }\n    catch (e) {\n        cli.exit(1, 'Cannot parse the config file ' + confPath + ': ' + e + '\\n' +\n            FATAL_ERROR_MESSAGE);\n    }\n\n    // look for options on the command line, in the config file, and in the defaults, in that order\n    env.opts = _.defaults(env.opts, env.conf.opts, defaultOpts);\n\n    return cli;\n};\n\n// TODO: docs\ncli.configureLogger = function() {\n    function recoverableError() {\n        props.shouldExitWithError = true;\n    }\n\n    function fatalError() {\n        cli.exit(1);\n    }\n\n    if (env.opts.debug) {\n        logger.setLevel(logger.LEVELS.DEBUG);\n    }\n    else if (env.opts.verbose) {\n        logger.setLevel(logger.LEVELS.INFO);\n    }\n\n    if (env.opts.pedantic) {\n        logger.once('logger:warn', recoverableError);\n        logger.once('logger:error', fatalError);\n    }\n    else {\n        logger.once('logger:error', recoverableError);\n    }\n\n    logger.once('logger:fatal', fatalError);\n\n    return cli;\n};\n\n// TODO: docs\ncli.logStart = function() {\n    logger.debug( cli.getVersion() );\n\n    logger.debug('Environment info: %j', {\n        env: {\n            conf: env.conf,\n            opts: env.opts\n        }\n    });\n};\n\n// TODO: docs\ncli.logFinish = function() {\n    var delta;\n    var deltaSeconds;\n\n    if (env.run.finish && env.run.start) {\n        delta = env.run.finish.getTime() - env.run.start.getTime();\n    }\n\n    if (delta !== undefined) {\n        deltaSeconds = (delta / 1000).toFixed(2);\n        logger.info('Finished running in %s seconds.', deltaSeconds);\n    }\n};\n\n// TODO: docs\ncli.runCommand = function(cb) {\n    var cmd;\n\n    var opts = env.opts;\n\n    if (opts.help) {\n        cmd = cli.printHelp;\n    }\n    else if (opts.test) {\n        cmd = cli.runTests;\n    }\n    else if (opts.version) {\n        cmd = cli.printVersion;\n    }\n    else {\n        cmd = cli.main;\n    }\n\n    cmd().then(function (errorCode) {\n        if (!errorCode && props.shouldExitWithError) {\n            errorCode = 1;\n        }\n        cb(errorCode);\n    });\n};\n\n// TODO: docs\ncli.printHelp = function() {\n    cli.printVersion();\n    console.log( '\\n' + require('jsdoc/opts/args').help() + '\\n' );\n    console.log('Visit http://usejsdoc.org for more information.');\n    return Promise.resolve(0);\n};\n\n// TODO: docs\ncli.runTests = function() {\n    var path = require('jsdoc/path');\n\n    var runner = Promise.promisify(require( path.join(env.dirname, 'test/runner') ));\n\n    console.log('Running tests...');\n    return runner();\n};\n\n// TODO: docs\ncli.getVersion = function() {\n    return 'JSDoc ' + env.version.number + ' (' + env.version.revision + ')';\n};\n\n// TODO: docs\ncli.printVersion = function() {\n    console.log( cli.getVersion() );\n    return Promise.resolve(0);\n};\n\n// TODO: docs\ncli.main = function() {\n    cli.scanFiles();\n\n    if (env.sourceFiles.length === 0) {\n        console.log('There are no input files to process.\\n');\n        return cli.printHelp();\n    } else {\n        return cli.createParser()\n            .parseFiles()\n            .processParseResults()\n            .then(function () {\n                env.run.finish = new Date();\n                return 0;\n            });\n    }\n};\n\nfunction readPackageJson(filepath) {\n    var fs = require('jsdoc/fs');\n\n    try {\n        return stripJsonComments( fs.readFileSync(filepath, 'utf8') );\n    }\n    catch (e) {\n        logger.error('Unable to read the package file \"%s\"', filepath);\n        return null;\n    }\n}\n\nfunction buildSourceList() {\n    var fs = require('jsdoc/fs');\n    var Readme = require('jsdoc/readme');\n\n    var packageJson;\n    var readmeHtml;\n    var sourceFile;\n    var sourceFiles = env.opts._ ? env.opts._.slice(0) : [];\n\n    if (env.conf.source && env.conf.source.include) {\n        sourceFiles = sourceFiles.concat(env.conf.source.include);\n    }\n\n    // load the user-specified package/README files, if any\n    if (env.opts.package) {\n        packageJson = readPackageJson(env.opts.package);\n    }\n    if (env.opts.readme) {\n        readmeHtml = new Readme(env.opts.readme).html;\n    }\n\n    // source files named `package.json` or `README.md` get special treatment, unless the user\n    // explicitly specified a package and/or README file\n    for (var i = 0, l = sourceFiles.length; i < l; i++) {\n        sourceFile = sourceFiles[i];\n\n        if ( !env.opts.package && /\\bpackage\\.json$/i.test(sourceFile) ) {\n            packageJson = readPackageJson(sourceFile);\n            sourceFiles.splice(i--, 1);\n        }\n\n        if ( !env.opts.readme && /(\\bREADME|\\.md)$/i.test(sourceFile) ) {\n            readmeHtml = new Readme(sourceFile).html;\n            sourceFiles.splice(i--, 1);\n        }\n    }\n\n    props.packageJson = packageJson;\n    env.opts.readme = readmeHtml;\n\n    return sourceFiles;\n}\n\n// TODO: docs\ncli.scanFiles = function() {\n    var Filter = require('jsdoc/src/filter').Filter;\n\n    var filter;\n\n    env.opts._ = buildSourceList();\n\n    // are there any files to scan and parse?\n    if (env.conf.source && env.opts._.length) {\n        filter = new Filter(env.conf.source);\n\n        env.sourceFiles = app.jsdoc.scanner.scan(env.opts._, (env.opts.recurse ? 10 : undefined),\n            filter);\n    }\n\n    return cli;\n};\n\nfunction resolvePluginPaths(paths) {\n    var path = require('jsdoc/path');\n\n    var pluginPaths = [];\n\n    paths.forEach(function(plugin) {\n        var basename = path.basename(plugin);\n        var dirname = path.dirname(plugin);\n        var pluginPath = path.getResourcePath(dirname);\n\n        if (!pluginPath) {\n            logger.error('Unable to find the plugin \"%s\"', plugin);\n            return;\n        }\n\n        pluginPaths.push( path.join(pluginPath, basename) );\n    });\n\n    return pluginPaths;\n}\n\ncli.createParser = function() {\n    var handlers = require('jsdoc/src/handlers');\n    var parser = require('jsdoc/src/parser');\n    var path = require('jsdoc/path');\n    var plugins = require('jsdoc/plugins');\n\n    app.jsdoc.parser = parser.createParser(env.conf.parser);\n\n    if (env.conf.plugins) {\n        env.conf.plugins = resolvePluginPaths(env.conf.plugins);\n        plugins.installPlugins(env.conf.plugins, app.jsdoc.parser);\n    }\n\n    handlers.attachTo(app.jsdoc.parser);\n\n    return cli;\n};\n\ncli.parseFiles = function() {\n    var augment = require('jsdoc/augment');\n    var borrow = require('jsdoc/borrow');\n    var Package = require('jsdoc/package').Package;\n\n    var docs;\n    var packageDocs;\n\n    props.docs = docs = app.jsdoc.parser.parse(env.sourceFiles, env.opts.encoding);\n\n    // If there is no package.json, just create an empty package\n    packageDocs = new Package(props.packageJson);\n    packageDocs.files = env.sourceFiles || [];\n    docs.push(packageDocs);\n\n    logger.debug('Indexing doclets...');\n    borrow.indexAll(docs);\n    logger.debug('Adding inherited symbols, mixins, and interface implementations...');\n    augment.augmentAll(docs);\n    logger.debug('Adding borrowed doclets...');\n    borrow.resolveBorrows(docs);\n    logger.debug('Post-processing complete.');\n\n    app.jsdoc.parser.fireProcessingComplete(docs);\n\n    return cli;\n};\n\ncli.processParseResults = function() {\n    if (env.opts.explain) {\n        cli.dumpParseResults();\n        return Promise.resolve();\n    }\n    else {\n        cli.resolveTutorials();\n        return cli.generateDocs();\n    }\n};\n\ncli.dumpParseResults = function() {\n    console.log(require('jsdoc/util/dumper').dump(props.docs));\n\n    return cli;\n};\n\ncli.resolveTutorials = function() {\n    var resolver = require('jsdoc/tutorial/resolver');\n\n    if (env.opts.tutorials) {\n        resolver.load(env.opts.tutorials);\n        resolver.resolve();\n    }\n\n    return cli;\n};\n\ncli.generateDocs = function() {\n    var path = require('jsdoc/path');\n    var resolver = require('jsdoc/tutorial/resolver');\n    var taffy = require('taffydb').taffy;\n\n    var template;\n\n    env.opts.template = (function() {\n        var publish = env.opts.template || 'templates/default';\n        var templatePath = path.getResourcePath(publish);\n\n        // if we didn't find the template, keep the user-specified value so the error message is\n        // useful\n        return templatePath || env.opts.template;\n    })();\n\n    try {\n        template = require(env.opts.template + '/publish');\n    }\n    catch (e) {\n        logger.fatal('Unable to load template: ' + e.message || e);\n    }\n\n    // templates should include a publish.js file that exports a \"publish\" function\n    if (template.publish && typeof template.publish === 'function') {\n        logger.info('Generating output files...');\n        var publishPromise = template.publish(\n            taffy(props.docs),\n            env.opts,\n            resolver.root\n        );\n\n        return Promise.resolve(publishPromise);\n    }\n    else {\n        logger.fatal(env.opts.template + ' does not export a \"publish\" function. Global ' +\n            '\"publish\" functions are no longer supported.');\n    }\n    return Promise.resolve();\n};\n\n// TODO: docs\ncli.exit = function(exitCode, message) {\n    if (exitCode > 0) {\n        if (message) {\n            console.error(message);\n        }\n        process.exit(exitCode);\n    }\n};\n\nreturn cli;\n})();\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/opts/args.js":"/**\n * @module jsdoc/opts/args\n * @requires jsdoc/opts/argparser\n * @author Michael Mathews <micmath@gmail.com>\n * @license Apache License 2.0 - See file 'LICENSE.md' in this project.\n */\n'use strict';\n\nvar ArgParser = require('jsdoc/opts/argparser');\nvar cast = require('jsdoc/util/cast').cast;\nvar querystring = require('querystring');\nvar util = require('util');\n\nvar ourOptions;\n\nvar argParser = new ArgParser();\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\nfunction parseQuery(str) {\n    return cast( querystring.parse(str) );\n}\n\n/* eslint-disable no-multi-spaces */\nargParser.addOption('a', 'access',      true,  'Only display symbols with the given access: \"public\", \"protected\", \"private\" or \"undefined\", or \"all\" for all access levels. Default: all except \"private\"', true);\nargParser.addOption('c', 'configure',   true,  'The path to the configuration file. Default: path/to/jsdoc/conf.json');\nargParser.addOption('d', 'destination', true,  'The path to the output folder. Use \"console\" to dump data to the console. Default: ./out/');\nargParser.addOption('',  'debug',       false, 'Log information for debugging JSDoc.');\nargParser.addOption('e', 'encoding',    true,  'Assume this encoding when reading all source files. Default: utf8');\nargParser.addOption('h', 'help',        false, 'Print this message and quit.');\nargParser.addOption('',  'match',       true,  'When running tests, only use specs whose names contain <value>.', true);\nargParser.addOption('',  'nocolor',     false, 'When running tests, do not use color in console output.');\nargParser.addOption('p', 'private',     false, 'Display symbols marked with the @private tag. Equivalent to \"--access all\". Default: false');\nargParser.addOption('P', 'package',     true,  'The path to the project\\'s package file. Default: path/to/sourcefiles/package.json');\nargParser.addOption('',  'pedantic',    false, 'Treat errors as fatal errors, and treat warnings as errors. Default: false');\nargParser.addOption('q', 'query',       true,  'A query string to parse and store in jsdoc.env.opts.query. Example: foo=bar&baz=true', false, parseQuery);\nargParser.addOption('r', 'recurse',     false, 'Recurse into subdirectories when scanning for source files and tutorials.');\nargParser.addOption('R', 'readme',      true,  'The path to the project\\'s README file. Default: path/to/sourcefiles/README.md');\nargParser.addOption('t', 'template',    true,  'The path to the template to use. Default: path/to/jsdoc/templates/default');\nargParser.addOption('T', 'test',        false, 'Run all tests and quit.');\nargParser.addOption('u', 'tutorials',   true,  'Directory in which JSDoc should search for tutorials.');\nargParser.addOption('v', 'version',     false, 'Display the version number and quit.');\nargParser.addOption('',  'verbose',     false, 'Log detailed information to the console as JSDoc runs.');\nargParser.addOption('X', 'explain',     false, 'Dump all found doclet internals to console and quit.');\n/* eslint-enable no-multi-spaces */\n\n// Options that are no longer supported and should be ignored\nargParser.addIgnoredOption('l', 'lenient'); // removed in JSDoc 3.3.0\n\n/**\n * Set the options for this app.\n * @throws {Error} Illegal arguments will throw errors.\n * @param {string|String[]} args The command line arguments for this app.\n */\nexports.parse = function(args) {\n    args = args || [];\n\n    if (typeof args === 'string' || args.constructor === String) {\n        args = String(args).split(/\\s+/g);\n    }\n\n    ourOptions = argParser.parse(args);\n\n    return ourOptions;\n};\n\n/**\n * Retrieve help message for options.\n */\nexports.help = function() {\n    return argParser.help();\n};\n\n/**\n * Get a named option.\n * @variation name\n * @param {string} name The name of the option.\n * @return {string} The value associated with the given name.\n *//**\n * Get all the options for this app.\n * @return {Object} A collection of key/values representing all the options.\n */\nexports.get = function(name) {\n    if (typeof name === 'undefined') {\n        return ourOptions;\n    }\n    else if ( hasOwnProp.call(ourOptions, name) ) {\n        return ourOptions[name];\n    }\n    return undefined;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/opts/argparser.js":"/**\n * Parse the command line arguments.\n * @module jsdoc/opts/argparser\n * @author Michael Mathews <micmath@gmail.com>\n * @license Apache License 2.0 - See file 'LICENSE.md' in this project.\n */\n'use strict';\n\nvar _ = require('underscore');\nvar util = require('util');\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\n/**\n * Create an instance of the parser.\n * @classdesc A parser to interpret the key-value pairs entered on the command line.\n * @constructor\n * @alias module:jsdoc/opts/argparser\n */\nvar ArgParser = function() {\n    this._options = [];\n    this._shortNameIndex = {};\n    this._longNameIndex = {};\n};\n\nArgParser.prototype._getOptionByShortName = function(name) {\n    if (hasOwnProp.call(this._shortNameIndex, name)) {\n        return this._options[this._shortNameIndex[name]];\n    }\n    return null;\n};\n\nArgParser.prototype._getOptionByLongName = function(name) {\n    if (hasOwnProp.call(this._longNameIndex, name)) {\n        return this._options[this._longNameIndex[name]];\n    }\n    return null;\n};\n\nArgParser.prototype._addOption = function(option) {\n    var currentIndex;\n\n    var longName = option.longName;\n    var shortName = option.shortName;\n\n    this._options.push(option);\n    currentIndex = this._options.length - 1;\n\n    if (shortName) {\n        this._shortNameIndex[shortName] = currentIndex;\n    }\n    if (longName) {\n        this._longNameIndex[longName] = currentIndex;\n    }\n\n    return this;\n};\n\n/**\n * Provide information about a legal option.\n * @param {character} shortName The short name of the option, entered like: -T.\n * @param {string}    longName The equivalent long name of the option, entered like: --test.\n * @param {boolean}   hasValue Does this option require a value? Like: -t templatename\n * @param {string}    helpText A brief description of the option.\n * @param {boolean}   [canHaveMultiple=false] Set to `true` if the option can be provided more than once.\n * @param {function}  [coercer] A function to coerce the given value to a specific type.\n * @return {this}\n * @example\n * myParser.addOption('t', 'template', true, 'The path to the template.');\n * myParser.addOption('h', 'help', false, 'Show the help message.');\n */\nArgParser.prototype.addOption = function(shortName, longName, hasValue, helpText, canHaveMultiple, coercer) {\n    var option = {\n        shortName: shortName,\n        longName: longName,\n        hasValue: hasValue,\n        helpText: helpText,\n        canHaveMultiple: (canHaveMultiple || false),\n        coercer: coercer\n    };\n\n    return this._addOption(option);\n};\n\n// TODO: refactor addOption to accept objects, then get rid of this method\n/**\n * Provide information about an option that should not cause an error if present, but that is always\n * ignored (for example, an option that was used in previous versions but is no longer supported).\n *\n * @private\n * @param {string} shortName - The short name of the option with a leading hyphen (for example,\n * `-v`).\n * @param {string} longName - The long name of the option with two leading hyphens (for example,\n * `--version`).\n */\nArgParser.prototype.addIgnoredOption = function(shortName, longName) {\n    var option = {\n        shortName: shortName,\n        longName: longName,\n        ignore: true\n    };\n\n    return this._addOption(option);\n};\n\nfunction padding(length) {\n    return new Array(length + 1).join(' ');\n}\n\nfunction padLeft(str, length) {\n    return padding(length) + str;\n}\n\nfunction padRight(str, length) {\n    return str + padding(length);\n}\n\nfunction findMaxLength(arr) {\n    var max = 0;\n\n    arr.forEach(function(item) {\n        if (item.length > max) {\n            max = item.length;\n        }\n    });\n\n    return max;\n}\n\nfunction concatWithMaxLength(items, maxLength) {\n    var result = '';\n    // to prevent endless loops, always use the first item, regardless of length\n    result += items.shift();\n\n    while ( items.length && (result.length + items[0].length < maxLength) ) {\n        result += ' ' + items.shift();\n    }\n\n    return result;\n}\n\n// we want to format names and descriptions like this:\n// |    -f, --foo    Very long description very long description very long    |\n// |                 description very long description.                       |\nfunction formatHelpInfo(options) {\n    var MARGIN_LENGTH = 4;\n    var results = [];\n\n    var maxLength = process.stdout.columns;\n    var maxNameLength = findMaxLength(options.names);\n    var maxDescriptionLength = findMaxLength(options.descriptions);\n\n    var wrapDescriptionAt = maxLength - (MARGIN_LENGTH * 3) - maxNameLength;\n    // build the string for each option\n    options.names.forEach(function(name, i) {\n        var result;\n        var partialDescription;\n        var words;\n\n        // add a left margin to the name\n        result = padLeft(options.names[i], MARGIN_LENGTH);\n        // and a right margin, with extra padding so the descriptions line up with one another\n        result = padRight(result, maxNameLength - options.names[i].length + MARGIN_LENGTH);\n\n        // split the description on spaces\n        words = options.descriptions[i].split(' ');\n        // add as much of the description as we can fit on the first line\n        result += concatWithMaxLength(words, wrapDescriptionAt);\n        // if there's anything left, keep going until we've consumed the description\n        while (words.length) {\n            partialDescription = padding( maxNameLength + (MARGIN_LENGTH * 2) );\n            partialDescription += concatWithMaxLength(words, wrapDescriptionAt);\n            result += '\\n' + partialDescription;\n        }\n\n        results.push(result);\n    });\n\n    return results;\n}\n\n/**\n * Generate a summary of all the options with corresponding help text.\n * @returns {string}\n */\nArgParser.prototype.help = function() {\n    var options = {\n        names: [],\n        descriptions: []\n    };\n\n    this._options.forEach(function(option) {\n        var name = '';\n\n        // don't show ignored options\n        if (option.ignore) {\n            return;\n        }\n\n        if (option.shortName) {\n            name += '-' + option.shortName + (option.longName ? ', ' : '');\n        }\n\n        if (option.longName) {\n            name += '--' + option.longName;\n        }\n\n        if (option.hasValue) {\n            name += ' <value>';\n        }\n\n        options.names.push(name);\n        options.descriptions.push(option.helpText);\n    });\n\n    return 'Options:\\n' + formatHelpInfo(options).join('\\n');\n};\n\n/**\n * Get the options.\n * @param {Array.<string>} args An array, like ['-x', 'hello']\n * @param {Object} [defaults={}] An optional collection of default values.\n * @returns {Object} The keys will be the longNames, or the shortName if no longName is defined for\n * that option. The values will be the values provided, or `true` if the option accepts no value.\n */\nArgParser.prototype.parse = function(args, defaults) {\n    var result = defaults && _.defaults({}, defaults) || {};\n\n    result._ = [];\n    for (var i = 0, leni = args.length; i < leni; i++) {\n        var arg = '' + args[i],\n            next = (i < leni - 1) ? '' + args[i + 1] : null,\n            option,\n            shortName = null,\n            longName,\n            name,\n            value = null;\n\n        // like -t\n        if (arg.charAt(0) === '-') {\n            // like --template\n            if (arg.charAt(1) === '-') {\n                name = longName = arg.slice(2);\n                option = this._getOptionByLongName(longName);\n            }\n            else {\n                name = shortName = arg.slice(1);\n                option = this._getOptionByShortName(shortName);\n            }\n\n            if (option === null) {\n                throw new Error( util.format('Unknown command-line option \"%s\".', name) );\n            }\n\n            if (option.hasValue) {\n                value = next;\n                i++;\n\n                if (value === null || value.charAt(0) === '-') {\n                    throw new Error( util.format('The command-line option \"%s\" requires a value.', name) );\n                }\n            }\n            else {\n                value = true;\n            }\n\n            // skip ignored options now that we've consumed the option text\n            if (option.ignore) {\n                continue;\n            }\n\n            if (option.longName && shortName) {\n                name = option.longName;\n            }\n\n            if (typeof option.coercer === 'function') {\n                value = option.coercer(value);\n            }\n\n            // Allow for multiple options of the same type to be present\n            if (option.canHaveMultiple && hasOwnProp.call(result, name)) {\n                var val = result[name];\n\n                if (val instanceof Array) {\n                    val.push(value);\n                } else {\n                    result[name] = [val, value];\n                }\n            }\n            else {\n                result[name] = value;\n            }\n        }\n        else {\n            result._.push(arg);\n        }\n    }\n\n    return result;\n};\n\nmodule.exports = ArgParser;\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/util/cast.js":"'use strict';\n\n/**\n * Module to convert values between various JavaScript types.\n * @module\n * @private\n */\n\n/**\n * Check whether a string contains a boolean or numeric value, and convert the string to the\n * appropriate type if necessary.\n *\n * @private\n * @param {string} str - The string to convert.\n * @return {(string|number|boolean)} The converted value.\n */\nfunction castString(str) {\n    var number;\n    var result;\n\n    switch (str) {\n        case 'true':\n            result = true;\n            break;\n\n        case 'false':\n            result = false;\n            break;\n\n        case 'NaN':\n            result = NaN;\n            break;\n\n        case 'null':\n            result = null;\n            break;\n\n        case 'undefined':\n            result = undefined;\n            break;\n\n        default:\n            if (typeof str === 'string') {\n                if (str.indexOf('.') !== -1) {\n                    number = parseFloat(str);\n                }\n                else {\n                    number = parseInt(str, 10);\n                }\n\n                if ( String(number) === str && !isNaN(number) ) {\n                    result = number;\n                }\n                else {\n                    result = str;\n                }\n            }\n    }\n\n    return result;\n}\n\n/**\n * Check whether a string contains a boolean or numeric value, and convert the string to the\n * appropriate type if necessary.\n *\n * If an object or array is passed to this method, the object or array's values will be recursively\n * converted to the appropriate types. The original object or array is not modified.\n *\n * @private\n * @param {(string|Object|Array)} item - The item whose type will be converted.\n * @return {(string|number|boolean|Object|Array)} The converted value.\n */\nexports.cast = function cast(item) {\n    var result;\n\n    if ( Array.isArray(item) ) {\n        result = [];\n        for (var i = 0, l = item.length; i < l; i++) {\n            result[i] = cast(item[i]);\n        }\n    }\n    else if (typeof item === 'object' && item !== null) {\n        result = {};\n        Object.keys(item).forEach(function(prop) {\n            result[prop] = cast(item[prop]);\n        });\n    }\n    else if (typeof item === 'string') {\n        result = castString(item);\n    }\n    else {\n        result = item;\n    }\n\n    return result;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/config.js":"/**\n    @overview\n    @author Michael Mathews <micmath@gmail.com>\n    @license Apache License 2.0 - See file 'LICENSE.md' in this project.\n */\n\n/**\n    @module jsdoc/config\n */\n'use strict';\n\nfunction mergeRecurse(target, source) {\n    Object.keys(source).forEach(function(p) {\n        if ( source[p].constructor === Object ) {\n            if ( !target[p] ) {\n                target[p] = {};\n            }\n            mergeRecurse(target[p], source[p]);\n        }\n        else {\n            target[p] = source[p];\n        }\n    });\n\n    return target;\n}\n\n// required config values, override these defaults in your config.json if necessary\nvar defaults = {\n    tags: {\n        allowUnknownTags: true,\n        dictionaries: ['jsdoc', 'closure']\n    },\n    templates: {\n        monospaceLinks: false,\n        cleverLinks: false\n    },\n    source: {\n        includePattern: '.+\\\\.js(doc|x)?$',\n        excludePattern: ''\n    },\n    plugins: []\n};\n\n/**\n    @class\n    @classdesc Represents a JSDoc application configuration.\n    @param {string} [json] - The contents of config.json.\n */\nfunction Config(json) {\n    json = JSON.parse( (json || '{}') );\n    this._config = mergeRecurse(defaults, json);\n}\n\nmodule.exports = Config;\n\n/**\n    Get the merged configuration values.\n */\nConfig.prototype.get = function() {\n    return this._config;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/src/filter.js":"/**\n    @module jsdoc/src/filter\n\n    @author Michael Mathews <micmath@gmail.com>\n    @license Apache License 2.0 - See file 'LICENSE.md' in this project.\n */\n'use strict';\n\nvar env = require('jsdoc/env');\nvar path = require('jsdoc/path');\n\nfunction makeRegExp(config) {\n    var regExp = null;\n\n    if (config) {\n        regExp = (typeof config === 'string') ? new RegExp(config) : config;\n    }\n\n    return regExp;\n}\n\n/**\n    @constructor\n    @param {object} opts\n    @param {string[]} opts.exclude - Specific files to exclude.\n    @param {string|RegExp} opts.includePattern\n    @param {string|RegExp} opts.excludePattern\n */\nexports.Filter = function(opts) {\n    this.exclude = opts.exclude && Array.isArray(opts.exclude) ?\n        opts.exclude.map(function($) {\n            return path.resolve(env.pwd, $);\n        }) :\n        null;\n    this.includePattern = makeRegExp(opts.includePattern);\n    this.excludePattern = makeRegExp(opts.excludePattern);\n};\n\n/**\n    @param {string} filepath - The filepath to check.\n    @returns {boolean} Should the given file be included?\n */\nexports.Filter.prototype.isIncluded = function(filepath) {\n    var included = true;\n\n    filepath = path.resolve(env.pwd, filepath);\n\n    if ( this.includePattern && !this.includePattern.test(filepath) ) {\n        included = false;\n    }\n\n    if ( this.excludePattern && this.excludePattern.test(filepath) ) {\n        included = false;\n    }\n\n    if (this.exclude) {\n        this.exclude.forEach(function(exclude) {\n            if ( filepath.indexOf(exclude) === 0 ) {\n                included = false;\n            }\n        });\n    }\n\n    return included;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/readme.js":"/**\n * Make the contents of a README file available to include in the output.\n * @module jsdoc/readme\n * @author Michael Mathews <micmath@gmail.com>\n * @author Ben Blank <ben.blank@gmail.com>\n */\n'use strict';\n\nvar env = require('jsdoc/env');\nvar fs = require('jsdoc/fs');\nvar markdown = require('jsdoc/util/markdown');\n\n/**\n * @class\n * @classdesc Represents a README file.\n * @param {string} path - The filepath to the README.\n */\nfunction ReadMe(path) {\n    var content = fs.readFileSync(path, env.opts.encoding);\n    var parse = markdown.getParser();\n\n    this.html = parse(content);\n}\n\nmodule.exports = ReadMe;\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/util/markdown.js":"/**\n * Provides access to Markdown-related functions.\n * @module jsdoc/util/markdown\n * @author Michael Mathews <micmath@gmail.com>\n * @author Ben Blank <ben.blank@gmail.com>\n */\n'use strict';\n\nvar env = require('jsdoc/env');\nvar util = require('util');\n\n/**\n * Enumeration of Markdown parsers that are available.\n * @enum {String}\n */\nvar parserNames = {\n    /**\n     * The \"[markdown-js](https://github.com/evilstreak/markdown-js)\" (aka \"evilstreak\") parser.\n     *\n     * @deprecated Replaced by \"marked,\" as markdown-js does not support inline HTML.\n     */\n    evilstreak: 'marked',\n    /**\n     * The \"GitHub-flavored Markdown\" parser.\n     * @deprecated Replaced by \"marked.\"\n     */\n    gfm: 'marked',\n    /**\n     * The \"[Marked](https://github.com/chjj/marked)\" parser.\n     */\n    marked: 'marked'\n};\n\n/**\n * Escape underscores that occur within {@ ... } in order to protect them\n * from the markdown parser(s).\n * @param {String} source the source text to sanitize.\n * @returns {String} `source` where underscores within {@ ... } have been\n * protected with a preceding backslash (i.e. \\_) -- the markdown parsers\n * will strip the backslash and protect the underscore.\n */\nfunction escapeUnderscores(source) {\n    return source.replace(/\\{@[^}\\r\\n]+\\}/g, function (wholeMatch) {\n        return wholeMatch.replace(/(^|[^\\\\])_/g, '$1\\\\_');\n    });\n}\n\n/**\n * Escape HTTP/HTTPS URLs so that they are not automatically converted to HTML links.\n *\n * @param {string} source - The source text to escape.\n * @return {string} The source text with escape characters added to HTTP/HTTPS URLs.\n */\nfunction escapeUrls(source) {\n    return source.replace(/(https?)\\:\\/\\//g, '$1:\\\\/\\\\/');\n}\n\n/**\n * Unescape HTTP/HTTPS URLs after Markdown parsing is complete.\n *\n * @param {string} source - The source text to unescape.\n * @return {string} The source text with escape characters removed from HTTP/HTTPS URLs.\n */\nfunction unescapeUrls(source) {\n    return source.replace(/(https?)\\:\\\\\\/\\\\\\//g, '$1://');\n}\n\n/**\n * Escape characters in text within a code block.\n *\n * @param {string} source - The source text to escape.\n * @return {string} The escaped source text.\n */\nfunction escapeCode(source) {\n    return source.replace(/</g, '&lt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&#39;');\n}\n\n/**\n * Unencode quotes that occur within {@ ... } after the markdown parser has turned them\n * into html entities (unfortunately it isn't possible to escape them before parsing)\n *\n * @param {string} source - The source text to unencode.\n * @return {string} The source text with html entity `&quot;` converted back to standard quotes\n */\nfunction unencodeQuotes(source) {\n    return source.replace(/\\{@[^}\\r\\n]+\\}/g, function (wholeMatch) {\n        return wholeMatch.replace(/&quot;/g, '\"');\n    });\n}\n\n\n/**\n * Retrieve a function that accepts a single parameter containing Markdown source. The function uses\n * the specified parser to transform the Markdown source to HTML, then returns the HTML as a string.\n *\n * @private\n * @param {String} parserName The name of the selected parser.\n * @param {Object} [conf] Configuration for the selected parser, if any.\n * @returns {Function} A function that accepts Markdown source, feeds it to the selected parser, and\n * returns the resulting HTML.\n */\nfunction getParseFunction(parserName, conf) {\n    var logger = require('jsdoc/util/logger');\n    var marked = require('marked');\n\n    var markedRenderer;\n    var parserFunction;\n\n    conf = conf || {};\n\n    if (parserName === parserNames.marked) {\n        if (conf.hardwrap) {\n            marked.setOptions({breaks: true});\n        }\n\n        // Marked generates an \"id\" attribute for headers; this custom renderer suppresses it\n        markedRenderer = new marked.Renderer();\n\n        if (!conf.idInHeadings) {\n            markedRenderer.heading = function(text, level) {\n                return util.format('<h%s>%s</h%s>', level, text, level);\n            };\n        }\n\n        // Allow prettyprint to work on inline code samples\n        markedRenderer.code = function(code, language) {\n            var langClass = language ? ' lang-' + language : '';\n\n            return util.format( '<pre class=\"prettyprint source%s\"><code>%s</code></pre>',\n                langClass, escapeCode(code) );\n        };\n\n        parserFunction = function(source) {\n            var result;\n\n            source = escapeUnderscores(source);\n            source = escapeUrls(source);\n\n            result = marked(source, { renderer: markedRenderer })\n                .replace(/\\s+$/, '')\n                .replace(/&#39;/g, \"'\");\n\n            result = unescapeUrls(result);\n            result = unencodeQuotes(result);\n\n            return result;\n        };\n        parserFunction._parser = parserNames.marked;\n        return parserFunction;\n    }\n    else {\n        logger.error('Unrecognized Markdown parser \"%s\". Markdown support is disabled.',\n            parserName);\n        return undefined;\n    }\n}\n\n/**\n * Retrieve a Markdown parsing function based on the value of the `conf.json` file's\n * `env.conf.markdown` property. The parsing function accepts a single parameter containing Markdown\n * source. The function uses the parser specified in `conf.json` to transform the Markdown source to\n * HTML, then returns the HTML as a string.\n *\n * @returns {function} A function that accepts Markdown source, feeds it to the selected parser, and\n * returns the resulting HTML.\n */\nexports.getParser = function() {\n    var conf = env.conf.markdown;\n    if (conf && conf.parser) {\n        return getParseFunction(parserNames[conf.parser], conf);\n    }\n    else {\n        // marked is the default parser\n        return getParseFunction(parserNames.marked, conf);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/plugins/commentConvert.js":"/**\n    @overview Demonstrate how to modify the source code before the parser sees it.\n    @module plugins/commentConvert\n    @author Michael Mathews <micmath@gmail.com>\n */\n'use strict';\n\n/* eslint spaced-comment: 0 */\n\nexports.handlers = {\n    ///\n    /// Convert ///-style comments into jsdoc comments.\n    /// @param e\n    /// @param e.filename\n    /// @param e.source\n    ///\n    beforeParse: function(e) {\n        e.source = e.source.replace(/(\\n[ \\t]*\\/\\/\\/[^\\n]*)+/g, function($) {\n            var replacement = '\\n/**' + $.replace(/^[ \\t]*\\/\\/\\//mg, '').replace(/(\\n$|$)/, '*/$1');\n            return replacement;\n        });\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/plugins/commentsOnly.js":"/**\n * @overview Remove everything in a file except JSDoc-style comments. By enabling this plugin, you\n * can document source files that are not valid JavaScript (including source files for other\n * languages).\n * @module plugins/commentsOnly\n * @author Jeff Williams <jeffrey.l.williams@gmail.com>\n */\n'use strict';\n\nexports.handlers = {\n    beforeParse: function(e) {\n        // a JSDoc comment looks like: /**[one or more chars]*/\n        var comments = e.source.match(/\\/\\*\\*[\\s\\S]+?\\*\\//g);\n        if (comments) {\n            e.source = comments.join('\\n\\n');\n        } else {\n            e.source = ''; // If file has no comments, parser should still receive no code\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/plugins/escapeHtml.js":"/**\n    @overview Escape HTML tags in descriptions.\n    @module plugins/escapeHtml\n    @author Michael Mathews <micmath@gmail.com>\n */\n'use strict';\n\nexports.handlers = {\n    /**\n        Translate HTML tags in descriptions into safe entities.\n        Replaces <, & and newlines\n     */\n    newDoclet: function(e) {\n        if (e.doclet.description) {\n            e.doclet.description = e.doclet.description\n                                   .replace(/&/g, '&amp;')\n                                   .replace(/</g, '&lt;')\n                                   .replace(/\\r\\n|\\n|\\r/g, '<br>');\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/plugins/eventDumper.js":"/**\n * @overview Dump information about parser events to the console.\n * @module plugins/eventDumper\n * @author Jeff Williams <jeffrey.l.williams@gmail.com>\n */\n'use strict';\n\nvar _ = require('underscore');\nvar dump = require('jsdoc/util/dumper').dump;\nvar env = require('jsdoc/env');\nvar util = require('util');\n\nvar conf = env.conf.eventDumper || {};\n\n// Dump the included parser events (defaults to all events)\nvar events = conf.include || [\n    'parseBegin',\n    'fileBegin',\n    'beforeParse',\n    'jsdocCommentFound',\n    'symbolFound',\n    'newDoclet',\n    'fileComplete',\n    'parseComplete',\n    'processingComplete'\n];\n// Don't dump the excluded parser events\nif (conf.exclude) {\n    events = _.difference(events, conf.exclude);\n}\n\n/**\n * Replace AST node objects in events with a placeholder.\n *\n * @param {Object} o - An object whose properties may contain AST node objects.\n * @return {Object} The modified object.\n */\nfunction replaceNodeObjects(o) {\n    var doop = require('jsdoc/util/doop');\n\n    var OBJECT_PLACEHOLDER = '<Object>';\n\n    if (o.code && o.code.node) {\n        // don't break the original object!\n        o.code = doop(o.code);\n        o.code.node = OBJECT_PLACEHOLDER;\n    }\n\n    if (o.doclet && o.doclet.meta && o.doclet.meta.code && o.doclet.meta.code.node) {\n        // don't break the original object!\n        o.doclet.meta.code = doop(o.doclet.meta.code);\n        o.doclet.meta.code.node = OBJECT_PLACEHOLDER;\n    }\n\n    if (o.astnode) {\n        o.astnode = OBJECT_PLACEHOLDER;\n    }\n\n    return o;\n}\n\n/**\n * Get rid of unwanted crud in an event object.\n *\n * @param {object} e The event object.\n * @return {object} The fixed-up object.\n */\nfunction cleanse(e) {\n    var result = {};\n\n    Object.keys(e).forEach(function(prop) {\n        // by default, don't stringify properties that contain an array of functions\n        if (!conf.includeFunctions && util.isArray(e[prop]) && e[prop][0] &&\n            String(typeof e[prop][0]) === 'function') {\n            result[prop] = 'function[' + e[prop].length + ']';\n        }\n        // never include functions that belong to the object\n        else if (typeof e[prop] !== 'function') {\n            result[prop] = e[prop];\n        }\n    });\n\n    // allow users to omit node objects, which can be enormous\n    if (conf.omitNodes) {\n        result = replaceNodeObjects(result);\n    }\n\n    return result;\n}\n\nexports.handlers = {};\n\nevents.forEach(function(eventType) {\n    exports.handlers[eventType] = function(e) {\n        console.log( dump({\n            type: eventType,\n            content: cleanse(e)\n        }) );\n    };\n});\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/plugins/markdown.js":"/**\n * @overview Translate doclet descriptions from MarkDown into HTML.\n * @module plugins/markdown\n * @author Michael Mathews <micmath@gmail.com>\n * @author Ben Blank <ben.blank@gmail.com>\n */\n'use strict';\n\nvar env = require('jsdoc/env');\n\nvar config = env.conf.markdown || {};\nvar defaultTags = [\n    'author',\n    'classdesc',\n    'description',\n    'exceptions',\n    'params',\n    'properties',\n    'returns',\n    'see'\n];\nvar hasOwnProp = Object.prototype.hasOwnProperty;\nvar parse = require('jsdoc/util/markdown').getParser();\nvar tags = [];\nvar excludeTags = [];\n\nfunction shouldProcessString(tagName, text) {\n    var shouldProcess = true;\n\n    // we only want to process `@author` and `@see` tags that contain Markdown links\n    if ( (tagName === 'author' || tagName === 'see') && text.indexOf('[') === -1 ) {\n        shouldProcess = false;\n    }\n\n    return shouldProcess;\n}\n\n/**\n * Process the markdown source in a doclet. The properties that should be\n * processed are configurable, but always include \"classdesc\", \"description\",\n * \"params\", \"properties\", and \"returns\".  Handled properties can be bare\n * strings, objects, or arrays of objects.\n */\nfunction process(doclet) {\n    tags.forEach(function(tag) {\n        if ( !hasOwnProp.call(doclet, tag) ) {\n            return;\n        }\n\n        if (typeof doclet[tag] === 'string' && shouldProcessString(tag, doclet[tag]) ) {\n            doclet[tag] = parse(doclet[tag]);\n        }\n        else if ( Array.isArray(doclet[tag]) ) {\n            doclet[tag].forEach(function(value, index, original) {\n                var inner = {};\n                inner[tag] = value;\n                process(inner);\n                original[index] = inner[tag];\n            });\n        }\n        else if (doclet[tag]) {\n            process(doclet[tag]);\n        }\n    });\n}\n\n// set up the list of \"tags\" (properties) to process\nif (config.tags) {\n    tags = config.tags.slice();\n}\n// set up the list of default tags to exclude from processing\nif (config.excludeTags) {\n    excludeTags = config.excludeTags.slice();\n}\ndefaultTags.forEach(function(tag) {\n    if (excludeTags.indexOf(tag) === -1 && tags.indexOf(tag) === -1) {\n        tags.push(tag);\n    }\n});\n\nexports.handlers = {\n    /**\n     * Translate markdown syntax in a new doclet's description into HTML. Is run\n     * by JSDoc 3 whenever a \"newDoclet\" event fires.\n     */\n    newDoclet: function(e) {\n        process(e.doclet);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/plugins/overloadHelper.js":"/**\n * The Overload Helper plugin automatically adds a signature-like string to the longnames of\n * overloaded functions and methods. In JSDoc, this string is known as a _variation_. (The longnames\n * of overloaded constructor functions are _not_ updated, so that JSDoc can identify the class'\n * members correctly.)\n *\n * Using this plugin allows you to link to overloaded functions without manually adding `@variation`\n * tags to your documentation.\n *\n * For example, suppose your code includes a function named `foo` that you can call in the\n * following ways:\n *\n * + `foo()`\n * + `foo(bar)`\n * + `foo(bar, baz)` (where `baz` is repeatable)\n *\n * This plugin assigns the following variations and longnames to each version of `foo`:\n *\n * + `foo()` gets the variation `()` and the longname `foo()`.\n * + `foo(bar)` gets the variation `(bar)` and the longname `foo(bar)`.\n * + `foo(bar, baz)` (where `baz` is repeatable) gets the variation `(bar, ...baz)` and the longname\n * `foo(bar, ...baz)`.\n *\n * You can then link to these functions with `{@link foo()}`, `{@link foo(bar)}`, and\n * `{@link foo(bar, ...baz)`. Note that the variation is based on the names of the function\n * parameters, _not_ their types.\n *\n * If you prefer to manually assign variations to certain functions, you can still do so with the\n * `@variation` tag. This plugin will not change these variations or add more variations for that\n * function, as long as the variations you've defined result in unique longnames.\n *\n * If an overloaded function includes multiple signatures with the same parameter names, the plugin\n * will assign numeric variations instead, starting at `(1)` and counting upwards.\n *\n * @module plugins/overloadHelper\n * @author Jeff Williams <jeffrey.l.williams@gmail.com>\n * @license Apache License 2.0\n */\n'use strict';\n\n// lookup table of function doclets by longname\nvar functionDoclets;\n\nfunction hasUniqueValues(obj) {\n    var isUnique = true;\n    var seen = [];\n    Object.keys(obj).forEach(function(key) {\n        if (seen.indexOf(obj[key]) !== -1) {\n            isUnique = false;\n        }\n\n        seen.push(obj[key]);\n    });\n\n    return isUnique;\n}\n\nfunction getParamNames(params) {\n    var names = [];\n\n    params.forEach(function(param) {\n        var name = param.name || '';\n        if (param.variable) {\n            name = '...' + name;\n        }\n        if (name !== '') {\n            names.push(name);\n        }\n    });\n\n    return names.length ? names.join(', ') : '';\n}\n\nfunction getParamVariation(doclet) {\n    return getParamNames(doclet.params || []);\n}\n\nfunction getUniqueVariations(doclets) {\n    var counter = 0;\n    var variations = {};\n    var docletKeys = Object.keys(doclets);\n\n    function getUniqueNumbers() {\n        var format = require('util').format;\n\n        docletKeys.forEach(function(doclet) {\n            var newLongname;\n\n            while (true) {\n                counter++;\n                variations[doclet] = String(counter);\n\n                // is this longname + variation unique?\n                newLongname = format('%s(%s)', doclets[doclet].longname, variations[doclet]);\n                if ( !functionDoclets[newLongname] ) {\n                    break;\n                }\n            }\n        });\n    }\n\n    function getUniqueNames() {\n        // start by trying to preserve existing variations\n        docletKeys.forEach(function(doclet) {\n            variations[doclet] = doclets[doclet].variation || getParamVariation(doclets[doclet]);\n        });\n\n        // if they're identical, try again, without preserving existing variations\n        if ( !hasUniqueValues(variations) ) {\n            docletKeys.forEach(function(doclet) {\n                variations[doclet] = getParamVariation(doclets[doclet]);\n            });\n\n            // if they're STILL identical, switch to numeric variations\n            if ( !hasUniqueValues(variations) ) {\n                getUniqueNumbers();\n            }\n        }\n    }\n\n    // are we already using numeric variations? if so, keep doing that\n    if (functionDoclets[doclets.newDoclet.longname + '(1)']) {\n        getUniqueNumbers();\n    }\n    else {\n        getUniqueNames();\n    }\n\n    return variations;\n}\n\nfunction ensureUniqueLongname(newDoclet) {\n    var doclets = {\n        oldDoclet: functionDoclets[newDoclet.longname],\n        newDoclet: newDoclet\n    };\n    var docletKeys = Object.keys(doclets);\n    var oldDocletLongname;\n    var variations = {};\n\n    if (doclets.oldDoclet) {\n        oldDocletLongname = doclets.oldDoclet.longname;\n        // if the shared longname has a variation, like MyClass#myLongname(variation),\n        // remove the variation\n        if (doclets.oldDoclet.variation || doclets.oldDoclet.variation === '') {\n            docletKeys.forEach(function(doclet) {\n                doclets[doclet].longname = doclets[doclet].longname.replace(/\\([\\s\\S]*\\)$/, '');\n                doclets[doclet].variation = null;\n            });\n        }\n\n        variations = getUniqueVariations(doclets);\n\n        // update the longnames/variations\n        docletKeys.forEach(function(doclet) {\n            doclets[doclet].longname += '(' + variations[doclet] + ')';\n            doclets[doclet].variation = variations[doclet];\n        });\n\n        // update the old doclet in the lookup table\n        functionDoclets[oldDocletLongname] = null;\n        functionDoclets[doclets.oldDoclet.longname] = doclets.oldDoclet;\n    }\n\n    // always store the new doclet in the lookup table\n    functionDoclets[doclets.newDoclet.longname] = doclets.newDoclet;\n\n    return doclets.newDoclet;\n}\n\nexports.handlers = {\n    parseBegin: function() {\n        functionDoclets = {};\n    },\n\n    newDoclet: function(e) {\n        if (e.doclet.kind === 'function') {\n            e.doclet = ensureUniqueLongname(e.doclet);\n        }\n    },\n\n    parseComplete: function() {\n        functionDoclets = null;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/plugins/partial.js":"/**\n    @overview Adds support for reusable partial jsdoc files.\n    @module plugins/partial\n    @author Ludo Antonov <ludo@hulu.com>\n */\n'use strict';\n\nvar env = require('jsdoc/env');\nvar fs = require('jsdoc/fs');\nvar path = require('path');\n\nexports.handlers = {\n    /**\n     * Include a partial jsdoc\n     *\n     * @param e\n     * @param e.filename\n     * @param e.source\n     * @example\n     *     @partial \"partial_doc.jsdoc\"\n     */\n    beforeParse: function(e) {\n        e.source = e.source.replace(/(@partial \\\".*\\\")+/g, function($) {\n            var pathArg = $.match(/\\\".*\\\"/)[0].replace(/\"/g, '');\n            var fullPath = path.join(e.filename, '..', pathArg);\n\n            var partialData = fs.readFileSync(fullPath, env.opts.encoding);\n\n            return partialData;\n        });\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/plugins/railsTemplate.js":"/**\n    @overview Strips the rails template tags from a js.erb file\n    @module plugins/railsTemplate\n    @author Jannon Frank <jannon@jannon.net>\n */\n'use strict';\n\nexports.handlers = {\n    /**\n     * Remove rails tags from the source input (e.g. <% foo bar %>)\n     * @param e\n     * @param e.filename\n     * @param e.source\n     */\n    beforeParse: function(e) {\n        if (e.filename.match(/\\.erb$/)) {\n            e.source = e.source.replace(/<%.*%>/g, '');\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/plugins/shout.js":"/**\n    @overview This is just an example.\n    @module plugins/shout\n    @author Michael Mathews <micmath@gmail.com>\n */\n'use strict';\n\nexports.handlers = {\n    /**\n        Make your descriptions more shoutier.\n     */\n    newDoclet: function(e) {\n        if (typeof e.doclet.description === 'string') {\n            e.doclet.description = e.doclet.description.toUpperCase();\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/plugins/sourcetag.js":"/**\n    @module plugins/sourcetag\n    @author Michael Mathews <micmath@gmail.com>\n */\n'use strict';\n\nvar logger = require('jsdoc/util/logger');\n\nexports.handlers = {\n    /**\n        Support @source tag. Expected value like:\n            { \"filename\": \"myfile.js\", \"lineno\": 123 }\n        Modifies the corresponding meta values on the given doclet.\n\n        WARNING: If you are using a JSDoc template that generates pretty-printed source files,\n        such as JSDoc's default template, this plugin can cause JSDoc to crash. To fix this issue,\n        update your template settings to disable pretty-printed source files.\n\n        @source { \"filename\": \"sourcetag.js\", \"lineno\": 13 }\n     */\n    newDoclet: function(e) {\n        var tags = e.doclet.tags,\n            tag,\n            value;\n\n        // any user-defined tags in this doclet?\n        if (typeof tags !== 'undefined') {\n            // only interested in the @source tags\n            tags = tags.filter(function($) {\n                return $.title === 'source';\n            });\n\n            if (tags.length) {\n                // take the first one\n                tag = tags[0];\n\n                try {\n                    value = JSON.parse(tag.value);\n                }\n                catch (ex) {\n                    logger.error('@source tag expects a valid JSON value, like { \"filename\": \"myfile.js\", \"lineno\": 123 }.');\n                    return;\n                }\n\n                e.doclet.meta = e.doclet.meta || {};\n                e.doclet.meta.filename = value.filename || '';\n                e.doclet.meta.lineno = value.lineno || '';\n            }\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/plugins/summarize.js":"/**\n * @overview This plugin creates a summary tag, if missing, from the first sentence in the\n * description.\n * @module plugins/summarize\n * @author Mads Bondo Dydensborg <mbd@dbc.dk>\n */\n'use strict';\n\nexports.handlers = {\n    /**\n     * Autogenerate summaries, if missing, from the description, if present.\n     */\n    newDoclet: function(e) {\n        var endTag;\n        var tags;\n        var stack;\n\n        // If the summary is missing, grab the first sentence from the description\n        // and use that.\n        if (e.doclet && !e.doclet.summary && e.doclet.description) {\n            // The summary may end with `.$`, `. `, or `.<` (a period followed by an HTML tag).\n            e.doclet.summary = e.doclet.description.split(/\\.$|\\.\\s|\\.</)[0];\n            // Append `.` as it was removed in both cases, or is possibly missing.\n            e.doclet.summary += '.';\n\n            // This is an excerpt of something that is possibly HTML.\n            // Balance it using a stack. Assume it was initially balanced.\n            tags = e.doclet.summary.match(/<[^>]+>/g) || [];\n            stack = [];\n\n            tags.forEach(function(tag) {\n                var idx = tag.indexOf('/');\n\n                if (idx === -1) {\n                    // start tag -- push onto the stack\n                    stack.push(tag);\n                } else if (idx === 1) {\n                    // end tag -- pop off of the stack\n                    stack.pop();\n                }\n\n                // otherwise, it's a self-closing tag; don't modify the stack\n            });\n\n            // stack should now contain only the start tags that lack end tags,\n            // with the most deeply nested start tag at the top\n            while (stack.length > 0) {\n                // pop the unmatched tag off the stack\n                endTag = stack.pop();\n                // get just the tag name\n                endTag = endTag.substring(1, endTag.search(/[ >]/));\n                // append the end tag\n                e.doclet.summary += '</' + endTag + '>';\n            }\n\n            // and, finally, if the summary starts and ends with a <p> tag, remove it; let the\n            // template decide whether to wrap the summary in a <p> tag\n            e.doclet.summary = e.doclet.summary.replace(/^<p>(.*)<\\/p>$/i, '$1');\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/plugins/underscore.js":"'use strict';\n\n/**\n * Removes all symbols that begin with an underscore from the doc output. If\n * you're using underscores to denote private variables in modules, this\n * automatically hides them.\n *\n * @module plugins/underscore\n * @author Daniel Ellis <coug36@gmail.com>\n */\n\nexports.handlers = {\n    newDoclet: function(e) {\n        var doclet = e.doclet;\n\n        // Ignore comment blocks for all symbols that begin with underscore\n        if (doclet.name.charAt(0) === '_' || doclet.name.substr(0, 6) === 'this._') {\n            doclet.access = 'private';\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/augment.js":"'use strict';\n\n/**\n * Provides methods for augmenting the parse results based on their content.\n * @module jsdoc/augment\n */\n\nvar doop = require('jsdoc/util/doop');\nvar name = require('jsdoc/name');\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\nfunction mapDependencies(index, propertyName) {\n    var dependencies = {};\n    var doc;\n    var doclets;\n    var kinds = ['class', 'external', 'interface', 'mixin'];\n    var len = 0;\n\n    Object.keys(index).forEach(function(indexName) {\n        doclets = index[indexName];\n        for (var i = 0, ii = doclets.length; i < ii; i++) {\n            doc = doclets[i];\n            if (kinds.indexOf(doc.kind) !== -1) {\n                dependencies[indexName] = {};\n                if (hasOwnProp.call(doc, propertyName)) {\n                    len = doc[propertyName].length;\n                    for (var j = 0; j < len; j++) {\n                        dependencies[indexName][doc[propertyName][j]] = true;\n                    }\n                }\n            }\n        }\n    });\n\n    return dependencies;\n}\n\nfunction Sorter(dependencies) {\n    this.dependencies = dependencies;\n    this.visited = {};\n    this.sorted = [];\n}\n\nSorter.prototype.visit = function(key) {\n    var self = this;\n\n    if (!(key in this.visited)) {\n        this.visited[key] = true;\n\n        if (this.dependencies[key]) {\n            Object.keys(this.dependencies[key]).forEach(function(path) {\n                self.visit(path);\n            });\n        }\n\n        this.sorted.push(key);\n    }\n};\n\nSorter.prototype.sort = function() {\n    var self = this;\n\n    Object.keys(this.dependencies).forEach(function(key) {\n        self.visit(key);\n    });\n\n    return this.sorted;\n};\n\nfunction sort(dependencies) {\n    var sorter = new Sorter(dependencies);\n    return sorter.sort();\n}\n\nfunction getMembers(longname, docs, scopes) {\n    var candidate;\n    var members = [];\n\n    for (var i = 0, l = docs.length; i < l; i++) {\n        candidate = docs[i];\n\n        if (candidate.memberof === longname && scopes.indexOf(candidate.scope) !== -1) {\n            members.push(candidate);\n        }\n    }\n\n    return members;\n}\n\nfunction addDocletProperty(doclets, propName, value) {\n    for (var i = 0, l = doclets.length; i < l; i++) {\n        doclets[i][propName] = value;\n    }\n}\n\nfunction reparentDoclet(parent, child) {\n    var parts = name.shorten(child.longname);\n\n    parts.memberof = parent.longname;\n    child.memberof = parent.longname;\n    child.longname = name.combine(parts);\n}\n\nfunction parentIsClass(parent) {\n    return parent.kind === 'class';\n}\n\nfunction staticToInstance(doclet) {\n    var parts = name.shorten(doclet.longname);\n\n    parts.scope = name.SCOPE.PUNC.INSTANCE;\n    doclet.longname = name.combine(parts);\n    doclet.scope = name.SCOPE.NAMES.INSTANCE;\n}\n\n/**\n * Update the list of doclets to be added to another symbol.\n *\n * We add only one doclet per longname. For example: If `ClassA` inherits from two classes that both\n * use the same method name, `ClassA` gets docs for one method rather than two.\n *\n * Also, the last symbol wins for any given longname. For example: If you write `@extends Class1\n * @extends Class2`, and both classes have an instance method called `myMethod`, you get the docs\n * from `Class2#myMethod`.\n *\n * @private\n * @param {module:jsdoc/doclet.Doclet} doclet - The doclet to be added.\n * @param {Array.<module:jsdoc/doclet.Doclet>} additions - An array of doclets that will be added to\n * another symbol.\n * @param {Object.<string, number>} indexes - A dictionary of indexes into the `additions` array.\n * Each key is a longname, and each value is the index of the longname's doclet.\n * @return {void}\n */\nfunction updateAddedDoclets(doclet, additions, indexes) {\n    if (typeof indexes[doclet.longname] !== 'undefined') {\n        // replace the existing doclet\n        additions[indexes[doclet.longname]] = doclet;\n    }\n    else {\n        // add the doclet to the array, and track its index\n        additions.push(doclet);\n        indexes[doclet.longname] = additions.length - 1;\n    }\n}\n\n/**\n * Update the index of doclets whose `undocumented` property is not `true`.\n *\n * @private\n * @param {module:jsdoc/doclet.Doclet} doclet - The doclet to be added to the index.\n * @param {Object.<string, Array.<module:jsdoc/doclet.Doclet>>} documented - The index of doclets\n * whose `undocumented` property is not `true`.\n * @return {void}\n */\nfunction updateDocumentedDoclets(doclet, documented) {\n    if ( !hasOwnProp.call(documented, doclet.longname) ) {\n        documented[doclet.longname] = [];\n    }\n\n    documented[doclet.longname].push(doclet);\n}\n\nfunction explicitlyInherits(doclets) {\n    var doclet;\n    var inherits = false;\n\n    for (var i = 0, l = doclets.length; i < l; i++) {\n        doclet = doclets[i];\n        if (typeof doclet.inheritdoc !== 'undefined' || typeof doclet.override !== 'undefined') {\n            inherits = true;\n            break;\n        }\n    }\n\n    return inherits;\n}\n\n// TODO: try to reduce overlap with similar methods\nfunction getInheritedAdditions(doclets, docs, documented) {\n    var additionIndexes;\n    var additions = [];\n    var doc;\n    var parents;\n    var members;\n    var member;\n    var parts;\n\n    // doclets will be undefined if the inherited symbol isn't documented\n    doclets = doclets || [];\n\n    for (var i = 0, ii = doclets.length; i < ii; i++) {\n        doc = doclets[i];\n        parents = doc.augments;\n\n        if ( parents && (doc.kind === 'class' || doc.kind === 'interface') ) {\n            // reset the lookup table of added doclet indexes by longname\n            additionIndexes = {};\n\n            for (var j = 0, jj = parents.length; j < jj; j++) {\n                members = getMembers(parents[j], docs, ['instance']);\n\n                for (var k = 0, kk = members.length; k < kk; k++) {\n                    // We only care about symbols that are documented.\n                    if (members[k].undocumented) {\n                        continue;\n                    }\n\n                    member = doop(members[k]);\n\n                    if (!member.inherited) {\n                        member.inherits = member.longname;\n                    }\n                    member.inherited = true;\n\n                    // TODO: this will fail on longnames like: MyClass#\"quoted#Longname\"\n                    // and nested instance members like: MyClass#MyOtherClass#myMethod;\n                    // switch to updateLongname()!\n                    member.memberof = doc.longname;\n                    parts = member.longname.split('#');\n                    parts[0] = doc.longname;\n                    member.longname = parts.join('#');\n\n                    // Indicate what the descendant is overriding. (We only care about the closest\n                    // ancestor. For classes A > B > C, if B#a overrides A#a, and C#a inherits B#a,\n                    // we don't want the doclet for C#a to say that it overrides A#a.)\n                    if ( hasOwnProp.call(docs.index.longname, member.longname) ) {\n                        member.overrides = members[k].longname;\n                    }\n                    else {\n                        delete member.overrides;\n                    }\n\n                    // Add the ancestor's docs unless the descendant overrides the ancestor AND\n                    // documents the override.\n                    if ( !hasOwnProp.call(documented, member.longname) ) {\n                        updateAddedDoclets(member, additions, additionIndexes);\n                        updateDocumentedDoclets(member, documented);\n                    }\n                    // If the descendant used an @inheritdoc or @override tag, add the ancestor's\n                    // docs, and ignore the existing doclets.\n                    else if ( explicitlyInherits(documented[member.longname]) ) {\n                        // Ignore any existing doclets. (This is safe because we only get here if\n                        // `member.longname` is an own property of `documented`.)\n                        addDocletProperty(documented[member.longname], 'ignore', true);\n\n                        updateAddedDoclets(member, additions, additionIndexes);\n                        updateDocumentedDoclets(member, documented);\n\n                        // Remove property that's no longer accurate.\n                        if (member.virtual) {\n                            delete member.virtual;\n                        }\n                        // Remove properties that we no longer need.\n                        if (member.inheritdoc) {\n                            delete member.inheritdoc;\n                        }\n                        if (member.override) {\n                            delete member.override;\n                        }\n                    }\n                    // If the descendant overrides the ancestor and documents the override,\n                    // update the doclets to indicate what the descendant is overriding.\n                    else {\n                        addDocletProperty(documented[member.longname], 'overrides',\n                            members[k].longname);\n                    }\n                }\n            }\n        }\n    }\n\n    return additions;\n}\n\nfunction updateMixes(mixedDoclet, mixedLongname) {\n    var idx;\n    var mixedName;\n    var names;\n\n    // take the fast path if there's no array of mixed-in longnames\n    if (!mixedDoclet.mixes) {\n        mixedDoclet.mixes = [mixedLongname];\n    }\n    else {\n        // find the short name of the longname we're mixing in\n        mixedName = name.shorten(mixedLongname).name;\n        // find the short name of each previously mixed-in symbol\n        names = mixedDoclet.mixes.map(function(m) {\n            return name.shorten(mixedDoclet.longname).name;\n        });\n\n        // if we're mixing `myMethod` into `MixinC` from `MixinB`, and `MixinB` had the method mixed\n        // in from `MixinA`, don't show `MixinA.myMethod` in the `mixes` list\n        idx = names.indexOf(mixedName);\n        if (idx !== -1) {\n            mixedDoclet.mixes.splice(idx, 1);\n        }\n\n        mixedDoclet.mixes.push(mixedLongname);\n    }\n}\n\n// TODO: try to reduce overlap with similar methods\nfunction getMixedInAdditions(mixinDoclets, allDoclets, commentedDoclets) {\n    var additionIndexes;\n    var additions = [];\n    var doclet;\n    var idx;\n    var mixedDoclet;\n    var mixedDoclets;\n    var mixes;\n\n    // mixinDoclets will be undefined if the mixed-in symbol isn't documented\n    mixinDoclets = mixinDoclets || [];\n\n    for (var i = 0, ii = mixinDoclets.length; i < ii; i++) {\n        doclet = mixinDoclets[i];\n        mixes = doclet.mixes;\n\n        if (mixes) {\n            // reset the lookup table of added doclet indexes by longname\n            additionIndexes = {};\n\n            for (var j = 0, jj = mixes.length; j < jj; j++) {\n                mixedDoclets = getMembers(mixes[j], allDoclets, ['static']);\n\n                for (var k = 0, kk = mixedDoclets.length; k < kk; k++) {\n                    // We only care about symbols that are documented.\n                    if (mixedDoclets[k].undocumented) {\n                        continue;\n                    }\n\n                    mixedDoclet = doop(mixedDoclets[k]);\n\n                    updateMixes(mixedDoclet, mixedDoclet.longname);\n                    mixedDoclet.mixed = true;\n\n                    reparentDoclet(doclet, mixedDoclet);\n\n                    // if we're mixing into a class, treat the mixed-in symbol as an instance member\n                    if (parentIsClass(doclet)) {\n                        staticToInstance(mixedDoclet);\n                    }\n\n                    updateAddedDoclets(mixedDoclet, additions, additionIndexes);\n                    updateDocumentedDoclets(mixedDoclet, commentedDoclets);\n                }\n            }\n        }\n    }\n\n    return additions;\n}\n\nfunction updateImplements(implDoclets, implementedLongname) {\n    if ( !Array.isArray(implDoclets) ) {\n        implDoclets = [implDoclets];\n    }\n\n    implDoclets.forEach(function(implDoclet) {\n        if ( !hasOwnProp.call(implDoclet, 'implements') ) {\n            implDoclet.implements = [];\n        }\n\n        if (implDoclet.implements.indexOf(implementedLongname) === -1) {\n            implDoclet.implements.push(implementedLongname);\n        }\n    });\n}\n\n// TODO: try to reduce overlap with similar methods\nfunction getImplementedAdditions(implDoclets, allDoclets, commentedDoclets) {\n    var additionIndexes;\n    var additions = [];\n    var doclet;\n    var idx;\n    var implementations;\n    var implExists;\n    var implementationDoclet;\n    var interfaceDoclets;\n\n    // interfaceDoclets will be undefined if the implemented symbol isn't documented\n    implDoclets = implDoclets || [];\n\n    for (var i = 0, ii = implDoclets.length; i < ii; i++) {\n        doclet = implDoclets[i];\n        implementations = doclet.implements;\n\n        if (implementations) {\n            // reset the lookup table of added doclet indexes by longname\n            additionIndexes = {};\n\n            for (var j = 0, jj = implementations.length; j < jj; j++) {\n                interfaceDoclets = getMembers(implementations[j], allDoclets, ['instance']);\n\n                for (var k = 0, kk = interfaceDoclets.length; k < kk; k++) {\n                    // We only care about symbols that are documented.\n                    if (interfaceDoclets[k].undocumented) {\n                        continue;\n                    }\n\n                    implementationDoclet = doop(interfaceDoclets[k]);\n\n                    reparentDoclet(doclet, implementationDoclet);\n                    updateImplements(implementationDoclet, interfaceDoclets[k].longname);\n\n                    // If there's no implementation, move along.\n                    implExists = hasOwnProp.call(allDoclets.index.longname,\n                        implementationDoclet.longname);\n                    if (!implExists) {\n                        continue;\n                    }\n\n                    // Add the interface's docs unless the implementation is already documented.\n                    if ( !hasOwnProp.call(commentedDoclets, implementationDoclet.longname) ) {\n                        updateAddedDoclets(implementationDoclet, additions, additionIndexes);\n                        updateDocumentedDoclets(implementationDoclet, commentedDoclets);\n                    }\n                    // If the implementation used an @inheritdoc or @override tag, add the\n                    // interface's docs, and ignore the existing doclets.\n                    else if ( explicitlyInherits(commentedDoclets[implementationDoclet.longname]) ) {\n                        // Ignore any existing doclets. (This is safe because we only get here if\n                        // `implementationDoclet.longname` is an own property of\n                        // `commentedDoclets`.)\n                        addDocletProperty(commentedDoclets[implementationDoclet.longname], 'ignore',\n                            true);\n\n                        updateAddedDoclets(implementationDoclet, additions, additionIndexes);\n                        updateDocumentedDoclets(implementationDoclet, commentedDoclets);\n\n                        // Remove property that's no longer accurate.\n                        if (implementationDoclet.virtual) {\n                            delete implementationDoclet.virtual;\n                        }\n                        // Remove properties that we no longer need.\n                        if (implementationDoclet.inheritdoc) {\n                            delete implementationDoclet.inheritdoc;\n                        }\n                        if (implementationDoclet.override) {\n                            delete implementationDoclet.override;\n                        }\n                    }\n                    // If there's an implementation, and it's documented, update the doclets to\n                    // indicate what the implementation is implementing.\n                    else {\n                        updateImplements(commentedDoclets[implementationDoclet.longname],\n                            interfaceDoclets[k].longname);\n                    }\n                }\n            }\n        }\n    }\n\n    return additions;\n}\n\nfunction augment(doclets, propertyName, docletFinder) {\n    var index = doclets.index.longname;\n    var dependencies = sort( mapDependencies(index, propertyName) );\n\n    dependencies.forEach(function(depName) {\n        var additions = docletFinder(index[depName], doclets, doclets.index.documented);\n\n        additions.forEach(function(addition) {\n            var longname = addition.longname;\n\n            if ( !hasOwnProp.call(index, longname) ) {\n                index[longname] = [];\n            }\n            index[longname].push(addition);\n            doclets.push(addition);\n        });\n    });\n}\n\n/**\n * Add doclets to reflect class inheritance.\n *\n * For example, if `ClassA` has the instance method `myMethod`, and `ClassB` inherits from `ClassA`,\n * calling this method creates a new doclet for `ClassB#myMethod`.\n *\n * @param {!Array.<module:jsdoc/doclet.Doclet>} doclets - The doclets generated by JSDoc.\n * @param {!Object} doclets.index - The doclet index added by {@link module:jsdoc/borrow.indexAll}.\n * @return {void}\n */\nexports.addInherited = function(doclets) {\n    augment(doclets, 'augments', getInheritedAdditions);\n};\n\n/**\n * Add doclets to reflect mixins. When a symbol is mixed into a class, the class' version of the\n * mixed-in symbol is treated as an instance member.\n *\n * For example:\n *\n * + If `MixinA` has the static method `myMethod`, and `MixinB` mixes `MixinA`, calling this method\n * creates a new doclet for the static method `MixinB.myMethod`.\n * + If `MixinA` has the static method `myMethod`, and `ClassA` mixes `MixinA`, calling this method\n * creates a new doclet for the instance method `ClassA#myMethod`.\n *\n * @param {!Array.<module:jsdoc/doclet.Doclet>} doclets - The doclets generated by JSDoc.\n * @param {!Object} doclets.index - The doclet index added by {@link module:jsdoc/borrow.indexAll}.\n * @return {void}\n */\nexports.addMixedIn = function(doclets) {\n    augment(doclets, 'mixes', getMixedInAdditions);\n};\n\n/**\n * Add and update doclets to reflect implementations of interfaces.\n *\n * For example, if `InterfaceA` has the instance method `myMethod`, and `ClassA` implements\n * `InterfaceA`, calling this method does the following:\n *\n * + Updates `InterfaceA` to indicate that it is implemented by `ClassA`\n * + Updates `InterfaceA#myMethod` to indicate that it is implemented by `ClassA#myMethod`\n * + Updates `ClassA#myMethod` to indicate that it implements `InterfaceA#myMethod`\n *\n * If `ClassA#myMethod` used the `@override` or `@inheritdoc` tag, calling this method would also\n * generate a new doclet that reflects the interface's documentation for `InterfaceA#myMethod`.\n *\n * @param {!Array.<module:jsdoc/doclet.Doclet>} docs - The doclets generated by JSDoc.\n * @param {!Object} doclets.index - The doclet index added by {@link module:jsdoc/borrow.indexAll}.\n * @return {void}\n */\nexports.addImplemented = function(doclets) {\n    augment(doclets, 'implements', getImplementedAdditions);\n};\n\n/**\n * Add and update doclets to reflect all of the following:\n *\n * + Inherited classes\n * + Mixins\n * + Interface implementations\n *\n * Calling this method is equivalent to calling all other methods exported by this module.\n *\n * @return {void}\n */\nexports.augmentAll = function(doclets) {\n    exports.addMixedIn(doclets);\n    exports.addImplemented(doclets);\n    exports.addInherited(doclets);\n    // look for implemented doclets again, in case we inherited an interface\n    exports.addImplemented(doclets);\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/borrow.js":"/**\n    A collection of functions relating to resolving @borrows tags in JSDoc symbols.\n    @module jsdoc/borrow\n    @author Michael Mathews <micmath@gmail.com>\n    @license Apache License 2.0 - See file 'LICENSE.md' in this project.\n */\n'use strict';\n\nvar doop = require('jsdoc/util/doop');\nvar logger = require('jsdoc/util/logger');\nvar SCOPE = require('jsdoc/name').SCOPE;\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\n// TODO: add the index at parse time, so we don't have to iterate over all the doclets again\nexports.indexAll = function(doclets) {\n    var borrowed = [];\n    var doclet;\n    var documented = {};\n    var longname = {};\n\n    for (var i = 0, l = doclets.length; i < l; i++) {\n        doclet = doclets[i];\n\n        // track all doclets by longname\n        if ( !hasOwnProp.call(longname, doclet.longname) ) {\n            longname[doclet.longname] = [];\n        }\n        longname[doclet.longname].push(doclet);\n\n        // track longnames of documented symbols\n        if (!doclet.undocumented) {\n            if ( !hasOwnProp.call(documented, doclet.longname) ) {\n                documented[doclet.longname] = [];\n            }\n            documented[doclet.longname].push(doclet);\n        }\n\n        // track doclets with a `borrowed` property\n        if ( hasOwnProp.call(doclet, 'borrowed') ) {\n            borrowed.push(doclet);\n        }\n    }\n\n    doclets.index = {\n        borrowed: borrowed,\n        documented: documented,\n        longname: longname\n    };\n};\n\nfunction cloneBorrowedDoclets(doclet, doclets) {\n    doclet.borrowed.forEach(function(borrowed) {\n        var borrowedDoclets = doclets.index.longname[borrowed.from];\n        var borrowedAs = borrowed.as || borrowed.from;\n        var clonedDoclets;\n        var parts;\n        var scopePunc;\n\n        if (borrowedDoclets) {\n            borrowedAs = borrowedAs.replace(/^prototype\\./, SCOPE.PUNC.INSTANCE);\n            clonedDoclets = doop(borrowedDoclets).forEach(function(clone) {\n                // TODO: this will fail on longnames like '\"Foo#bar\".baz'\n                parts = borrowedAs.split(SCOPE.PUNC.INSTANCE);\n\n                if (parts.length === 2) {\n                    clone.scope = SCOPE.NAMES.INSTANCE;\n                    scopePunc = SCOPE.PUNC.INSTANCE;\n                }\n                else {\n                    clone.scope = SCOPE.NAMES.STATIC;\n                    scopePunc = SCOPE.PUNC.STATIC;\n                }\n\n                clone.name = parts.pop();\n                clone.memberof = doclet.longname;\n                clone.longname = clone.memberof + scopePunc + clone.name;\n                doclets.push(clone);\n            });\n        }\n    });\n}\n\n// requires docs to have been indexed: docs.index must be defined here\n/**\n    Take a copy of the docs for borrowed symbols and attach them to the\n    docs for the borrowing symbol. This process changes the symbols involved,\n    moving docs from the \"borrowed\" array and into the general docs, then\n    deleting the \"borrowed\" array.\n */\nexports.resolveBorrows = function(doclets) {\n    var doclet;\n\n    if (!doclets.index) {\n        logger.error('Unable to resolve borrowed symbols, because the docs have not been indexed.');\n        return;\n    }\n\n    for (var i = 0, l = doclets.index.borrowed.length; i < l; i++) {\n        doclet = doclets.index.borrowed[i];\n\n        cloneBorrowedDoclets(doclet, doclets);\n        delete doclet.borrowed;\n    }\n\n    doclets.index.borrowed = [];\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/doclet.js":"/**\n * @overview\n * @author Michael Mathews <micmath@gmail.com>\n * @license Apache License 2.0 - See file 'LICENSE.md' in this project.\n */\n\n/**\n * @module jsdoc/doclet\n */\n'use strict';\n\nvar _ = require('underscore');\nvar jsdoc = {\n    env: require('jsdoc/env'),\n    name: require('jsdoc/name'),\n    src: {\n        astnode: require('jsdoc/src/astnode'),\n        Syntax: require('jsdoc/src/syntax').Syntax\n    },\n    tag: {\n        Tag: require('jsdoc/tag').Tag,\n        dictionary: require('jsdoc/tag/dictionary')\n    }\n};\nvar path = require('jsdoc/path');\nvar Syntax = jsdoc.src.Syntax;\nvar util = require('util');\n\nfunction applyTag(doclet, tag) {\n    if (tag.title === 'name') {\n        doclet.name = tag.value;\n    }\n\n    if (tag.title === 'kind') {\n        doclet.kind = tag.value;\n    }\n\n    if (tag.title === 'description') {\n        doclet.description = tag.value;\n    }\n}\n\nfunction fakeMeta(node) {\n    return {\n        type: node ? node.type : null,\n        node: node\n    };\n}\n\n// use the meta info about the source code to guess what the doclet kind should be\n// TODO: set this elsewhere (maybe jsdoc/src/astnode.getInfo)\nfunction codeToKind(code) {\n    var isFunction = jsdoc.src.astnode.isFunction;\n    var kind = 'member';\n    var node = code.node;\n\n    if ( isFunction(code.type) && code.type !== Syntax.MethodDefinition ) {\n        kind = 'function';\n    }\n    else if (code.type === Syntax.MethodDefinition) {\n        if (code.node.kind === 'constructor') {\n            kind = 'class';\n        }\n        else if (code.node.kind !== 'get' && code.node.kind !== 'set') {\n            kind = 'function';\n        }\n    }\n    else if (code.type === Syntax.ClassDeclaration || code.type === Syntax.ClassExpression) {\n        kind = 'class';\n    }\n    else if (code.type === Syntax.ExportAllDeclaration) {\n        // this value will often be an Identifier for a variable, which isn't very useful\n        kind = codeToKind(fakeMeta(node.source));\n    }\n    else if (code.type === Syntax.ExportDefaultDeclaration ||\n        code.type === Syntax.ExportNamedDeclaration) {\n        kind = codeToKind(fakeMeta(node.declaration));\n    }\n    else if (code.type === Syntax.ExportSpecifier) {\n        // this value will often be an Identifier for a variable, which isn't very useful\n        kind = codeToKind(fakeMeta(node.local));\n    }\n    else if ( code.node && code.node.parent && isFunction(code.node.parent) ) {\n        kind = 'param';\n    }\n\n    return kind;\n}\n\nfunction unwrap(docletSrc) {\n    if (!docletSrc) { return ''; }\n\n    // note: keep trailing whitespace for @examples\n    // extra opening/closing stars are ignored\n    // left margin is considered a star and a space\n    // use the /m flag on regex to avoid having to guess what this platform's newline is\n    docletSrc =\n        docletSrc.replace(/^\\/\\*\\*+/, '') // remove opening slash+stars\n        .replace(/\\**\\*\\/$/, '\\\\Z')       // replace closing star slash with end-marker\n        .replace(/^\\s*(\\* ?|\\\\Z)/gm, '')  // remove left margin like: spaces+star or spaces+end-marker\n        .replace(/\\s*\\\\Z$/g, '');         // remove end-marker\n\n    return docletSrc;\n}\n\n/**\n * Convert the raw source of the doclet comment into an array of pseudo-Tag objects.\n * @private\n */\nfunction toTags(docletSrc) {\n    var parsedTag;\n    var tagData = [];\n    var tagText;\n    var tagTitle;\n\n    // split out the basic tags, keep surrounding whitespace\n    // like: @tagTitle tagBody\n    docletSrc\n        // replace splitter ats with an arbitrary sequence\n        .replace(/^(\\s*)@(\\S)/gm, '$1\\\\@$2')\n        // then split on that arbitrary sequence\n        .split('\\\\@')\n        .forEach(function($) {\n            if ($) {\n                parsedTag = $.match(/^(\\S+)(?:\\s+(\\S[\\s\\S]*))?/);\n\n                if (parsedTag) {\n                    tagTitle = parsedTag[1];\n                    tagText = parsedTag[2];\n\n                    if (tagTitle) {\n                        tagData.push({\n                            title: tagTitle,\n                            text: tagText\n                        });\n                    }\n                }\n            }\n    });\n\n    return tagData;\n}\n\nfunction fixDescription(docletSrc, meta) {\n    var isClass;\n\n    if (!/^\\s*@/.test(docletSrc) && docletSrc.replace(/\\s/g, '').length) {\n        isClass = meta.code &&\n            (meta.code.type === Syntax.ClassDeclaration ||\n            meta.code.type === Syntax.ClassExpression);\n\n        docletSrc = (isClass ? '@classdesc' : '@description') + ' ' + docletSrc;\n    }\n    return docletSrc;\n}\n\n/**\n * Replace the existing tag dictionary with a new tag dictionary.\n *\n * Used for testing only.\n *\n * @private\n * @param {module:jsdoc/tag/dictionary.Dictionary} dict - The new tag dictionary.\n */\nexports._replaceDictionary = function _replaceDictionary(dict) {\n    jsdoc.tag.dictionary = dict;\n    require('jsdoc/tag')._replaceDictionary(dict);\n    require('jsdoc/util/templateHelper')._replaceDictionary(dict);\n};\n\n/**\n * @class\n * @classdesc Represents a single JSDoc comment.\n * @alias module:jsdoc/doclet.Doclet\n *\n * @param {string} docletSrc - The raw source code of the jsdoc comment.\n * @param {object=} meta - Properties describing the code related to this comment.\n */\nvar Doclet = exports.Doclet = function(docletSrc, meta) {\n    var newTags = [];\n\n    /** The original text of the comment from the source code. */\n    this.comment = docletSrc;\n    this.setMeta(meta);\n\n    docletSrc = unwrap(docletSrc);\n    docletSrc = fixDescription(docletSrc, meta);\n\n    newTags = toTags.call(this, docletSrc);\n\n    for (var i = 0, l = newTags.length; i < l; i++) {\n        this.addTag(newTags[i].title, newTags[i].text);\n    }\n\n    this.postProcess();\n};\n\n/** Called once after all tags have been added. */\nDoclet.prototype.postProcess = function() {\n    var i;\n    var l;\n\n    if (!this.preserveName) {\n        jsdoc.name.resolve(this);\n    }\n    if (this.name && !this.longname) {\n        this.setLongname(this.name);\n    }\n    if (this.memberof === '') {\n        delete this.memberof;\n    }\n\n    if (!this.kind && this.meta && this.meta.code) {\n        this.addTag( 'kind', codeToKind(this.meta.code) );\n    }\n\n    if (this.variation && this.longname && !/\\)$/.test(this.longname) ) {\n        this.longname += '(' + this.variation + ')';\n    }\n\n    // add in any missing param names\n    if (this.params && this.meta && this.meta.code && this.meta.code.paramnames) {\n        for (i = 0, l = this.params.length; i < l; i++) {\n            if (!this.params[i].name) {\n                this.params[i].name = this.meta.code.paramnames[i] || '';\n            }\n        }\n    }\n};\n\n/**\n * Add a tag to the doclet.\n *\n * @param {string} title - The title of the tag being added.\n * @param {string} [text] - The text of the tag being added.\n */\nDoclet.prototype.addTag = function(title, text) {\n    var tagDef = jsdoc.tag.dictionary.lookUp(title),\n        newTag = new jsdoc.tag.Tag(title, text, this.meta);\n\n    if (tagDef && tagDef.onTagged) {\n       tagDef.onTagged(this, newTag);\n    }\n\n    if (!tagDef) {\n        this.tags = this.tags || [];\n        this.tags.push(newTag);\n    }\n\n    applyTag(this, newTag);\n};\n\nfunction removeGlobal(longname) {\n    var globalRegexp = new RegExp('^' + jsdoc.name.LONGNAMES.GLOBAL + '\\\\.?');\n\n    return longname.replace(globalRegexp, '');\n}\n\n/**\n * Set the doclet's `memberof` property.\n *\n * @param {string} sid - The longname of the doclet's parent symbol.\n */\nDoclet.prototype.setMemberof = function(sid) {\n    /**\n     * The longname of the symbol that contains this one, if any.\n     * @type {string}\n     */\n    this.memberof = removeGlobal(sid)\n        .replace(/\\.prototype/g, jsdoc.name.SCOPE.PUNC.INSTANCE);\n};\n\n/**\n * Set the doclet's `longname` property.\n *\n * @param {string} name - The longname for the doclet.\n */\nDoclet.prototype.setLongname = function(name) {\n    /**\n     * The fully resolved symbol name.\n     * @type {string}\n     */\n    this.longname = removeGlobal(name);\n    if (jsdoc.tag.dictionary.isNamespace(this.kind)) {\n        this.longname = jsdoc.name.applyNamespace(this.longname, this.kind);\n    }\n};\n\n/**\n * Get the full path to the source file that is associated with a doclet.\n *\n * @private\n * @param {module:jsdoc/doclet.Doclet} The doclet to check for a filepath.\n * @return {string} The path to the doclet's source file, or an empty string if the path is not\n * available.\n */\nfunction getFilepath(doclet) {\n    if (!doclet || !doclet.meta || !doclet.meta.filename) {\n        return '';\n    }\n\n    return path.join(doclet.meta.path || '', doclet.meta.filename);\n}\n\n/**\n * Set the doclet's `scope` property. Must correspond to a scope name that is defined in\n * {@link module:jsdoc/name.SCOPE.NAMES}.\n *\n * @param {module:jsdoc/name.SCOPE.NAMES} scope - The scope for the doclet relative to the symbol's\n * parent.\n * @throws {Error} If the scope name is not recognized.\n */\nDoclet.prototype.setScope = function(scope) {\n    var errorMessage;\n    var filepath;\n    var scopeNames = _.values(jsdoc.name.SCOPE.NAMES);\n\n    if (scopeNames.indexOf(scope) === -1) {\n        filepath = getFilepath(this);\n\n        errorMessage = util.format('The scope name \"%s\" is not recognized. Use one of the ' +\n            'following values: %j', scope, scopeNames);\n        if (filepath) {\n            errorMessage += util.format(' (Source file: %s)', filepath);\n        }\n\n        throw new Error(errorMessage);\n    }\n\n    this.scope = scope;\n};\n\n/**\n * Add a symbol to this doclet's `borrowed` array.\n *\n * @param {string} source - The longname of the symbol that is the source.\n * @param {string} target - The name the symbol is being assigned to.\n */\nDoclet.prototype.borrow = function(source, target) {\n    var about = { from: source };\n    if (target) {\n        about.as = target;\n    }\n\n    if (!this.borrowed) {\n        /**\n         * A list of symbols that are borrowed by this one, if any.\n         * @type {Array.<string>}\n         */\n        this.borrowed = [];\n    }\n    this.borrowed.push(about);\n};\n\nDoclet.prototype.mix = function(source) {\n    /**\n     * A list of symbols that are mixed into this one, if any.\n     * @type Array.<string>\n     */\n    this.mixes = this.mixes || [];\n    this.mixes.push(source);\n};\n\n/**\n * Add a symbol to the doclet's `augments` array.\n *\n * @param {string} base - The longname of the base symbol.\n */\nDoclet.prototype.augment = function(base) {\n    /**\n     * A list of symbols that are augmented by this one, if any.\n     * @type Array.<string>\n     */\n    this.augments = this.augments || [];\n    this.augments.push(base);\n};\n\n/**\n * Set the `meta` property of this doclet.\n *\n * @param {object} meta\n */\nDoclet.prototype.setMeta = function(meta) {\n    /**\n     * Information about the source code associated with this doclet.\n     * @namespace\n     */\n    this.meta = this.meta || {};\n\n    if (meta.range) {\n        /**\n         * The positions of the first and last characters of the code associated with this doclet.\n         * @type Array.<number>\n         */\n        this.meta.range = meta.range.slice(0);\n    }\n\n    if (meta.lineno) {\n        /**\n         * The name of the file containing the code associated with this doclet.\n         * @type string\n         */\n        this.meta.filename = path.basename(meta.filename);\n        /**\n         * The line number of the code associated with this doclet.\n         * @type number\n         */\n        this.meta.lineno = meta.lineno;\n\n        var pathname = path.dirname(meta.filename);\n        if (pathname && pathname !== '.') {\n            this.meta.path = pathname;\n        }\n    }\n\n    /**\n     * Information about the code symbol.\n     * @namespace\n     */\n    this.meta.code = this.meta.code || {};\n    if (meta.id) { this.meta.code.id = meta.id; }\n    if (meta.code) {\n        if (meta.code.name) {\n            /**\n             * The name of the symbol in the source code.\n             * @type {string}\n             */\n            this.meta.code.name = meta.code.name;\n        }\n        if (meta.code.type) {\n            /**\n             * The type of the symbol in the source code.\n             * @type {string}\n             */\n            this.meta.code.type = meta.code.type;\n        }\n        if (meta.code.node) {\n            Object.defineProperty(this.meta.code, 'node', {\n                value: meta.code.node,\n                enumerable: false\n            });\n        }\n        if (meta.code.funcscope) {\n            this.meta.code.funcscope = meta.code.funcscope;\n        }\n        if (typeof meta.code.value !== 'undefined') {\n            /**\n             * The value of the symbol in the source code.\n             * @type {*}\n             */\n            this.meta.code.value = meta.code.value;\n        }\n        if (meta.code.paramnames) {\n            this.meta.code.paramnames = meta.code.paramnames.slice(0);\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/package.js":"'use strict';\n\nvar logger = require('jsdoc/util/logger');\n\n/**\n * Provides access to information about a JavaScript package.\n *\n * @module jsdoc/package\n * @see https://www.npmjs.org/doc/files/package.json.html\n */\n\n// Collect all of the license information from a `package.json` file.\nfunction getLicenses(packageInfo) {\n    var licenses = packageInfo.licenses ? packageInfo.licenses.slice(0) : [];\n\n    if (packageInfo.license) {\n        licenses.push({ type: packageInfo.license });\n    }\n\n    return licenses;\n}\n\n/**\n * Information about where to report bugs in the package.\n *\n * @typedef {Object} module:jsdoc/package.Package~BugInfo\n * @property {string} email - The email address for reporting bugs.\n * @property {string} url - The URL for reporting bugs.\n */\n\n/**\n * Information about a package's software license.\n *\n * @typedef {Object} module:jsdoc/package.Package~LicenseInfo\n * @property {string} type - An identifier for the type of license.\n * @property {string} url - The URL for the complete text of the license.\n */\n\n/**\n * Information about a package author or contributor.\n *\n * @typedef {Object} module:jsdoc/package.Package~PersonInfo\n * @property {string} name - The person's full name.\n * @property {string} email - The person's email address.\n * @property {string} url - The URL of the person's website.\n */\n\n/**\n * Information about a package's version-control repository.\n *\n * @typedef {Object} module:jsdoc/package.Package~RepositoryInfo\n * @property {string} type - The type of version-control system that the repository uses (for\n * example, `git` or `svn`).\n * @property {string} url - The URL for the repository.\n */\n\n/**\n * Information about a JavaScript package. JSDoc can extract package information from\n * `package.json` files that follow the\n * [npm specification](https://www.npmjs.org/doc/files/package.json.html).\n *\n * **Note**: JSDoc does not validate or normalize the contents of `package.json` files. If your\n * `package.json` file does not follow the npm specification, some properties of the `Package`\n * object may not use the format documented here.\n *\n * @class\n * @param {string} json - The contents of the `package.json` file.\n */\nexports.Package = function(json) {\n    var packageInfo;\n\n    /**\n     * The string identifier that is shared by all `Package` objects.\n     *\n     * @readonly\n     * @default\n     * @type {string}\n     */\n    this.kind = 'package';\n\n    try {\n        packageInfo = JSON.parse(json || '{}');\n    }\n    catch (e) {\n        logger.error('Unable to parse the package file: %s', e.message);\n        packageInfo = {};\n    }\n\n    if (packageInfo.name) {\n        /**\n         * The package name.\n         *\n         * @type {string}\n         */\n        this.name = packageInfo.name;\n    }\n\n    /**\n     * The unique longname for this `Package` object.\n     *\n     * @type {string}\n     */\n    this.longname = this.kind + ':' + this.name;\n\n    if (packageInfo.author) {\n        /**\n         * The author of this package. Contains either a\n         * {@link module:jsdoc/package.Package~PersonInfo PersonInfo} object or a string with\n         * information about the author.\n         *\n         * @type {(module:jsdoc/package.Package~PersonInfo|string)}\n         * @since 3.3.0\n         */\n        this.author = packageInfo.author;\n    }\n\n    if (packageInfo.bugs) {\n        /**\n         * Information about where to report bugs in the project. May contain a URL, a string, or an\n         * object with more detailed information.\n         *\n         * @type {(string|module:jsdoc/package.Package~BugInfo)}\n         * @since 3.3.0\n         */\n        this.bugs = packageInfo.bugs;\n    }\n\n    if (packageInfo.contributors) {\n        /**\n         * The contributors to this package.\n         *\n         * @type {Array.<(module:jsdoc/package.Package~PersonInfo|string)>}\n         * @since 3.3.0\n         */\n        this.contributors = packageInfo.contributors;\n    }\n\n    if (packageInfo.dependencies) {\n        /**\n         * The dependencies for this package.\n         *\n         * @type {Object}\n         * @since 3.3.0\n         */\n        this.dependencies = packageInfo.dependencies;\n    }\n\n    if (packageInfo.description) {\n        /**\n         * A brief description of the package.\n         *\n         * @type {string}\n         */\n        this.description = packageInfo.description;\n    }\n\n    if (packageInfo.devDependencies) {\n        /**\n         * The development dependencies for this package.\n         *\n         * @type {Object}\n         * @since 3.3.0\n         */\n        this.devDependencies = packageInfo.devDependencies;\n    }\n\n    if (packageInfo.engines) {\n        /**\n         * The JavaScript engines that this package supports. Each key is a string that identifies\n         * the engine (for example, `node`). Each value is a\n         * [semver](https://www.npmjs.org/doc/misc/semver.html)-compliant version number for the\n         * engine.\n         *\n         * @type {Object}\n         * @since 3.3.0\n         */\n        this.engines = packageInfo.engines;\n    }\n\n    /**\n     * The source files associated with the package.\n     *\n     * New `Package` objects always contain an empty array, regardless of whether the `package.json`\n     * file includes a `files` property.\n     *\n     * After JSDoc parses your input files, it sets this property to a list of paths to your input\n     * files.\n     *\n     * @type {Array.<string>}\n     */\n    this.files = [];\n\n    if (packageInfo.homepage) {\n        /**\n         * The URL for the package's homepage.\n         *\n         * @type {string}\n         * @since 3.3.0\n         */\n        this.homepage = packageInfo.homepage;\n    }\n\n    if (packageInfo.keywords) {\n        /**\n         * Keywords to help users find the package.\n         *\n         * @type {Array.<string>}\n         * @since 3.3.0\n         */\n        this.keywords = packageInfo.keywords;\n    }\n\n    if (packageInfo.license || packageInfo.licenses) {\n        /**\n         * The licenses used by this package. Combines information from the `package.json` file's\n         * `license` property and the deprecated `licenses` property.\n         *\n         * @type {Array.<module:jsdoc/package.Package~LicenseInfo>}\n         */\n        this.licenses = getLicenses(packageInfo);\n    }\n\n    if (packageInfo.main) {\n        /**\n         * The module ID that provides the primary entry point to the package. For example, if your\n         * package is a CommonJS module, and the value of this property is `foo`, users should be\n         * able to load your module with `require('foo')`.\n         *\n         * @type {string}\n         * @since 3.3.0\n         */\n        this.main = packageInfo.main;\n    }\n\n    if (packageInfo.repository) {\n        /**\n         * The version-control repository for the package.\n         *\n         * @type {module:jsdoc/package.Package~RepositoryInfo}\n         * @since 3.3.0\n         */\n        this.repository = packageInfo.repository;\n    }\n\n    if (packageInfo.version) {\n        /**\n         * The [semver](https://www.npmjs.org/doc/misc/semver.html)-compliant version number of the\n         * package.\n         *\n         * @type {string}\n         * @since 3.2.0\n         */\n        this.version = packageInfo.version;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/plugins.js":"/**\n * Utility functions to support the JSDoc plugin framework.\n * @module jsdoc/plugins\n */\n'use strict';\n\nvar logger = require('jsdoc/util/logger');\nvar path = require('jsdoc/path');\n\nfunction addHandlers(handlers, parser) {\n    Object.keys(handlers).forEach(function(eventName) {\n        parser.on(eventName, handlers[eventName]);\n    });\n}\n\nexports.installPlugins = function(plugins, parser) {\n    var dictionary = require('jsdoc/tag/dictionary');\n\n    var eventName;\n    var plugin;\n\n    for (var i = 0, l = plugins.length; i < l; i++) {\n        plugin = require(plugins[i]);\n\n        // allow user-defined plugins to...\n        // ...register event handlers\n        if (plugin.handlers) {\n            addHandlers(plugin.handlers, parser);\n        }\n\n        // ...define tags\n        if (plugin.defineTags) {\n            plugin.defineTags(dictionary);\n        }\n\n        // ...add a Mozilla Parser API node visitor\n        if (plugin.astNodeVisitor) {\n            parser.addAstNodeVisitor(plugin.astNodeVisitor);\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/schema.js":"/**\n * @overview Schema for validating JSDoc doclets.\n *\n * @author Michael Mathews <micmath@gmail.com>\n * @author Jeff Williams <jeffrey.l.williams@gmail.com>\n * @license Apache License 2.0 - See file 'LICENSE.md' in this project.\n * @see <http://tools.ietf.org/html/draft-zyp-json-schema-03>\n */\n'use strict';\n\n// JSON schema types\nvar ARRAY = 'array';\nvar BOOLEAN = 'boolean';\nvar INTEGER = 'integer';\nvar NULL = 'null';\nvar NUMBER = 'number';\nvar OBJECT = 'object';\nvar STRING = 'string';\nvar UNDEFINED = 'undefined';\n\nvar BOOLEAN_OPTIONAL = [BOOLEAN, NULL, UNDEFINED];\nvar STRING_OPTIONAL = [STRING, NULL, UNDEFINED];\n\nvar EVENT_REGEXP = /event\\:[\\S]+/;\nvar PACKAGE_REGEXP = /package\\:[\\S]+/;\n\n// information about the code associated with a doclet\nvar META_SCHEMA = exports.META_SCHEMA = {\n    type: OBJECT,\n    optional: true,\n    additionalProperties: false,\n    properties: {\n        code: {\n            type: OBJECT,\n            additionalProperties: false,\n            properties: {\n                funcscope: {\n                    type: STRING,\n                    optional: true\n                },\n                id: {\n                    type: STRING,\n                    optional: true\n                },\n                name: {\n                    optional: true\n                },\n                node: {\n                    type: OBJECT,\n                    optional: true\n                },\n                paramnames: {\n                    type: ARRAY,\n                    optional: true,\n                    uniqueItems: true,\n                    items: {\n                        type: STRING\n                    }\n                },\n                type: {\n                    type: STRING,\n                    optional: true\n                },\n                value: {\n                    optional: true\n                }\n            }\n        },\n        filename: {\n            title: 'The name of the file that contains the code associated with this doclet.',\n            type: STRING,\n            optional: true\n        },\n        lineno: {\n            title: 'The line number of the code associated with this doclet.',\n            type: NUMBER,\n            optional: true\n        },\n        path: {\n            title: 'The path in which the code associated with this doclet is located.',\n            type: STRING,\n            optional: true\n        },\n        range: {\n            title: 'The positions of the first and last characters of the code associated with ' +\n                'this doclet.',\n            type: ARRAY,\n            optional: true,\n            minItems: 2,\n            maxItems: 2,\n            items: {\n                type: NUMBER\n            }\n        },\n        vars: {\n            type: OBJECT\n        }\n    }\n};\n\n// type property containing type names\nvar TYPE_PROPERTY_SCHEMA = exports.TYPE_PROPERTY_SCHEMA = {\n    type: OBJECT,\n    additionalProperties: false,\n    properties: {\n        names: {\n            type: ARRAY,\n            minItems: 1,\n            items: {\n                type: STRING\n            }\n        },\n        // type parser output\n        parsedType: {\n           type: OBJECT,\n           additionalProperties: true\n        }\n    }\n};\n\n// enumeration properties\nvar ENUM_PROPERTY_SCHEMA = exports.ENUM_PROPERTY_SCHEMA = {\n    type: OBJECT,\n    additionalProperties: false,\n    properties: {\n        comment: {\n            type: STRING\n        },\n        defaultvalue: {\n            optional: true\n        },\n        description: {\n            type: STRING_OPTIONAL,\n            optional: true\n        },\n        kind: {\n            type: STRING,\n            // TODO: get this from a real enum somewhere\n            enum: ['member']\n        },\n        longname: {\n            type: STRING\n        },\n        memberof: {\n            type: STRING,\n            optional: true\n        },\n        meta: META_SCHEMA,\n        name: {\n            type: STRING\n        },\n        // is this member nullable? (derived from the type expression)\n        nullable: {\n            type: BOOLEAN_OPTIONAL\n        },\n        // is this member optional? (derived from the type expression)\n        optional: {\n            type: BOOLEAN_OPTIONAL\n        },\n        scope: {\n            type: STRING,\n            // TODO: get this from a real enum somewhere\n            enum: ['static']\n        },\n        type: TYPE_PROPERTY_SCHEMA,\n        // can this member be provided more than once? (derived from the type expression)\n        variable: {\n            type: BOOLEAN_OPTIONAL\n        }\n    }\n};\n\n// function parameter, or object property defined with @property tag\nvar PARAM_SCHEMA = exports.PARAM_SCHEMA = {\n    type: OBJECT,\n    additionalProperties: false,\n    properties: {\n        // what is the default value for this parameter?\n        defaultvalue: {\n            optional: true\n        },\n        // a description of the parameter\n        description: {\n            type: STRING_OPTIONAL,\n            optional: true\n        },\n        // what name does this parameter have within the function?\n        name: {\n            type: STRING\n        },\n        // can the value for this parameter be null?\n        nullable: {\n            type: BOOLEAN_OPTIONAL,\n            optional: true\n        },\n        // is a value for this parameter optional?\n        optional: {\n            type: BOOLEAN_OPTIONAL,\n            optional: true\n        },\n        // what are the types of value expected for this parameter?\n        type: TYPE_PROPERTY_SCHEMA,\n        // can this parameter be repeated?\n        variable: {\n            type: BOOLEAN_OPTIONAL,\n            optional: true\n        }\n    }\n};\n\nvar DOCLET_SCHEMA = exports.DOCLET_SCHEMA = {\n    type: OBJECT,\n    additionalProperties: false,\n    properties: {\n        // what access privileges are allowed\n        access: {\n            type: STRING,\n            optional: true,\n            // TODO: define this as an enumeration elsewhere\n            enum: [\n                'private',\n                'protected',\n                'public'\n            ]\n        },\n        alias: {\n            type: STRING,\n            optional: true\n        },\n        augments: {\n            type: ARRAY,\n            optional: true,\n            uniqueItems: true,\n            items: {\n                type: STRING\n            }\n        },\n        author: {\n            type: ARRAY,\n            optional: true,\n            items: {\n                type: STRING\n            }\n        },\n        borrowed: {\n            type: ARRAY,\n            optional: true,\n            uniqueItems: true,\n            items: {\n                type: OBJECT,\n                additionalProperties: false,\n                properties: {\n                    // name of the target\n                    as: {\n                        type: STRING,\n                        optional: true\n                    },\n                    // name of the source\n                    from: {\n                        type: STRING\n                    }\n                }\n            }\n        },\n        // a description of the class that this constructor belongs to\n        classdesc: {\n            type: STRING,\n            optional: true\n        },\n        comment: {\n            type: STRING\n        },\n        copyright: {\n            type: STRING,\n            optional: true\n        },\n        defaultvalue: {\n            optional: true\n        },\n        defaultvaluetype: {\n            type: STRING,\n            optional: true,\n            enum: [OBJECT, ARRAY]\n        },\n        // is usage of this symbol deprecated?\n        deprecated: {\n            type: [STRING, BOOLEAN],\n            optional: true\n        },\n        // a description\n        description: {\n            type: STRING_OPTIONAL,\n            optional: true\n        },\n        // something else to consider\n        examples: {\n            type: ARRAY,\n            optional: true,\n            items: {\n                type: STRING\n            }\n        },\n        exceptions: {\n            type: ARRAY,\n            optional: true,\n            items: PARAM_SCHEMA\n        },\n        // the path to another constructor\n        extends: {\n            type: ARRAY,\n            optional: true,\n            uniqueItems: true,\n            items: {\n                type: STRING\n            }\n        },\n        // the path to another doc object\n        fires: {\n            type: ARRAY,\n            optional: true,\n            uniqueItems: true,\n            items: {\n                type: STRING,\n                pattern: EVENT_REGEXP\n            }\n        },\n        forceMemberof: {\n            type: BOOLEAN_OPTIONAL,\n            optional: true\n        },\n        ignore: {\n            type: BOOLEAN,\n            optional: true\n        },\n        implementations: {\n            type: ARRAY,\n            optional: true,\n            items: {\n                type: STRING\n            }\n        },\n        implements: {\n            type: ARRAY,\n            optional: true,\n            items: {\n                type: STRING\n            }\n        },\n        inheritdoc: {\n            type: STRING,\n            optional: true\n        },\n        inherited: {\n            type: BOOLEAN,\n            optional: true\n        },\n        inherits: {\n            type: STRING,\n            optional: true,\n            dependency: {\n                inherited: true\n            }\n        },\n        isEnum: {\n            type: BOOLEAN,\n            optional: true\n        },\n        // what kind of symbol is this?\n        kind: {\n            type: STRING,\n            // TODO: define this as an enumeration elsewhere\n            enum: [\n                'class',\n                'constant',\n                'event',\n                'external',\n                'file',\n                'function',\n                'interface',\n                'member',\n                'mixin',\n                'module',\n                'namespace',\n                'package',\n                'param',\n                'typedef'\n            ]\n        },\n        license: {\n            type: STRING,\n            optional: true\n        },\n        listens: {\n            type: ARRAY,\n            optional: true,\n            uniqueItems: true,\n            items: {\n                type: STRING,\n                pattern: EVENT_REGEXP\n            }\n        },\n        longname: {\n            type: STRING\n        },\n        // probably a leading substring of the path\n        memberof: {\n            type: STRING,\n            optional: true\n        },\n        // information about this doc\n        meta: META_SCHEMA,\n        // was this doclet mixed in?\n        mixed: {\n            type: BOOLEAN,\n            optional: true\n        },\n        mixes: {\n            type: ARRAY,\n            optional: true,\n            uniqueItems: true,\n            items: {\n                type: STRING\n            }\n        },\n        // probably a trailing substring of the path\n        name: {\n            type: STRING\n        },\n        // is this member nullable? (derived from the type expression)\n        nullable: {\n            type: BOOLEAN_OPTIONAL\n        },\n        // is this member optional? (derived from the type expression)\n        optional: {\n            type: BOOLEAN_OPTIONAL\n        },\n        // does this member explicitly override the parent?\n        override: {\n            type: BOOLEAN,\n            optional: true\n        },\n        overrides: {\n            type: STRING,\n            optional: true\n        },\n        // are there function parameters associated with this doc?\n        params: {\n            type: ARRAY,\n            optional: true,\n            uniqueItems: true,\n            items: PARAM_SCHEMA\n        },\n        preserveName: {\n            type: BOOLEAN,\n            optional: true\n        },\n        properties: {\n            type: ARRAY,\n            optional: true,\n            uniqueItems: true,\n            minItems: 1,\n            items: {\n                anyOf: [ENUM_PROPERTY_SCHEMA, PARAM_SCHEMA]\n            }\n        },\n        readonly: {\n            type: BOOLEAN,\n            optional: true\n        },\n        // the symbol being documented requires another symbol\n        requires: {\n            type: ARRAY,\n            optional: true,\n            uniqueItems: true,\n            minItems: 1,\n            items: {\n                type: STRING\n            }\n        },\n        returns: {\n            type: ARRAY,\n            optional: true,\n            minItems: 1,\n            items: PARAM_SCHEMA\n        },\n        // what sort of parent scope does this symbol have?\n        scope: {\n            type: STRING,\n            enum: [\n                // TODO: make these an enumeration\n                'global',\n                'inner',\n                'instance',\n                'static'\n            ]\n        },\n        // something else to consider\n        see: {\n            type: ARRAY,\n            optional: true,\n            minItems: 1,\n            items: {\n                type: STRING\n            }\n        },\n        // at what previous version was this doc added?\n        since: {\n            type: STRING,\n            optional: true\n        },\n        summary: {\n            type: STRING,\n            optional: true\n        },\n        // arbitrary tags associated with this doc\n        tags: {\n            type: ARRAY,\n            optional: true,\n            minItems: 1,\n            items: {\n                type: OBJECT,\n                additionalProperties: false,\n                properties: {\n                    originalTitle: {\n                        type: STRING\n                    },\n                    text: {\n                        type: STRING,\n                        optional: true\n                    },\n                    title: {\n                        type: STRING\n                    },\n                    value: {\n                        type: [STRING, OBJECT],\n                        optional: true,\n                        properties: PARAM_SCHEMA\n                    }\n                }\n            }\n        },\n        'this': {\n            type: STRING,\n            optional: true\n        },\n        todo: {\n            type: ARRAY,\n            optional: true,\n            minItems: 1,\n            items: {\n                type: STRING\n            }\n        },\n        // extended tutorials\n        tutorials: {\n            type: ARRAY,\n            optional: true,\n            minItems: 1,\n            items: {\n                type: STRING\n            }\n        },\n        // what type is the value that this doc is associated with, like `number`\n        type: TYPE_PROPERTY_SCHEMA,\n        undocumented: {\n            type: BOOLEAN,\n            optional: true\n        },\n        // can this member be provided more than once? (derived from the type expression)\n        variable: {\n            type: BOOLEAN_OPTIONAL\n        },\n        variation: {\n            type: STRING,\n            optional: true\n        },\n        // what is the version of this doc\n        version: {\n            type: STRING,\n            optional: true\n        },\n        // is a member left to be implemented during inheritance?\n        virtual: {\n            type: BOOLEAN,\n            optional: true\n        }\n    }\n};\n\nvar CONTACT_INFO_SCHEMA = exports.CONTACT_INFO_SCHEMA = {\n    type: OBJECT,\n    additionalProperties: false,\n    properties: {\n        email: {\n            type: STRING,\n            optional: true\n        },\n        name: {\n            type: STRING,\n            optional: true\n        },\n        url: {\n            type: STRING,\n            optional: true,\n            format: 'uri'\n        }\n    }\n};\n\nvar BUGS_SCHEMA = exports.BUGS_SCHEMA = {\n    type: OBJECT,\n    additionalProperties: false,\n    properties: {\n        email: {\n            type: STRING,\n            optional: true\n        },\n        url: {\n            type: STRING,\n            optional: true,\n            format: 'uri'\n        }\n    }\n};\n\nvar PACKAGE_SCHEMA = exports.PACKAGE_SCHEMA = {\n    type: OBJECT,\n    additionalProperties: false,\n    properties: {\n        author: {\n            anyOf: [STRING, CONTACT_INFO_SCHEMA],\n            optional: true\n        },\n        bugs: {\n            anyOf: [STRING, BUGS_SCHEMA],\n            optional: true\n        },\n        contributors: {\n            type: ARRAY,\n            optional: true,\n            minItems: 0,\n            items: {\n                anyOf: [STRING, CONTACT_INFO_SCHEMA]\n            }\n        },\n        dependencies: {\n            type: OBJECT,\n            optional: true\n        },\n        description: {\n            type: STRING,\n            optional: true\n        },\n        devDependencies: {\n            type: OBJECT,\n            optional: true\n        },\n        engines: {\n            type: OBJECT,\n            optional: true\n        },\n        files: {\n            type: ARRAY,\n            uniqueItems: true,\n            minItems: 0,\n            items: {\n                type: STRING\n            }\n        },\n        homepage: {\n            type: STRING,\n            optional: true,\n            format: 'uri'\n        },\n        keywords: {\n            type: ARRAY,\n            optional: true,\n            minItems: 0,\n            items: {\n                type: STRING\n            }\n        },\n        kind: {\n            type: STRING,\n            enum: ['package']\n        },\n        licenses: {\n            type: ARRAY,\n            optional: true,\n            minItems: 1,\n            items: {\n                type: OBJECT,\n                additionalProperties: false,\n                properties: {\n                    type: {\n                        type: STRING,\n                        optional: true\n                    },\n                    url: {\n                        type: STRING,\n                        optional: true,\n                        format: 'uri'\n                    }\n                }\n            }\n        },\n        longname: {\n            type: STRING,\n            optional: true,\n            pattern: PACKAGE_REGEXP\n        },\n        main: {\n            type: STRING,\n            optional: true\n        },\n        name: {\n            type: STRING,\n            optional: true\n        },\n        repository: {\n            type: OBJECT,\n            optional: true,\n            additionalProperties: false,\n            properties: {\n                type: {\n                    type: STRING,\n                    optional: true\n                },\n                // we don't use `format: 'uri'` here because repo URLs are atypical\n                url: {\n                    type: STRING,\n                    optional: true\n                }\n            }\n        },\n        version: {\n            type: STRING,\n            optional: true\n        }\n    }\n};\n\nvar DOCLETS_SCHEMA = exports.DOCLETS_SCHEMA = {\n    type: ARRAY,\n    items: {\n        anyOf: [DOCLET_SCHEMA, PACKAGE_SCHEMA]\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/tag.js":"/**\n    @overview\n    @author Michael Mathews <micmath@gmail.com>\n    @license Apache License 2.0 - See file 'LICENSE.md' in this project.\n */\n\n/**\n    Functionality related to JSDoc tags.\n    @module jsdoc/tag\n    @requires jsdoc/tag/dictionary\n    @requires jsdoc/tag/validator\n    @requires jsdoc/tag/type\n */\n'use strict';\n\nvar jsdoc = {\n    env: require('jsdoc/env'),\n    tag: {\n        dictionary: require('jsdoc/tag/dictionary'),\n        validator: require('jsdoc/tag/validator'),\n        type: require('jsdoc/tag/type')\n    },\n    util: {\n        logger: require('jsdoc/util/logger')\n    }\n};\nvar path = require('jsdoc/path');\nvar util = require('util');\n\n// Check whether the text is the same as a symbol name with leading or trailing whitespace. If so,\n// the whitespace must be preserved, and the text cannot be trimmed.\nfunction mustPreserveWhitespace(text, meta) {\n    return meta && meta.code && meta.code.name === text && text.match(/(?:^\\s+)|(?:\\s+$)/);\n}\n\nfunction trim(text, opts, meta) {\n    var indentMatcher;\n    var match;\n\n    opts = opts || {};\n    text = String(typeof text !== 'undefined' ? text : '');\n\n    if ( mustPreserveWhitespace(text, meta) ) {\n        text = util.format('\"%s\"', text);\n    }\n    else if (opts.keepsWhitespace) {\n        text = text.replace(/^[\\n\\r\\f]+|[\\n\\r\\f]+$/g, '');\n        if (opts.removesIndent) {\n            match = text.match(/^([ \\t]+)/);\n            if (match && match[1]) {\n                indentMatcher = new RegExp('^' + match[1], 'gm');\n                text = text.replace(indentMatcher, '');\n            }\n        }\n    }\n    else {\n        text = text.replace(/^\\s+|\\s+$/g, '');\n    }\n\n    return text;\n}\n\nfunction addHiddenProperty(obj, propName, propValue) {\n    Object.defineProperty(obj, propName, {\n        value: propValue,\n        writable: true,\n        enumerable: !!jsdoc.env.opts.debug,\n        configurable: true\n    });\n}\n\nfunction parseType(tag, tagDef, meta) {\n    try {\n        return jsdoc.tag.type.parse(tag.text, tagDef.canHaveName, tagDef.canHaveType);\n    }\n    catch (e) {\n        jsdoc.util.logger.error(\n            'Unable to parse a tag\\'s type expression%s with tag title \"%s\" and text \"%s\": %s',\n            meta.filename ? ( ' for source file ' + path.join(meta.path, meta.filename) ) : '',\n            tag.originalTitle,\n            tag.text,\n            e.message\n        );\n        return {};\n    }\n}\n\nfunction processTagText(tag, tagDef, meta) {\n    var tagType;\n\n    if (tagDef.onTagText) {\n        tag.text = tagDef.onTagText(tag.text);\n    }\n\n    if (tagDef.canHaveType || tagDef.canHaveName) {\n        /** The value property represents the result of parsing the tag text. */\n        tag.value = {};\n\n        tagType = parseType(tag, tagDef, meta);\n\n        // It is possible for a tag to *not* have a type but still have\n        // optional or defaultvalue, e.g. '@param [foo]'.\n        // Although tagType.type.length == 0 we should still copy the other properties.\n        if (tagType.type) {\n            if (tagType.type.length) {\n                tag.value.type = {\n                    names: tagType.type\n                };\n                addHiddenProperty(tag.value.type, 'parsedType', tagType.parsedType);\n            }\n\n            ['optional', 'nullable', 'variable', 'defaultvalue'].forEach(function(prop) {\n                if (typeof tagType[prop] !== 'undefined') {\n                    tag.value[prop] = tagType[prop];\n                }\n            });\n        }\n\n        if (tagType.text && tagType.text.length) {\n            tag.value.description = tagType.text;\n        }\n\n        if (tagDef.canHaveName) {\n            // note the dash is a special case: as a param name it means \"no name\"\n            if (tagType.name && tagType.name !== '-') { tag.value.name = tagType.name; }\n        }\n    }\n    else {\n        tag.value = tag.text;\n    }\n}\n\n/**\n * Replace the existing tag dictionary with a new tag dictionary.\n *\n * Used for testing only. Do not call this method directly. Instead, call\n * {@link module:jsdoc/doclet._replaceDictionary}, which also updates this module's tag dictionary.\n *\n * @private\n * @param {module:jsdoc/tag/dictionary.Dictionary} dict - The new tag dictionary.\n */\nexports._replaceDictionary = function _replaceDictionary(dict) {\n    jsdoc.tag.dictionary = dict;\n};\n\n/**\n    Constructs a new tag object. Calls the tag validator.\n    @class\n    @classdesc Represents a single doclet tag.\n    @param {string} tagTitle\n    @param {string=} tagBody\n    @param {object=} meta\n */\nvar Tag = exports.Tag = function(tagTitle, tagBody, meta) {\n    var tagDef;\n    var trimOpts;\n\n    meta = meta || {};\n\n    this.originalTitle = trim(tagTitle);\n\n    /** The title of the tag (for example, `title` in `@title text`). */\n    this.title = jsdoc.tag.dictionary.normalise(this.originalTitle);\n\n    tagDef = jsdoc.tag.dictionary.lookUp(this.title);\n    trimOpts = {\n        keepsWhitespace: tagDef.keepsWhitespace,\n        removesIndent: tagDef.removesIndent\n    };\n\n    /**\n     * The text following the tag (for example, `text` in `@title text`).\n     *\n     * Whitespace is trimmed from the tag text as follows:\n     *\n     * + If the tag's `keepsWhitespace` option is falsy, all leading and trailing whitespace are\n     * removed.\n     * + If the tag's `keepsWhitespace` option is set to `true`, leading and trailing whitespace are\n     * not trimmed, unless the `removesIndent` option is also enabled.\n     * + If the tag's `removesIndent` option is set to `true`, any indentation that is shared by\n     * every line in the string is removed. This option is ignored unless `keepsWhitespace` is set\n     * to `true`.\n     *\n     * **Note**: If the tag text is the name of a symbol, and the symbol's name includes leading or\n     * trailing whitespace (for example, the property names in `{ ' ': true, ' foo ': false }`),\n     * the tag text is not trimmed. Instead, the tag text is wrapped in double quotes to prevent the\n     * whitespace from being trimmed.\n     */\n    this.text = trim(tagBody, trimOpts, meta);\n\n    if (this.text) {\n        processTagText(this, tagDef, meta);\n    }\n\n    jsdoc.tag.validator.validate(this, tagDef, meta);\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/template.js":"/**\n * @file Wrapper for underscore's template utility to allow loading templates from files.\n * @author Rafał Wrzeszcz <rafal.wrzeszcz@wrzasq.pl>\n * @author <a href=\"mailto:matthewkastor@gmail.com\">Matthew Christopher Kastor-Inare III</a>\n * @license Apache License 2.0 - See file 'LICENSE.md' in this project.\n */\n'use strict';\n\nvar _ = require('underscore'),\n    fs = require('jsdoc/fs'),\n    path = require('path');\n\n/**\n    @module jsdoc/template\n */\n\n/**\n    @class\n    @classdesc Underscore template helper.\n    @param {string} filepath - Templates directory.\n */\nexports.Template = function(filepath) {\n    this.path = filepath;\n    this.layout = null;\n    this.cache = {};\n    // override default template tag settings\n    this.settings = {\n        evaluate: /<\\?js([\\s\\S]+?)\\?>/g,\n        interpolate: /<\\?js=([\\s\\S]+?)\\?>/g,\n        escape: /<\\?js~([\\s\\S]+?)\\?>/g\n    };\n};\n\n/** Loads template from given file.\n    @param {string} file - Template filename.\n    @return {function} Returns template closure.\n */\nexports.Template.prototype.load = function(file) {\n    return _.template(fs.readFileSync(file, 'utf8'), null, this.settings);\n};\n\n/**\n    Renders template using given data.\n\n    This is low-level function, for rendering full templates use {@link Template.render()}.\n\n    @param {string} file - Template filename.\n    @param {object} data - Template variables (doesn't have to be object, but passing variables dictionary is best way and most common use).\n    @return {string} Rendered template.\n */\nexports.Template.prototype.partial = function(file, data) {\n    file = path.resolve(this.path, file);\n\n    // load template into cache\n    if (!(file in this.cache)) {\n        this.cache[file] = this.load(file);\n    }\n\n    // keep template helper context\n    return this.cache[file].call(this, data);\n};\n\n/**\n    Renders template with given data.\n\n    This method automaticaly applies layout if set.\n\n    @param {string} file - Template filename.\n    @param {object} data - Template variables (doesn't have to be object, but passing variables dictionary is best way and most common use).\n    @return {string} Rendered template.\n */\nexports.Template.prototype.render = function(file, data) {\n    // main content\n    var content = this.partial(file, data);\n\n    // apply layout\n    if (this.layout) {\n        data.content = content;\n        content = this.partial(this.layout, data);\n    }\n\n    return content;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/tutorial.js":"/**\n    @overview\n    @author Rafał Wrzeszcz <rafal.wrzeszcz@wrzasq.pl>\n    @license Apache License 2.0 - See file 'LICENSE.md' in this project.\n */\n'use strict';\n\nvar markdown = require('jsdoc/util/markdown');\nvar util = require('util');\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\n/** Removes child tutorial from the parent. Does *not* unset child.parent though.\n    @param {Tutorial} parent - parent tutorial.\n    @param {Tutorial} child - Old child.\n    @private\n */\nfunction removeChild(parent, child) {\n    var index = parent.children.indexOf(child);\n    if (index !== -1) {\n        parent.children.splice(index, 1);\n    }\n}\n\n/** Adds a child to the parent tutorial. Does *not* set child.parent though.\n    @param {Tutorial} parent - parent tutorial.\n    @param {Tutorial} child - New child.\n    @private\n */\nfunction addChild(parent, child) {\n    parent.children.push(child);\n}\n\n/**\n    @module jsdoc/tutorial\n */\n\n/**\n    @class\n    @classdesc Represents a single JSDoc tutorial.\n    @param {string} name - Tutorial name.\n    @param {string} content - Text content.\n    @param {number} type - Source formating.\n */\nexports.Tutorial = function(name, content, type) {\n    this.title = this.name = this.longname = name;\n    this.content = content;\n    this.type = type;\n\n    // default values\n    this.parent = null;\n    this.children = [];\n};\n\n/** Moves children from current parent to different one.\n    @param {?Tutorial} parent - New parent. If null, the tutorial has no parent.\n */\nexports.Tutorial.prototype.setParent = function(parent) {\n    // removes node from old parent\n    if (this.parent) {\n        removeChild(this.parent, this);\n    }\n\n    this.parent = parent;\n    if (parent) {\n        addChild(parent, this);\n    }\n};\n\n/** Removes children from current node.\n    @param {Tutorial} child - Old child.\n */\nexports.Tutorial.prototype.removeChild = function(child) {\n    child.setParent(null);\n};\n\n/** Adds new children to current node.\n    @param {Tutorial} child - New child.\n */\nexports.Tutorial.prototype.addChild = function(child) {\n    child.setParent(this);\n};\n\n/** Prepares source.\n    @return {string} HTML source.\n */\nexports.Tutorial.prototype.parse = function() {\n    switch (this.type) {\n        // nothing to do\n        case exports.TYPES.HTML:\n            return this.content;\n\n        // markdown\n        case exports.TYPES.MARKDOWN:\n            var mdParse = markdown.getParser();\n            return mdParse(this.content);\n\n        // uhm... should we react somehow?\n        // if not then this case can be merged with TYPES.HTML\n        default:\n            return this.content;\n    }\n};\n\n/**\n * @class\n * @classdesc Represents the root tutorial.\n * @extends {module:jsdoc/tutorial.Tutorial}\n */\nexports.RootTutorial = function() {\n    exports.RootTutorial.super_.call(this, '', '');\n\n    this._tutorials = {};\n};\nutil.inherits(exports.RootTutorial, exports.Tutorial);\n\n/**\n * Retrieve a tutorial by name.\n * @param {string} name - Tutorial name.\n * @return {module:jsdoc/tutorial.Tutorial} Tutorial instance.\n */\nexports.RootTutorial.prototype.getByName = function(name) {\n    return hasOwnProp.call(this._tutorials, name) && this._tutorials[name];\n};\n\n/**\n * Add a child tutorial to the root.\n * @param {module:jsdoc/tutorial.Tutorial} child - Child tutorial.\n */\nexports.RootTutorial.prototype._addTutorial = function(child) {\n    this._tutorials[child.name] = child;\n};\n\n/** Tutorial source types.\n    @enum {number}\n */\nexports.TYPES = {\n    HTML: 1,\n    MARKDOWN: 2\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/templates/default/publish.js":"'use strict';\n\nvar doop = require('jsdoc/util/doop');\nvar env = require('jsdoc/env');\nvar fs = require('jsdoc/fs');\nvar helper = require('jsdoc/util/templateHelper');\nvar logger = require('jsdoc/util/logger');\nvar path = require('jsdoc/path');\nvar taffy = require('taffydb').taffy;\nvar template = require('jsdoc/template');\nvar util = require('util');\n\nvar htmlsafe = helper.htmlsafe;\nvar linkto = helper.linkto;\nvar resolveAuthorLinks = helper.resolveAuthorLinks;\nvar scopeToPunc = helper.scopeToPunc;\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\nvar data;\nvar view;\n\nvar outdir = path.normalize(env.opts.destination);\n\nfunction find(spec) {\n    return helper.find(data, spec);\n}\n\nfunction tutoriallink(tutorial) {\n    return helper.toTutorial(tutorial, null, { tag: 'em', classname: 'disabled', prefix: 'Tutorial: ' });\n}\n\nfunction getAncestorLinks(doclet) {\n    return helper.getAncestorLinks(data, doclet);\n}\n\nfunction hashToLink(doclet, hash) {\n    if ( !/^(#.+)/.test(hash) ) { return hash; }\n\n    var url = helper.createLink(doclet);\n\n    url = url.replace(/(#.+|$)/, hash);\n    return '<a href=\"' + url + '\">' + hash + '</a>';\n}\n\nfunction needsSignature(doclet) {\n    var needsSig = false;\n\n    // function and class definitions always get a signature\n    if (doclet.kind === 'function' || doclet.kind === 'class') {\n        needsSig = true;\n    }\n    // typedefs that contain functions get a signature, too\n    else if (doclet.kind === 'typedef' && doclet.type && doclet.type.names &&\n        doclet.type.names.length) {\n        for (var i = 0, l = doclet.type.names.length; i < l; i++) {\n            if (doclet.type.names[i].toLowerCase() === 'function') {\n                needsSig = true;\n                break;\n            }\n        }\n    }\n\n    return needsSig;\n}\n\nfunction getSignatureAttributes(item) {\n    var attributes = [];\n\n    if (item.optional) {\n        attributes.push('opt');\n    }\n\n    if (item.nullable === true) {\n        attributes.push('nullable');\n    }\n    else if (item.nullable === false) {\n        attributes.push('non-null');\n    }\n\n    return attributes;\n}\n\nfunction updateItemName(item) {\n    var attributes = getSignatureAttributes(item);\n    var itemName = item.name || '';\n\n    if (item.variable) {\n        itemName = '&hellip;' + itemName;\n    }\n\n    if (attributes && attributes.length) {\n        itemName = util.format( '%s<span class=\"signature-attributes\">%s</span>', itemName,\n            attributes.join(', ') );\n    }\n\n    return itemName;\n}\n\nfunction addParamAttributes(params) {\n    return params.filter(function(param) {\n        return param.name && param.name.indexOf('.') === -1;\n    }).map(updateItemName);\n}\n\nfunction buildItemTypeStrings(item) {\n    var types = [];\n\n    if (item && item.type && item.type.names) {\n        item.type.names.forEach(function(name) {\n            types.push( linkto(name, htmlsafe(name)) );\n        });\n    }\n\n    return types;\n}\n\nfunction buildAttribsString(attribs) {\n    var attribsString = '';\n\n    if (attribs && attribs.length) {\n        attribsString = htmlsafe( util.format('(%s) ', attribs.join(', ')) );\n    }\n\n    return attribsString;\n}\n\nfunction addNonParamAttributes(items) {\n    var types = [];\n\n    items.forEach(function(item) {\n        types = types.concat( buildItemTypeStrings(item) );\n    });\n\n    return types;\n}\n\nfunction addSignatureParams(f) {\n    var params = f.params ? addParamAttributes(f.params) : [];\n\n    f.signature = util.format( '%s(%s)', (f.signature || ''), params.join(', ') );\n}\n\nfunction addSignatureReturns(f) {\n    var attribs = [];\n    var attribsString = '';\n    var returnTypes = [];\n    var returnTypesString = '';\n\n    // jam all the return-type attributes into an array. this could create odd results (for example,\n    // if there are both nullable and non-nullable return types), but let's assume that most people\n    // who use multiple @return tags aren't using Closure Compiler type annotations, and vice-versa.\n    if (f.returns) {\n        f.returns.forEach(function(item) {\n            helper.getAttribs(item).forEach(function(attrib) {\n                if (attribs.indexOf(attrib) === -1) {\n                    attribs.push(attrib);\n                }\n            });\n        });\n\n        attribsString = buildAttribsString(attribs);\n    }\n\n    if (f.returns) {\n        returnTypes = addNonParamAttributes(f.returns);\n    }\n    if (returnTypes.length) {\n        returnTypesString = util.format( ' &rarr; %s{%s}', attribsString, returnTypes.join('|') );\n    }\n\n    f.signature = '<span class=\"signature\">' + (f.signature || '') + '</span>' +\n        '<span class=\"type-signature\">' + returnTypesString + '</span>';\n}\n\nfunction addSignatureTypes(f) {\n    var types = f.type ? buildItemTypeStrings(f) : [];\n\n    f.signature = (f.signature || '') + '<span class=\"type-signature\">' +\n        (types.length ? ' :' + types.join('|') : '') + '</span>';\n}\n\nfunction addAttribs(f) {\n    var attribs = helper.getAttribs(f);\n    var attribsString = buildAttribsString(attribs);\n\n    f.attribs = util.format('<span class=\"type-signature\">%s</span>', attribsString);\n}\n\nfunction shortenPaths(files, commonPrefix) {\n    Object.keys(files).forEach(function(file) {\n        files[file].shortened = files[file].resolved.replace(commonPrefix, '')\n            // always use forward slashes\n            .replace(/\\\\/g, '/');\n    });\n\n    return files;\n}\n\nfunction getPathFromDoclet(doclet) {\n    if (!doclet.meta) {\n        return null;\n    }\n\n    return doclet.meta.path && doclet.meta.path !== 'null' ?\n        path.join(doclet.meta.path, doclet.meta.filename) :\n        doclet.meta.filename;\n}\n\nfunction generate(title, docs, filename, resolveLinks) {\n    resolveLinks = resolveLinks === false ? false : true;\n\n    var docData = {\n        env: env,\n        title: title,\n        docs: docs\n    };\n\n    var outpath = path.join(outdir, filename),\n        html = view.render('container.tmpl', docData);\n\n    if (resolveLinks) {\n        html = helper.resolveLinks(html); // turn {@link foo} into <a href=\"foodoc.html\">foo</a>\n    }\n\n    fs.writeFileSync(outpath, html, 'utf8');\n}\n\nfunction generateSourceFiles(sourceFiles, encoding) {\n    encoding = encoding || 'utf8';\n    Object.keys(sourceFiles).forEach(function(file) {\n        var source;\n        // links are keyed to the shortened path in each doclet's `meta.shortpath` property\n        var sourceOutfile = helper.getUniqueFilename(sourceFiles[file].shortened);\n        helper.registerLink(sourceFiles[file].shortened, sourceOutfile);\n\n        try {\n            source = {\n                kind: 'source',\n                code: helper.htmlsafe( fs.readFileSync(sourceFiles[file].resolved, encoding) )\n            };\n        }\n        catch (e) {\n            logger.error('Error while generating source file %s: %s', file, e.message);\n        }\n\n        generate('Source: ' + sourceFiles[file].shortened, [source], sourceOutfile,\n            false);\n    });\n}\n\n/**\n * Look for classes or functions with the same name as modules (which indicates that the module\n * exports only that class or function), then attach the classes or functions to the `module`\n * property of the appropriate module doclets. The name of each class or function is also updated\n * for display purposes. This function mutates the original arrays.\n *\n * @private\n * @param {Array.<module:jsdoc/doclet.Doclet>} doclets - The array of classes and functions to\n * check.\n * @param {Array.<module:jsdoc/doclet.Doclet>} modules - The array of module doclets to search.\n */\nfunction attachModuleSymbols(doclets, modules) {\n    var symbols = {};\n\n    // build a lookup table\n    doclets.forEach(function(symbol) {\n        symbols[symbol.longname] = symbols[symbol.longname] || [];\n        symbols[symbol.longname].push(symbol);\n    });\n\n    return modules.map(function(module) {\n        if (symbols[module.longname]) {\n            module.modules = symbols[module.longname]\n                // Only show symbols that have a description. Make an exception for classes, because\n                // we want to show the constructor-signature heading no matter what.\n                .filter(function(symbol) {\n                    return symbol.description || symbol.kind === 'class';\n                })\n                .map(function(symbol) {\n                    symbol = doop(symbol);\n\n                    if (symbol.kind === 'class' || symbol.kind === 'function') {\n                        symbol.name = symbol.name.replace('module:', '(require(\"') + '\"))';\n                    }\n\n                    return symbol;\n                });\n        }\n    });\n}\n\nfunction buildMemberNav(items, itemHeading, itemsSeen, linktoFn) {\n    var nav = '';\n\n    if (items.length) {\n        var itemsNav = '';\n\n        items.forEach(function(item) {\n            if ( !hasOwnProp.call(item, 'longname') ) {\n                itemsNav += '<li>' + linktoFn('', item.name) + '</li>';\n            }\n            else if ( !hasOwnProp.call(itemsSeen, item.longname) ) {\n                var displayName;\n                if (env.conf.templates.default.useLongnameInNav) {\n                    displayName = item.longname;\n                } else {\n                    displayName = item.name;\n                }\n                itemsNav += '<li>' + linktoFn(item.longname, displayName.replace(/\\b(module|event):/g, '')) + '</li>';\n\n                itemsSeen[item.longname] = true;\n            }\n        });\n\n        if (itemsNav !== '') {\n            nav += '<h3>' + itemHeading + '</h3><ul>' + itemsNav + '</ul>';\n        }\n    }\n\n    return nav;\n}\n\nfunction linktoTutorial(longName, name) {\n    return tutoriallink(name);\n}\n\nfunction linktoExternal(longName, name) {\n    return linkto(longName, name.replace(/(^\"|\"$)/g, ''));\n}\n\n/**\n * Create the navigation sidebar.\n * @param {object} members The members that will be used to create the sidebar.\n * @param {array<object>} members.classes\n * @param {array<object>} members.externals\n * @param {array<object>} members.globals\n * @param {array<object>} members.mixins\n * @param {array<object>} members.modules\n * @param {array<object>} members.namespaces\n * @param {array<object>} members.tutorials\n * @param {array<object>} members.events\n * @param {array<object>} members.interfaces\n * @return {string} The HTML for the navigation sidebar.\n */\nfunction buildNav(members) {\n    var nav = '<h2><a href=\"index.html\">Home</a></h2>';\n    var seen = {};\n    var seenTutorials = {};\n\n    nav += buildMemberNav(members.modules, 'Modules', {}, linkto);\n    nav += buildMemberNav(members.externals, 'Externals', seen, linktoExternal);\n    nav += buildMemberNav(members.classes, 'Classes', seen, linkto);\n    nav += buildMemberNav(members.events, 'Events', seen, linkto);\n    nav += buildMemberNav(members.namespaces, 'Namespaces', seen, linkto);\n    nav += buildMemberNav(members.mixins, 'Mixins', seen, linkto);\n    nav += buildMemberNav(members.tutorials, 'Tutorials', seenTutorials, linktoTutorial);\n    nav += buildMemberNav(members.interfaces, 'Interfaces', seen, linkto);\n\n    if (members.globals.length) {\n        var globalNav = '';\n\n        members.globals.forEach(function(g) {\n            if ( g.kind !== 'typedef' && !hasOwnProp.call(seen, g.longname) ) {\n                globalNav += '<li>' + linkto(g.longname, g.name) + '</li>';\n            }\n            seen[g.longname] = true;\n        });\n\n        if (!globalNav) {\n            // turn the heading into a link so you can actually get to the global page\n            nav += '<h3>' + linkto('global', 'Global') + '</h3>';\n        }\n        else {\n            nav += '<h3>Global</h3><ul>' + globalNav + '</ul>';\n        }\n    }\n\n    return nav;\n}\n\n/**\n    @param {TAFFY} taffyData See <http://taffydb.com/>.\n    @param {object} opts\n    @param {Tutorial} tutorials\n */\nexports.publish = function(taffyData, opts, tutorials) {\n    data = taffyData;\n\n    var conf = env.conf.templates || {};\n    conf.default = conf.default || {};\n\n    var templatePath = path.normalize(opts.template);\n    view = new template.Template( path.join(templatePath, 'tmpl') );\n\n    // claim some special filenames in advance, so the All-Powerful Overseer of Filename Uniqueness\n    // doesn't try to hand them out later\n    var indexUrl = helper.getUniqueFilename('index');\n    // don't call registerLink() on this one! 'index' is also a valid longname\n\n    var globalUrl = helper.getUniqueFilename('global');\n    helper.registerLink('global', globalUrl);\n\n    // set up templating\n    view.layout = conf.default.layoutFile ?\n        path.getResourcePath(path.dirname(conf.default.layoutFile),\n            path.basename(conf.default.layoutFile) ) :\n        'layout.tmpl';\n\n    // set up tutorials for helper\n    helper.setTutorials(tutorials);\n\n    data = helper.prune(data);\n    data.sort('longname, version, since');\n    helper.addEventListeners(data);\n\n    var sourceFiles = {};\n    var sourceFilePaths = [];\n    data().each(function(doclet) {\n         doclet.attribs = '';\n\n        if (doclet.examples) {\n            doclet.examples = doclet.examples.map(function(example) {\n                var caption, code;\n\n                if (example.match(/^\\s*<caption>([\\s\\S]+?)<\\/caption>(\\s*[\\n\\r])([\\s\\S]+)$/i)) {\n                    caption = RegExp.$1;\n                    code = RegExp.$3;\n                }\n\n                return {\n                    caption: caption || '',\n                    code: code || example\n                };\n            });\n        }\n        if (doclet.see) {\n            doclet.see.forEach(function(seeItem, i) {\n                doclet.see[i] = hashToLink(doclet, seeItem);\n            });\n        }\n\n        // build a list of source files\n        var sourcePath;\n        if (doclet.meta) {\n            sourcePath = getPathFromDoclet(doclet);\n            sourceFiles[sourcePath] = {\n                resolved: sourcePath,\n                shortened: null\n            };\n            if (sourceFilePaths.indexOf(sourcePath) === -1) {\n                sourceFilePaths.push(sourcePath);\n            }\n        }\n    });\n\n    // update outdir if necessary, then create outdir\n    var packageInfo = ( find({kind: 'package'}) || [] ) [0];\n    if (packageInfo && packageInfo.name) {\n        outdir = path.join( outdir, packageInfo.name, (packageInfo.version || '') );\n    }\n    fs.mkPath(outdir);\n\n    // copy the template's static files to outdir\n    var fromDir = path.join(templatePath, 'static');\n    var staticFiles = fs.ls(fromDir, 3);\n\n    staticFiles.forEach(function(fileName) {\n        var toDir = fs.toDir( fileName.replace(fromDir, outdir) );\n        fs.mkPath(toDir);\n        fs.copyFileSync(fileName, toDir);\n    });\n\n    // copy user-specified static files to outdir\n    var staticFilePaths;\n    var staticFileFilter;\n    var staticFileScanner;\n    if (conf.default.staticFiles) {\n        // The canonical property name is `include`. We accept `paths` for backwards compatibility\n        // with a bug in JSDoc 3.2.x.\n        staticFilePaths = conf.default.staticFiles.include ||\n            conf.default.staticFiles.paths ||\n            [];\n        staticFileFilter = new (require('jsdoc/src/filter')).Filter(conf.default.staticFiles);\n        staticFileScanner = new (require('jsdoc/src/scanner')).Scanner();\n\n        staticFilePaths.forEach(function(filePath) {\n            var extraStaticFiles;\n\n            filePath = path.resolve(env.pwd, filePath);\n            extraStaticFiles = staticFileScanner.scan([filePath], 10, staticFileFilter);\n\n            extraStaticFiles.forEach(function(fileName) {\n                var sourcePath = fs.toDir(filePath);\n                var toDir = fs.toDir( fileName.replace(sourcePath, outdir) );\n                fs.mkPath(toDir);\n                fs.copyFileSync(fileName, toDir);\n            });\n        });\n    }\n\n    if (sourceFilePaths.length) {\n        sourceFiles = shortenPaths( sourceFiles, path.commonPrefix(sourceFilePaths) );\n    }\n    data().each(function(doclet) {\n        var url = helper.createLink(doclet);\n        helper.registerLink(doclet.longname, url);\n\n        // add a shortened version of the full path\n        var docletPath;\n        if (doclet.meta) {\n            docletPath = getPathFromDoclet(doclet);\n            docletPath = sourceFiles[docletPath].shortened;\n            if (docletPath) {\n                doclet.meta.shortpath = docletPath;\n            }\n        }\n    });\n\n    data().each(function(doclet) {\n        var url = helper.longnameToUrl[doclet.longname];\n\n        if (url.indexOf('#') > -1) {\n            doclet.id = helper.longnameToUrl[doclet.longname].split(/#/).pop();\n        }\n        else {\n            doclet.id = doclet.name;\n        }\n\n        if ( needsSignature(doclet) ) {\n            addSignatureParams(doclet);\n            addSignatureReturns(doclet);\n            addAttribs(doclet);\n        }\n    });\n\n    // do this after the urls have all been generated\n    data().each(function(doclet) {\n        doclet.ancestors = getAncestorLinks(doclet);\n\n        if (doclet.kind === 'member') {\n            addSignatureTypes(doclet);\n            addAttribs(doclet);\n        }\n\n        if (doclet.kind === 'constant') {\n            addSignatureTypes(doclet);\n            addAttribs(doclet);\n            doclet.kind = 'member';\n        }\n    });\n\n    var members = helper.getMembers(data);\n    members.tutorials = tutorials.children;\n\n    // output pretty-printed source files by default\n    var outputSourceFiles = conf.default && conf.default.outputSourceFiles !== false ? true :\n        false;\n\n    // add template helpers\n    view.find = find;\n    view.linkto = linkto;\n    view.resolveAuthorLinks = resolveAuthorLinks;\n    view.tutoriallink = tutoriallink;\n    view.htmlsafe = htmlsafe;\n    view.outputSourceFiles = outputSourceFiles;\n\n    // once for all\n    view.nav = buildNav(members);\n    attachModuleSymbols( find({ longname: {left: 'module:'} }), members.modules );\n\n    // generate the pretty-printed source files first so other pages can link to them\n    if (outputSourceFiles) {\n        generateSourceFiles(sourceFiles, opts.encoding);\n    }\n\n    if (members.globals.length) { generate('Global', [{kind: 'globalobj'}], globalUrl); }\n\n    // index page displays information from package.json and lists files\n    var files = find({kind: 'file'}),\n        packages = find({kind: 'package'});\n\n    generate('Home',\n        packages.concat(\n            [{kind: 'mainpage', readme: opts.readme, longname: (opts.mainpagetitle) ? opts.mainpagetitle : 'Main Page'}]\n        ).concat(files),\n    indexUrl);\n\n    // set up the lists that we'll use to generate pages\n    var classes = taffy(members.classes);\n    var modules = taffy(members.modules);\n    var namespaces = taffy(members.namespaces);\n    var mixins = taffy(members.mixins);\n    var externals = taffy(members.externals);\n    var interfaces = taffy(members.interfaces);\n\n    Object.keys(helper.longnameToUrl).forEach(function(longname) {\n        var myModules = helper.find(modules, {longname: longname});\n        if (myModules.length) {\n            generate('Module: ' + myModules[0].name, myModules, helper.longnameToUrl[longname]);\n        }\n\n        var myClasses = helper.find(classes, {longname: longname});\n        if (myClasses.length) {\n            generate('Class: ' + myClasses[0].name, myClasses, helper.longnameToUrl[longname]);\n        }\n\n        var myNamespaces = helper.find(namespaces, {longname: longname});\n        if (myNamespaces.length) {\n            generate('Namespace: ' + myNamespaces[0].name, myNamespaces, helper.longnameToUrl[longname]);\n        }\n\n        var myMixins = helper.find(mixins, {longname: longname});\n        if (myMixins.length) {\n            generate('Mixin: ' + myMixins[0].name, myMixins, helper.longnameToUrl[longname]);\n        }\n\n        var myExternals = helper.find(externals, {longname: longname});\n        if (myExternals.length) {\n            generate('External: ' + myExternals[0].name, myExternals, helper.longnameToUrl[longname]);\n        }\n\n        var myInterfaces = helper.find(interfaces, {longname: longname});\n        if (myInterfaces.length) {\n            generate('Interface: ' + myInterfaces[0].name, myInterfaces, helper.longnameToUrl[longname]);\n        }\n    });\n\n    // TODO: move the tutorial functions to templateHelper.js\n    function generateTutorial(title, tutorial, filename) {\n        var tutorialData = {\n            title: title,\n            header: tutorial.title,\n            content: tutorial.parse(),\n            children: tutorial.children\n        };\n\n        var tutorialPath = path.join(outdir, filename),\n            html = view.render('tutorial.tmpl', tutorialData);\n\n        // yes, you can use {@link} in tutorials too!\n        html = helper.resolveLinks(html); // turn {@link foo} into <a href=\"foodoc.html\">foo</a>\n\n        fs.writeFileSync(tutorialPath, html, 'utf8');\n    }\n\n    // tutorials can have only one parent so there is no risk for loops\n    function saveChildren(node) {\n        node.children.forEach(function(child) {\n            generateTutorial('Tutorial: ' + child.title, child, helper.tutorialToUrl(child.name));\n            saveChildren(child);\n        });\n    }\n    saveChildren(tutorials);\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/templates/haruki/publish.js":"/* eslint no-nested-ternary:0, space-infix-ops: 0 */\n/**\n    @overview Builds a tree-like JSON string from the doclet data.\n    @version 0.0.3\n    @example\n        ./jsdoc scratch/jsdoc_test.js -t templates/haruki -d console -q format=xml\n */\n'use strict';\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\nfunction graft(parentNode, childNodes, parentLongname, parentName) {\n    childNodes\n    .filter(function (element) {\n        return (element.memberof === parentLongname);\n    })\n    .forEach(function (element, index) {\n        var i,\n            len;\n\n        if (element.kind === 'namespace') {\n            if (!parentNode.namespaces) {\n                parentNode.namespaces = [];\n            }\n\n            var thisNamespace = {\n                'name': element.name,\n                'description': element.description || '',\n                'access': element.access || '',\n                'virtual': !!element.virtual\n            };\n\n            parentNode.namespaces.push(thisNamespace);\n\n            graft(thisNamespace, childNodes, element.longname, element.name);\n        }\n        else if (element.kind === 'mixin') {\n            if (!parentNode.mixins) {\n                parentNode.mixins = [];\n            }\n\n            var thisMixin = {\n                'name': element.name,\n                'description': element.description || '',\n                'access': element.access || '',\n                'virtual': !!element.virtual\n            };\n\n            parentNode.mixins.push(thisMixin);\n\n            graft(thisMixin, childNodes, element.longname, element.name);\n        }\n        else if (element.kind === 'function') {\n            if (!parentNode.functions) {\n                parentNode.functions = [];\n            }\n\n            var thisFunction = {\n                'name': element.name,\n                'access': element.access || '',\n                'virtual': !!element.virtual,\n                'description': element.description || '',\n                'parameters': [ ],\n                'examples': []\n            };\n\n            parentNode.functions.push(thisFunction);\n\n            if (element.returns) {\n                thisFunction.returns = {\n                    'type': element.returns[0].type? (element.returns[0].type.names.length === 1? element.returns[0].type.names[0] : element.returns[0].type.names) : '',\n                    'description': element.returns[0].description || ''\n                };\n            }\n\n            if (element.examples) {\n                for (i = 0, len = element.examples.length; i < len; i++) {\n                    thisFunction.examples.push(element.examples[i]);\n                }\n            }\n\n            if (element.params) {\n                for (i = 0, len = element.params.length; i < len; i++) {\n                    thisFunction.parameters.push({\n                        'name': element.params[i].name,\n                        'type': element.params[i].type? (element.params[i].type.names.length === 1? element.params[i].type.names[0] : element.params[i].type.names) : '',\n                        'description': element.params[i].description || '',\n                        'default': hasOwnProp.call(element.params[i], 'defaultvalue') ? element.params[i].defaultvalue : '',\n                        'optional': typeof element.params[i].optional === 'boolean'? element.params[i].optional : '',\n                        'nullable': typeof element.params[i].nullable === 'boolean'? element.params[i].nullable : ''\n                    });\n                }\n            }\n        }\n        else if (element.kind === 'member') {\n            if (!parentNode.properties) {\n                parentNode.properties = [];\n            }\n            parentNode.properties.push({\n                'name': element.name,\n                'access': element.access || '',\n                'virtual': !!element.virtual,\n                'description': element.description || '',\n                'type': element.type? (element.type.length === 1? element.type[0] : element.type) : ''\n            });\n        }\n\n        else if (element.kind === 'event') {\n            if (!parentNode.events) {\n                parentNode.events = [];\n            }\n\n            var thisEvent = {\n                'name': element.name,\n                'access': element.access || '',\n                'virtual': !!element.virtual,\n                'description': element.description || '',\n                'parameters': [],\n                'examples': []\n            };\n\n            parentNode.events.push(thisEvent);\n\n            if (element.returns) {\n                thisEvent.returns = {\n                    'type': element.returns.type? (element.returns.type.names.length === 1? element.returns.type.names[0] : element.returns.type.names) : '',\n                    'description': element.returns.description || ''\n                };\n            }\n\n            if (element.examples) {\n                for (i = 0, len = element.examples.length; i < len; i++) {\n                    thisEvent.examples.push(element.examples[i]);\n                }\n            }\n\n            if (element.params) {\n                for (i = 0, len = element.params.length; i < len; i++) {\n                    thisEvent.parameters.push({\n                        'name': element.params[i].name,\n                        'type': element.params[i].type? (element.params[i].type.names.length === 1? element.params[i].type.names[0] : element.params[i].type.names) : '',\n                        'description': element.params[i].description || '',\n                        'default': hasOwnProp.call(element.params[i], 'defaultvalue') ? element.params[i].defaultvalue : '',\n                        'optional': typeof element.params[i].optional === 'boolean'? element.params[i].optional : '',\n                        'nullable': typeof element.params[i].nullable === 'boolean'? element.params[i].nullable : ''\n                    });\n                }\n            }\n        }\n        else if (element.kind === 'class') {\n            if (!parentNode.classes) {\n                parentNode.classes = [];\n            }\n\n            var thisClass = {\n                'name': element.name,\n                'description': element.classdesc || '',\n                'extends': element.augments || [],\n                'access': element.access || '',\n                'virtual': !!element.virtual,\n                'fires': element.fires || '',\n                'constructor': {\n                    'name': element.name,\n                    'description': element.description || '',\n                    'parameters': [\n                    ],\n                    'examples': []\n                }\n            };\n\n            parentNode.classes.push(thisClass);\n\n            if (element.examples) {\n                for (i = 0, len = element.examples.length; i < len; i++) {\n                    thisClass.constructor.examples.push(element.examples[i]);\n                }\n            }\n\n            if (element.params) {\n                for (i = 0, len = element.params.length; i < len; i++) {\n                    thisClass.constructor.parameters.push({\n                        'name': element.params[i].name,\n                        'type': element.params[i].type? (element.params[i].type.names.length === 1? element.params[i].type.names[0] : element.params[i].type.names) : '',\n                        'description': element.params[i].description || '',\n                        'default': hasOwnProp.call(element.params[i], 'defaultvalue') ? element.params[i].defaultvalue : '',\n                        'optional': typeof element.params[i].optional === 'boolean'? element.params[i].optional : '',\n                        'nullable': typeof element.params[i].nullable === 'boolean'? element.params[i].nullable : ''\n                    });\n                }\n            }\n\n            graft(thisClass, childNodes, element.longname, element.name);\n       }\n    });\n}\n\n/**\n    @param {TAFFY} data\n    @param {object} opts\n */\nexports.publish = function(data, opts) {\n    var root = {},\n        docs;\n\n    data({undocumented: true}).remove();\n    docs = data().get(); // <-- an array of Doclet objects\n\n    graft(root, docs);\n\n    if (opts.destination === 'console') {\n        if (opts.query && opts.query.format === 'xml') {\n            var xml = require('js2xmlparser');\n            console.log( xml('jsdoc', root) );\n        }\n        else {\n            console.log( require('jsdoc/util/dumper').dump(root) );\n        }\n    }\n    else {\n        console.log('This template only supports output to the console. Use the option \"-d console\" when you run JSDoc.');\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/src/astbuilder.js":"'use strict';\n\nvar espree = require('espree');\nvar jsdoc = {\n    src: {\n        syntax: require('jsdoc/src/syntax'),\n        Walker: require('jsdoc/src/walker').Walker\n    },\n    util: {\n        logger: require('jsdoc/util/logger')\n    }\n};\nvar Syntax = jsdoc.src.syntax.Syntax;\n\nvar VISITOR_CONTINUE = true;\nvar VISITOR_STOP = false;\n\n// TODO: docs; empty array means any node type, otherwise only the node types in the array\nvar acceptsLeadingComments = (function() {\n    var accepts = {};\n\n    // these nodes always accept leading comments\n    var commentable = [\n        Syntax.ArrowFunctionExpression,\n        Syntax.AssignmentExpression,\n        Syntax.CallExpression,\n        Syntax.ClassDeclaration,\n        Syntax.ExportAllDeclaration,\n        Syntax.ExportDefaultDeclaration,\n        Syntax.ExportNamedDeclaration,\n        Syntax.ExportSpecifier,\n        Syntax.FunctionDeclaration,\n        Syntax.FunctionExpression,\n        Syntax.MemberExpression,\n        Syntax.MethodDefinition,\n        Syntax.Property,\n        Syntax.TryStatement,\n        Syntax.VariableDeclaration,\n        Syntax.VariableDeclarator,\n        Syntax.WithStatement\n    ];\n    for (var i = 0, l = commentable.length; i < l; i++) {\n        accepts[commentable[i]] = [];\n    }\n\n    // these nodes accept leading comments if they have specific types of parent nodes\n    // like: function foo(/** @type {string} */ bar) {}\n    accepts[Syntax.Identifier] = [\n        Syntax.ArrowFunctionExpression,\n        Syntax.CatchClause,\n        Syntax.FunctionDeclaration,\n        Syntax.FunctionExpression\n    ];\n    // like: function foo(/** @type {string} */ bar='baz') {}\n    accepts[Syntax.AssignmentPattern] = [\n        Syntax.ArrowFunctionExpression,\n        Syntax.FunctionDeclaration,\n        Syntax.FunctionExpression\n    ];\n    // like: function foo(/** @type {string} */ ...bar) {}\n    accepts[Syntax.RestElement] = [\n        Syntax.ArrowFunctionExpression,\n        Syntax.FunctionDeclaration,\n        Syntax.FunctionExpression\n    ];\n    // like: var Foo = Class.create(/** @lends Foo */{ // ... })\n    accepts[Syntax.ObjectExpression] = [\n        Syntax.CallExpression,\n        Syntax.Property,\n        Syntax.ReturnStatement\n    ];\n\n    return accepts;\n})();\n// exported so we can use them in tests\nvar parserOptions = exports.parserOptions = {\n    comment: true,\n    ecmaFeatures: {\n        experimentalObjectRestSpread: true,\n        globalReturn: true,\n        impliedStrict: true,\n        jsx: true\n    },\n    ecmaVersion: 7,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true\n};\n\n// TODO: docs\nfunction canAcceptComment(node) {\n    var canAccept = false;\n    var spec = acceptsLeadingComments[node.type];\n\n    if (spec) {\n        // empty array means we don't care about the parent type\n        if (spec.length === 0) {\n            canAccept = true;\n        }\n        // we can accept the comment if the spec contains the type of the node's parent\n        else if (node.parent) {\n            canAccept = spec.indexOf(node.parent.type) !== -1;\n        }\n    }\n\n    return canAccept;\n}\n\n// TODO: docs\n// check whether node1 is before node2\nfunction isBefore(beforeRange, afterRange) {\n    return beforeRange[1] <= afterRange[0];\n}\n\n// TODO: docs\nfunction isWithin(innerRange, outerRange) {\n    return innerRange[0] >= outerRange[0] && innerRange[1] <= outerRange[1];\n}\n\n// TODO: docs\nfunction isJsdocComment(comment) {\n    return comment && (comment.type === 'Block') && (comment.value[0] === '*');\n}\n\n/**\n * Add the raw comment string to a block comment node.\n *\n * @private\n * @param {!Object} comment - A comment node with `type` and `value` properties.\n */\nfunction addRawComment(comment) {\n    comment.raw = comment.raw || ('/*' + comment.value + '*/');\n    return comment;\n}\n\n// TODO: docs\nfunction scrubComments(comments) {\n    var comment;\n\n    var scrubbed = [];\n\n    for (var i = 0, l = comments.length; i < l; i++) {\n        comment = comments[i];\n        if ( isJsdocComment(comment) ) {\n            scrubbed.push( addRawComment(comment) );\n        }\n    }\n\n    return scrubbed;\n}\n\n// TODO: docs\nvar AstBuilder = exports.AstBuilder = function() {};\n\nfunction parse(source, filename) {\n    var ast;\n\n    try {\n        ast = espree.parse(source, parserOptions);\n    }\n    catch (e) {\n        jsdoc.util.logger.error('Unable to parse %s: %s', filename, e.message);\n    }\n\n    return ast;\n}\n\n// TODO: docs\nAstBuilder.prototype.build = function(source, filename) {\n    var ast = parse(source, filename);\n\n    if (ast) {\n        this._postProcess(filename, ast);\n    }\n\n    return ast;\n};\n\n// TODO: docs\nfunction atomSorter(a, b) {\n    var aRange = a.range;\n    var bRange = b.range;\n    var result = 0;\n\n    // does a end before b starts?\n    if ( isBefore(aRange, bRange) ) {\n        result = -1;\n    }\n    // does a enclose b?\n    else if ( isWithin(bRange, aRange) ) {\n        result = -1;\n    }\n    // does a start before b?\n    else if (aRange[0] < bRange[0]) {\n        result = -1;\n    }\n    // are the ranges non-identical? if so, b must be first\n    else if ( aRange[0] !== bRange[0] || aRange[1] !== bRange[1] ) {\n        result = 1;\n    }\n\n    return result;\n}\n\n// TODO: docs\n// TODO: export?\nfunction CommentAttacher(comments, tokens) {\n    this._comments = comments || [];\n    this._tokens = tokens || [];\n\n    this._tokenIndex = 0;\n    this._previousNode = null;\n    this._astRoot = null;\n\n    this._resetPendingComments()\n        ._resetCandidates();\n}\n\n// TODO: docs\nCommentAttacher.prototype._resetPendingComments = function() {\n    this._pendingComments = [];\n    this._pendingCommentRange = null;\n\n    return this;\n};\n\n// TODO: docs\nCommentAttacher.prototype._resetCandidates = function() {\n    this._candidates = [];\n\n    return this;\n};\n\n// TODO: docs\nCommentAttacher.prototype._nextComment = function() {\n    return this._comments[0] || null;\n};\n\n// TODO: docs\nCommentAttacher.prototype._nextToken = function() {\n    return this._tokens[this._tokenIndex] || null;\n};\n\n// TODO: docs\n// find the index of the atom whose end position is closest to (but not after) the specified\n// position\nCommentAttacher.prototype._nextIndexBefore = function(atoms, startIndex, position) {\n    var atom;\n\n    var newIndex = startIndex;\n\n    for (var i = newIndex, l = atoms.length; i < l; i++) {\n        atom = atoms[i];\n\n        if (atom.range[1] > position) {\n            break;\n        }\n        else {\n            newIndex = i;\n        }\n    }\n\n    return newIndex;\n};\n\n// TODO: docs\nCommentAttacher.prototype._advanceTokenIndex = function(node) {\n    var position = node.range[0];\n\n    this._tokenIndex = this._nextIndexBefore(this._tokens, this._tokenIndex, position);\n\n    return this;\n};\n\n// TODO: docs\nCommentAttacher.prototype._fastForwardComments = function(node) {\n    var position = node.range[0];\n    var commentIndex = this._nextIndexBefore(this._comments, 0, position);\n\n    // all comments before the node (except the last one) are pended\n    if (commentIndex > 0) {\n        this._pendingComments = this._pendingComments.concat( this._comments.splice(0,\n            commentIndex) );\n    }\n};\n\nCommentAttacher.prototype._attachPendingCommentsAsLeading = function(target) {\n    target.leadingComments = (target.leadingComments || []).concat(this._pendingComments);\n};\n\nCommentAttacher.prototype._attachPendingCommentsAsTrailing = function(target) {\n    target.trailingComments = (target.trailingComments || []).concat(this._pendingComments);\n};\n\n// TODO: docs\nCommentAttacher.prototype._attachPendingComments = function(currentNode) {\n    var target;\n\n    if (!this._pendingComments.length) {\n        return this;\n    }\n\n    // if there are one or more candidate nodes, attach the pending comments before the last\n    // candidate node\n    if (this._candidates.length > 0) {\n        target = this._candidates[this._candidates.length - 1];\n        this._attachPendingCommentsAsLeading(target);\n    }\n    // if we don't have a previous node, attach pending comments before the AST root; this should\n    // mean that we haven't encountered any other nodes yet, or that the source file contains\n    // JSDoc comments but not code\n    else if (!this._previousNode) {\n        target = this._astRoot;\n        this._attachPendingCommentsAsLeading(target);\n    }\n    // otherwise, the comments must come after the current node (or the last node of the AST, if\n    // we've run out of nodes)\n    else {\n        this._attachPendingCommentsAsTrailing(currentNode || this._previousNode);\n    }\n\n    // update the previous node\n    this._previousNode = currentNode;\n\n    this._resetPendingComments()\n        ._resetCandidates();\n\n    return this;\n};\n\n// TODO: docs\nCommentAttacher.prototype._isEligible = function(node) {\n    var atoms;\n    var token;\n\n    var isEligible = false;\n\n    var comment = this._nextComment();\n    if (comment) {\n        atoms = [node, comment];\n        token = this._nextToken();\n        if (token) {\n            atoms.push(token);\n        }\n\n        atoms.sort(atomSorter);\n\n        // a candidate node must immediately follow the comment\n        if (atoms.indexOf(node) === atoms.indexOf(comment) + 1) {\n            isEligible = true;\n        }\n    }\n\n    return isEligible;\n};\n\n// TODO: docs\n// TODO: do we ever get multiple candidate nodes?\nCommentAttacher.prototype.visit = function(node) {\n    var isEligible;\n\n    // bail if we're out of comments\n    if ( !this._nextComment() ) {\n        return VISITOR_STOP;\n    }\n\n    // set the AST root if necessary\n    this._astRoot = this._astRoot || node;\n\n    // move to the next token, and fast-forward past comments that can no longer be attached\n    this._advanceTokenIndex(node);\n    this._fastForwardComments(node);\n    // now we can check whether the current node is in the right position to accept the next comment\n    isEligible = this._isEligible(node);\n\n    // attach the pending comments, if any\n    this._attachPendingComments(node);\n\n    // okay, now that we've done all that bookkeeping, we can check whether the current node accepts\n    // leading comments and add it to the candidate list if needed\n    if ( isEligible && canAcceptComment(node) ) {\n        // make sure we don't go past the end of the outermost target node\n        if (!this._pendingCommentRange) {\n            this._pendingCommentRange = node.range.slice(0);\n        }\n        this._candidates.push(node);\n\n        // we have a candidate node, so pend the current comment\n        this._pendingComments.push(this._comments.splice(0, 1)[0]);\n    }\n\n    return VISITOR_CONTINUE;\n};\n\n// TODO: docs\nCommentAttacher.prototype.finish = function() {\n    var length = this._comments.length;\n\n    // any leftover comments are pended\n    if (length) {\n        this._pendingComments = this._pendingComments.concat( this._comments.splice(0, length) );\n    }\n\n    // attach the pending comments, if any\n    this._attachPendingComments();\n};\n\n// TODO: docs\n// TODO: refactor to make this extensible\n/**\n * @private\n * @param {string} filename - The full path to the source file.\n * @param {Object} ast - An abstract syntax tree that conforms to the Mozilla Parser API.\n */\nAstBuilder.prototype._postProcess = function(filename, ast) {\n    var attachComments = !!ast.comments && !!ast.comments.length;\n    var commentAttacher;\n    var scrubbed;\n    var visitor;\n    var walker;\n\n    if (!attachComments) {\n        return;\n    }\n\n    scrubbed = scrubComments(ast.comments.slice(0));\n    commentAttacher = new CommentAttacher(scrubbed.slice(0), ast.tokens);\n    visitor = {\n        visit: function(node) {\n            return commentAttacher.visit(node);\n        }\n    };\n    walker = new jsdoc.src.Walker();\n\n    walker.recurse(ast, visitor, filename);\n\n    commentAttacher.finish();\n\n    // replace the comments with the filtered comments\n    ast.comments = scrubbed;\n    // we no longer need the tokens\n    ast.tokens = [];\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/src/astnode.js":"// TODO: docs\n/** @module jsdoc/src/astnode */\n'use strict';\n\nvar cast = require('jsdoc/util/cast').cast;\nvar env = require('jsdoc/env');\nvar name = require('jsdoc/name');\nvar Syntax = require('jsdoc/src/syntax').Syntax;\nvar util = require('util');\n\n// Counter for generating unique node IDs.\nvar uid = 100000000;\n\n/**\n * Check whether an AST node represents a function.\n *\n * @alias module:jsdoc/src/astnode.isFunction\n * @param {(Object|string)} node - The AST node to check, or the `type` property of a node.\n * @return {boolean} Set to `true` if the node is a function or `false` in all other cases.\n */\nvar isFunction = exports.isFunction = function(node) {\n    var type;\n\n    if (!node) {\n        return false;\n    }\n\n    if (typeof node === 'string') {\n        type = node;\n    }\n    else {\n        type = node.type;\n    }\n\n    return type === Syntax.FunctionDeclaration || type === Syntax.FunctionExpression ||\n        type === Syntax.MethodDefinition || type === Syntax.ArrowFunctionExpression;\n};\n\n/**\n * Check whether an AST node creates a new scope.\n *\n * @alias module:jsdoc/src/astnode.isScope\n * @param {Object} node - The AST node to check.\n * @return {Boolean} Set to `true` if the node creates a new scope, or `false` in all other cases.\n */\nvar isScope = exports.isScope = function(node) {\n    // TODO: handle blocks with \"let\" declarations\n    return !!node && typeof node === 'object' && ( node.type === Syntax.CatchClause ||\n        isFunction(node) );\n};\n\n// TODO: docs\nvar addNodeProperties = exports.addNodeProperties = function(node) {\n    var debugEnabled = !!env.opts.debug;\n    var newProperties = {};\n\n    if (!node || typeof node !== 'object') {\n        return null;\n    }\n\n    if (!node.nodeId) {\n        newProperties.nodeId = {\n            value: 'astnode' + uid++,\n            enumerable: debugEnabled\n        };\n    }\n\n    if (!node.parent && node.parent !== null) {\n        newProperties.parent = {\n            // `null` means 'no parent', so use `undefined` for now\n            value: undefined,\n            writable: true\n        };\n    }\n\n    if (!node.enclosingScope && node.enclosingScope !== null) {\n        newProperties.enclosingScope = {\n            // `null` means 'no enclosing scope', so use `undefined` for now\n            value: undefined,\n            writable: true\n        };\n    }\n\n    if (debugEnabled && typeof node.parentId === 'undefined') {\n        newProperties.parentId = {\n            enumerable: true,\n            get: function() {\n                return this.parent ? this.parent.nodeId : null;\n            }\n        };\n    }\n\n    if (debugEnabled && typeof node.enclosingScopeId === 'undefined') {\n        newProperties.enclosingScopeId = {\n            enumerable: true,\n            get: function() {\n                return this.enclosingScope ? this.enclosingScope.nodeId : null;\n            }\n        };\n    }\n\n    Object.defineProperties(node, newProperties);\n\n    return node;\n};\n\n// TODO: docs\nvar nodeToValue = exports.nodeToValue = function(node) {\n    var parent;\n    var str;\n    var tempObject;\n\n    switch (node.type) {\n        case Syntax.ArrayExpression:\n            tempObject = [];\n            node.elements.forEach(function(el, i) {\n                // handle sparse arrays. use `null` to represent missing values, consistent with\n                // JSON.stringify([,]).\n                if (!el) {\n                    tempObject[i] = null;\n                }\n                else {\n                    tempObject[i] = nodeToValue(el);\n                }\n            });\n\n            str = JSON.stringify(tempObject);\n            break;\n\n        case Syntax.AssignmentExpression:\n            // falls through\n\n        case Syntax.AssignmentPattern:\n            str = nodeToValue(node.left);\n            break;\n\n        case Syntax.ClassDeclaration:\n            str = nodeToValue(node.id);\n            break;\n\n        case Syntax.ExportAllDeclaration:\n            // falls through\n\n        case Syntax.ExportDefaultDeclaration:\n            str = 'module.exports';\n            break;\n\n        case Syntax.ExportNamedDeclaration:\n            if (node.declaration) {\n                // like `var` in: export var foo = 'bar';\n                // we need a single value, so we use the first variable name\n                if (node.declaration.declarations) {\n                    str = 'exports.' + nodeToValue(node.declaration.declarations[0]);\n                }\n                else {\n                    str = 'exports.' + nodeToValue(node.declaration);\n                }\n            }\n\n            // otherwise we'll use the ExportSpecifier nodes\n            break;\n\n        case Syntax.ExportSpecifier:\n            str = 'exports.' + nodeToValue(node.exported);\n            break;\n\n        case Syntax.ArrowFunctionExpression:\n            // falls through\n\n        case Syntax.FunctionDeclaration:\n            // falls through\n\n        case Syntax.FunctionExpression:\n            if (node.id && node.id.name) {\n                str = node.id.name;\n            }\n            break;\n\n        case Syntax.Identifier:\n            str = node.name;\n            break;\n\n        case Syntax.Literal:\n            str = node.value;\n            break;\n\n        case Syntax.MemberExpression:\n            // could be computed (like foo['bar']) or not (like foo.bar)\n            str = nodeToValue(node.object);\n            if (node.computed) {\n                str += util.format('[%s]', node.property.raw);\n            }\n            else {\n                str += '.' + nodeToValue(node.property);\n            }\n            break;\n\n        case Syntax.MethodDefinition:\n            parent = node.parent.parent;\n            // for class expressions, we want the name of the variable the class is assigned to\n            if (parent.type === Syntax.ClassExpression) {\n                str = nodeToValue(parent.parent);\n            }\n            // for the constructor of a module's default export, use a special name\n            else if (node.kind === 'constructor' && parent.parent &&\n                parent.parent.type === Syntax.ExportDefaultDeclaration) {\n                str = 'module.exports';\n            }\n            // if the method is a member of a module's default export, ignore the name, because it's\n            // irrelevant\n            else if (parent.parent && parent.parent.type === Syntax.ExportDefaultDeclaration) {\n                str = '';\n            }\n            // otherwise, use the class's name\n            else {\n                str = parent.id ? nodeToValue(parent.id) : '';\n            }\n\n            if (node.kind !== 'constructor') {\n                if (str) {\n                    str += node.static ? name.SCOPE.PUNC.STATIC : name.SCOPE.PUNC.INSTANCE;\n                }\n                str += nodeToValue(node.key);\n            }\n            break;\n\n        case Syntax.ObjectExpression:\n            tempObject = {};\n            node.properties.forEach(function(prop) {\n                // ExperimentalSpreadProperty have no key\n                // like var hello = {...hi};\n                if (!prop.key) {\n                    return;\n                }\n\n                var key = prop.key.name;\n                // preserve literal values so that the JSON form shows the correct type\n                if (prop.value.type === Syntax.Literal) {\n                    tempObject[key] = prop.value.value;\n                }\n                else {\n                    tempObject[key] = nodeToValue(prop);\n                }\n            });\n\n            str = JSON.stringify(tempObject);\n            break;\n\n        case Syntax.RestElement:\n            str = nodeToValue(node.argument);\n            break;\n\n        case Syntax.ThisExpression:\n            str = 'this';\n            break;\n\n        case Syntax.UnaryExpression:\n            // like -1. in theory, operator can be prefix or postfix. in practice, any value with a\n            // valid postfix operator (such as -- or ++) is not a UnaryExpression.\n            str = nodeToValue(node.argument);\n\n            if (node.prefix === true) {\n                str = cast(node.operator + str);\n            }\n            else {\n                // this shouldn't happen\n                throw new Error( util.format('Found a UnaryExpression with a postfix operator: %j',\n                    node) );\n            }\n            break;\n\n        case Syntax.VariableDeclarator:\n            str = nodeToValue(node.id);\n            break;\n\n        default:\n            str = '';\n    }\n\n    return str;\n};\n\n// backwards compatibility\nexports.nodeToString = nodeToValue;\n\n// TODO: docs\nvar getParamNames = exports.getParamNames = function(node) {\n    var params;\n\n    if (!node || !node.params) {\n        return [];\n    }\n\n    params = node.params.slice(0);\n\n    return params.map(function(param) {\n        return nodeToValue(param);\n    });\n};\n\n// TODO: docs\nvar isAccessor = exports.isAccessor = function(node) {\n    return !!node && typeof node === 'object' &&\n        (node.type === Syntax.Property || node.type === Syntax.MethodDefinition) &&\n        (node.kind === 'get' || node.kind === 'set');\n};\n\n// TODO: docs\nvar isAssignment = exports.isAssignment = function(node) {\n    return !!node && typeof node === 'object' && (node.type === Syntax.AssignmentExpression ||\n        node.type === Syntax.VariableDeclarator);\n};\n\n// TODO: docs\n/**\n * Retrieve information about the node, including its name and type.\n * @alias module:jsdoc/src/astnode.getInfo\n */\nvar getInfo = exports.getInfo = function(node) {\n    var info = {};\n\n    switch (node.type) {\n        // like the function in: \"var foo = () => {}\"\n        case Syntax.ArrowFunctionExpression:\n            info.node = node;\n            info.name = '';\n            info.type = info.node.type;\n            info.paramnames = getParamNames(node);\n            break;\n\n        // like: \"foo = 'bar'\" (after declaring foo)\n        // like: \"MyClass.prototype.myMethod = function() {}\" (after declaring MyClass)\n        case Syntax.AssignmentExpression:\n            info.node = node.right;\n            info.name = nodeToValue(node.left);\n            info.type = info.node.type;\n            info.value = nodeToValue(info.node);\n            // if the assigned value is a function, we need to capture the parameter names here\n            info.paramnames = getParamNames(node.right);\n            break;\n\n        // like \"bar='baz'\" in: function foo(bar='baz') {}\n        case Syntax.AssignmentPattern:\n            info.node = node;\n            info.name = nodeToValue(node.left);\n            info.type = info.node.type;\n            info.value = nodeToValue(info.node);\n\n            break;\n\n        // like:          \"class Foo {}\"\n        // or \"class\" in: \"export default class {}\"\n        case Syntax.ClassDeclaration:\n            info.node = node;\n            // if this class is the default export, we need to use a special name\n            if (node.parent && node.parent.type === Syntax.ExportDefaultDeclaration) {\n                info.name = 'module.exports';\n            }\n            else {\n                info.name = node.id ? nodeToValue(node.id) : '';\n            }\n            info.type = info.node.type;\n            info.paramnames = [];\n\n            node.body.body.some(function(definition) {\n                if (definition.kind === 'constructor') {\n                    info.paramnames = getParamNames(definition.value);\n                    return true;\n                }\n                return false;\n            });\n\n            break;\n\n        // like: \"export * from 'foo'\"\n        case Syntax.ExportAllDeclaration:\n            info.node = node;\n            info.name = nodeToValue(info.node);\n            info.type = info.node.type;\n            break;\n\n        // like: \"export default 'foo'\"\n        case Syntax.ExportDefaultDeclaration:\n            info.node = node.declaration;\n            info.name = nodeToValue(node);\n            info.type = info.node.type;\n\n            if ( isFunction(info.node) ) {\n                info.paramnames = getParamNames(info.node);\n            }\n\n            break;\n\n        // like: \"export var foo;\" (has declaration)\n        // or:   \"export {foo}\" (no declaration)\n        case Syntax.ExportNamedDeclaration:\n            info.node = node;\n            info.name = nodeToValue(info.node);\n            info.type = info.node.declaration ? info.node.declaration.type :\n                Syntax.ObjectExpression;\n\n            if (info.node.declaration) {\n                if ( isFunction(info.node.declaration) ) {\n                    info.paramnames = getParamNames(info.node.declaration);\n                }\n\n                // TODO: This duplicates logic for another node type in\n                // visitor.makeSymbolFoundEvent(). Is there a way to combine the logic for both\n                // node types into a single module?\n                if (info.node.declaration.kind === 'const') {\n                    info.kind = 'constant';\n                }\n            }\n\n            break;\n\n        // like \"foo as bar\" in: \"export {foo as bar}\"\n        case Syntax.ExportSpecifier:\n            info.node = node;\n            info.name = nodeToValue(info.node);\n            info.type = info.node.local.type;\n\n            if ( isFunction(info.node.local) ) {\n                info.paramnames = getParamNames(info.node.local);\n            }\n\n            break;\n\n        // like: \"function foo() {}\"\n        // or the function in: \"export default function() {}\"\n        case Syntax.FunctionDeclaration:\n            info.node = node;\n            info.name = node.id ? nodeToValue(node.id) : '';\n            info.type = info.node.type;\n            info.paramnames = getParamNames(node);\n            break;\n\n        // like the function in: \"var foo = function() {}\"\n        case Syntax.FunctionExpression:\n            info.node = node;\n            // TODO: should we add a name for, e.g., \"var foo = function bar() {}\"?\n            info.name = '';\n            info.type = info.node.type;\n            info.paramnames = getParamNames(node);\n            break;\n\n        // like the param \"bar\" in: \"function foo(bar) {}\"\n        case Syntax.Identifier:\n            info.node = node;\n            info.name = nodeToValue(info.node);\n            info.type = info.node.type;\n            break;\n\n        // like \"a.b.c\"\n        case Syntax.MemberExpression:\n            info.node = node;\n            info.name = nodeToValue(info.node);\n            info.type = info.node.type;\n            break;\n\n        // like: \"foo() {}\"\n        case Syntax.MethodDefinition:\n            info.node = node;\n            info.name = nodeToValue(info.node);\n            info.type = info.node.type;\n            info.paramnames = getParamNames(node.value);\n            break;\n\n        // like \"a: 0\" in \"var foo = {a: 0}\"\n        case Syntax.Property:\n            info.node = node.value;\n            info.name = nodeToValue(node.key);\n            info.value = nodeToValue(info.node);\n\n            // property names with unsafe characters must be quoted\n            if ( !/^[$_a-zA-Z0-9]*$/.test(info.name) ) {\n                info.name = '\"' + String(info.name).replace(/\"/g, '\\\\\"') + '\"';\n            }\n\n            if ( isAccessor(node) ) {\n                info.type = nodeToValue(info.node);\n                info.paramnames = getParamNames(info.node);\n            }\n            else {\n                info.type = info.node.type;\n            }\n\n            break;\n\n        // like \"...bar\" in: function foo(...bar) {}\n        case Syntax.RestElement:\n            info.node = node;\n            info.name = nodeToValue(info.node.argument);\n            info.type = info.node.type;\n\n            break;\n\n        // like: \"var i = 0\" (has init property)\n        // like: \"var i\" (no init property)\n        case Syntax.VariableDeclarator:\n            info.node = node.init || node.id;\n            info.name = node.id.name;\n\n            if (node.init) {\n                info.type = info.node.type;\n                info.value = nodeToValue(info.node);\n            }\n\n            break;\n\n        default:\n            info.node = node;\n            info.type = info.node.type;\n    }\n\n    return info;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/src/handlers.js":"/**\n * @module jsdoc/src/handlers\n */\n'use strict';\n\nvar escape = require('escape-string-regexp');\nvar jsdoc = {\n    doclet: require('jsdoc/doclet'),\n    name: require('jsdoc/name'),\n    src: {\n        syntax: require('jsdoc/src/syntax')\n    },\n    util: {\n        logger: require('jsdoc/util/logger')\n    }\n};\nvar util = require('util');\n\nvar currentModule = null;\nvar SCOPE_NAMES = jsdoc.name.SCOPE.NAMES;\nvar SCOPE_PUNC = jsdoc.name.SCOPE.PUNC;\nvar Syntax = jsdoc.src.syntax.Syntax;\n\nfunction CurrentModule(doclet) {\n    this.doclet = doclet;\n    this.longname = doclet.longname;\n    this.originalName = doclet.meta.code.name || '';\n}\n\nfunction filterByLongname(doclet) {\n    // you can't document prototypes\n    if ( /#$/.test(doclet.longname) ) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction createDoclet(comment, e) {\n    var doclet;\n    var err;\n\n    try {\n        doclet = new jsdoc.doclet.Doclet(comment, e);\n    }\n    catch (error) {\n        err = new Error( util.format('cannot create a doclet for the comment \"%s\": %s',\n            comment.replace(/[\\r\\n]/g, ''), error.message) );\n        jsdoc.util.logger.error(err);\n        doclet = new jsdoc.doclet.Doclet('', e);\n    }\n\n    return doclet;\n}\n\n/**\n * Create a doclet for a `symbolFound` event. The doclet represents an actual symbol that is defined\n * in the code.\n *\n * Here's why this function is useful. A JSDoc comment can define a symbol name by including:\n *\n * + A `@name` tag\n * + Another tag that accepts a name, such as `@function`\n *\n * When the JSDoc comment defines a symbol name, we treat it as a \"virtual comment\" for a symbol\n * that isn't actually present in the code. And if a virtual comment is attached to a symbol, it's\n * possible that the comment and symbol have nothing to do with one another.\n *\n * To handle this case, this function checks the new doclet to see if we've already added a name\n * property by parsing the JSDoc comment. If so, this method creates a replacement doclet that\n * ignores the attached JSDoc comment and only looks at the code.\n *\n * @private\n */\nfunction createSymbolDoclet(comment, e) {\n    var doclet = createDoclet(comment, e);\n\n    if (doclet.name) {\n        // try again, without the comment\n        e.comment = '@undocumented';\n        doclet = createDoclet(e.comment, e);\n    }\n\n    return doclet;\n}\n\nfunction setCurrentModule(doclet) {\n    if (doclet.kind === 'module') {\n        currentModule = new CurrentModule(doclet);\n    }\n}\n\nfunction setModuleScopeMemberOf(doclet) {\n    // handle module symbols that are _not_ assigned to module.exports\n    if (currentModule && currentModule.longname !== doclet.name) {\n        if (!doclet.scope) {\n            // is this a method definition? if so, get the scope from the node directly\n            if (doclet.meta && doclet.meta.code && doclet.meta.code.node &&\n                doclet.meta.code.node.type === Syntax.MethodDefinition) {\n                if (doclet.meta.code.node.static) {\n                    doclet.addTag('static');\n                }\n                else {\n                    doclet.addTag('instance');\n                }\n            }\n            // otherwise, it must be an inner member\n            else {\n                doclet.addTag('inner');\n            }\n        }\n\n        // if the doclet isn't a memberof anything yet, and it's not a global, it must be a memberof\n        // the current module\n        if (!doclet.memberof && doclet.scope !== SCOPE_NAMES.GLOBAL) {\n            doclet.addTag('memberof', currentModule.longname);\n        }\n    }\n}\n\nfunction setDefaultScope(doclet) {\n    // module doclets don't get a default scope\n    if (!doclet.scope && doclet.kind !== 'module') {\n        doclet.setScope(SCOPE_NAMES.GLOBAL);\n    }\n}\n\nfunction addDoclet(parser, newDoclet) {\n    var e;\n    if (newDoclet) {\n        setCurrentModule(newDoclet);\n        e = { doclet: newDoclet };\n        parser.emit('newDoclet', e);\n\n        if ( !e.defaultPrevented && !filterByLongname(e.doclet) ) {\n            parser.addResult(e.doclet);\n        }\n    }\n}\n\nfunction processAlias(parser, doclet, astNode) {\n    var memberofName;\n\n    if (doclet.alias === '{@thisClass}') {\n        memberofName = parser.resolveThis(astNode);\n\n        // \"class\" refers to the owner of the prototype, not the prototype itself\n        if ( /^(.+?)(\\.prototype|#)$/.test(memberofName) ) {\n            memberofName = RegExp.$1;\n        }\n        doclet.alias = memberofName;\n    }\n\n    doclet.addTag('name', doclet.alias);\n    doclet.postProcess();\n}\n\n// TODO: separate code that resolves `this` from code that resolves the module object\nfunction findSymbolMemberof(parser, doclet, astNode, nameStartsWith, trailingPunc) {\n    var memberof = '';\n    var nameAndPunc;\n    var scopePunc = '';\n\n    // handle computed properties like foo['bar']\n    if (trailingPunc === '[') {\n        // we don't know yet whether the symbol is a static or instance member\n        trailingPunc = null;\n    }\n\n    nameAndPunc = nameStartsWith + (trailingPunc || '');\n\n    // remove stuff that indicates module membership (but don't touch the name `module.exports`,\n    // which identifies the module object itself)\n    if (doclet.name !== 'module.exports') {\n        doclet.name = doclet.name.replace(nameAndPunc, '');\n    }\n\n    // like `bar` in:\n    //   exports.bar = 1;\n    //   module.exports.bar = 1;\n    //   module.exports = MyModuleObject; MyModuleObject.bar = 1;\n    if (nameStartsWith !== 'this' && currentModule && doclet.name !== 'module.exports') {\n        memberof = currentModule.longname;\n        scopePunc = SCOPE_PUNC.STATIC;\n    }\n    // like: module.exports = 1;\n    else if (doclet.name === 'module.exports' && currentModule) {\n        doclet.addTag('name', currentModule.longname);\n        doclet.postProcess();\n    }\n    else {\n        memberof = parser.resolveThis(astNode);\n\n        // like the following at the top level of a module:\n        //   this.foo = 1;\n        if (nameStartsWith === 'this' && currentModule && !memberof) {\n            memberof = currentModule.longname;\n            scopePunc = SCOPE_PUNC.STATIC;\n        }\n        else {\n            scopePunc = SCOPE_PUNC.INSTANCE;\n        }\n    }\n\n    return {\n        memberof: memberof,\n        scopePunc: scopePunc\n    };\n}\n\nfunction addSymbolMemberof(parser, doclet, astNode) {\n    var basename;\n    var memberof;\n    var memberofInfo;\n    var moduleOriginalName = '';\n    var resolveTargetRegExp;\n    var scopePunc;\n    var unresolved;\n\n    if (!astNode) {\n        return;\n    }\n\n    // check to see if the doclet name is an unresolved reference to the module object, or to `this`\n    // TODO: handle cases where the module object is shadowed in the current scope\n    if (currentModule) {\n        moduleOriginalName = '|' + currentModule.originalName;\n    }\n    resolveTargetRegExp = new RegExp('^((?:module.)?exports|this' + moduleOriginalName +\n        ')(\\\\.|\\\\[|$)');\n    unresolved = resolveTargetRegExp.exec(doclet.name);\n\n    if (unresolved) {\n        memberofInfo = findSymbolMemberof(parser, doclet, astNode, unresolved[1], unresolved[2]);\n        memberof = memberofInfo.memberof;\n        scopePunc = memberofInfo.scopePunc;\n\n        if (memberof) {\n            doclet.name = doclet.name ?\n                memberof + scopePunc + doclet.name :\n                memberof;\n        }\n    }\n    else {\n        memberofInfo = parser.astnodeToMemberof(astNode);\n        basename = memberofInfo.basename;\n        memberof = memberofInfo.memberof;\n    }\n\n    // if we found a memberof name, apply it to the doclet\n    if (memberof) {\n        doclet.addTag('memberof', memberof);\n        if (basename) {\n            doclet.name = (doclet.name || '')\n                .replace(new RegExp('^' + escape(basename) + '.'), '');\n        }\n    }\n    // otherwise, add the defaults for a module (if we're currently in a module)\n    else {\n        setModuleScopeMemberOf(doclet);\n    }\n}\n\nfunction newSymbolDoclet(parser, docletSrc, e) {\n    var memberofName = null;\n    var newDoclet = createSymbolDoclet(docletSrc, e);\n\n    // if there's an alias, use that as the symbol name\n    if (newDoclet.alias) {\n        processAlias(parser, newDoclet, e.astnode);\n    }\n    // otherwise, get the symbol name from the code\n    else if (e.code && typeof e.code.name !== 'undefined' && e.code.name !== '') {\n        newDoclet.addTag('name', e.code.name);\n        if (!newDoclet.memberof) {\n            addSymbolMemberof(parser, newDoclet, e.astnode);\n        }\n\n        newDoclet.postProcess();\n    }\n    else {\n        return false;\n    }\n\n    // set the scope to global unless any of the following are true:\n    // a) the doclet is a memberof something\n    // b) the doclet represents a module\n    // c) we're in a module that exports only this symbol\n    if ( !newDoclet.memberof && newDoclet.kind !== 'module' &&\n        (!currentModule || currentModule.longname !== newDoclet.name) ) {\n        newDoclet.scope = SCOPE_NAMES.GLOBAL;\n    }\n\n    // handle cases where the doclet kind is auto-detected from the node type\n    if (e.code.kind && newDoclet.kind === 'member') {\n        newDoclet.kind = e.code.kind;\n    }\n\n    addDoclet(parser, newDoclet);\n    e.doclet = newDoclet;\n\n    return true;\n}\n\n/**\n * Attach these event handlers to a particular instance of a parser.\n * @param parser\n */\nexports.attachTo = function(parser) {\n    // Handle JSDoc \"virtual comments\" that include one of the following:\n    // + A `@name` tag\n    // + Another tag that accepts a name, such as `@function`\n    parser.on('jsdocCommentFound', function(e) {\n        var comments = e.comment.split(/@also\\b/g);\n        var newDoclet;\n\n        for (var i = 0, l = comments.length; i < l; i++) {\n            newDoclet = createDoclet(comments[i], e);\n\n            // we're only interested in virtual comments here\n            if (!newDoclet.name) {\n                continue;\n            }\n\n            // add the default scope/memberof for a module (if we're in a module)\n            setModuleScopeMemberOf(newDoclet);\n            newDoclet.postProcess();\n\n            // if we _still_ don't have a scope, use the default\n            setDefaultScope(newDoclet);\n\n            addDoclet(parser, newDoclet);\n\n            e.doclet = newDoclet;\n        }\n    });\n\n    // Handle named symbols in the code. May or may not have a JSDoc comment attached.\n    parser.on('symbolFound', function(e) {\n        var comments = e.comment.split(/@also\\b/g);\n\n        for (var i = 0, l = comments.length; i < l; i++) {\n            newSymbolDoclet(parser, comments[i], e);\n        }\n    });\n\n    parser.on('fileComplete', function(e) {\n        currentModule = null;\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/src/parser.js":"/**\n * @module jsdoc/src/parser\n */\n'use strict';\n\nvar events = require('events');\nvar fs = require('jsdoc/fs');\nvar jsdoc = {\n    doclet: require('jsdoc/doclet'),\n    env: require('jsdoc/env'),\n    name: require('jsdoc/name'),\n    src: {\n        astnode: require('jsdoc/src/astnode'),\n        syntax: require('jsdoc/src/syntax')\n    },\n    util: {\n        doop: require('jsdoc/util/doop')\n    }\n};\nvar logger = require('jsdoc/util/logger');\nvar path = require('jsdoc/path');\nvar util = require('util');\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\nvar Syntax = jsdoc.src.syntax.Syntax;\n\n// TODO: docs\nvar PARSERS = exports.PARSERS = {\n    js: 'jsdoc/src/parser'\n};\n/* eslint-disable no-script-url */\n// Prefix for JavaScript strings that were provided in lieu of a filename.\nvar SCHEMA = 'javascript:';\n/* eslint-enable no-script-url */\n\nfunction DocletCache() {\n    this._doclets = {};\n}\n\nDocletCache.prototype.get = function(name) {\n    if ( !hasOwnProp.call(this._doclets, name) ) {\n        return null;\n    }\n\n    // always return the most recent doclet\n    return this._doclets[name][this._doclets[name].length - 1];\n};\n\nDocletCache.prototype.put = function(name, value) {\n    if ( !hasOwnProp.call(this._doclets, name) ) {\n        this._doclets[name] = [];\n    }\n\n    this._doclets[name].push(value);\n};\n\n// TODO: docs\nexports.createParser = function(type) {\n    var modulePath;\n\n    if (!type) {\n        /* istanbul ignore next */\n        type = 'js';\n    }\n\n    if (hasOwnProp.call(PARSERS, type)) {\n        modulePath = PARSERS[type];\n    }\n    else {\n        logger.fatal('The parser type \"%s\" is not recognized.', type);\n        return null;\n    }\n\n    return new ( require(modulePath) ).Parser();\n};\n\n// TODO: docs\n/**\n * @class\n * @alias module:jsdoc/src/parser.Parser\n * @mixes module:events.EventEmitter\n *\n * @example <caption>Create a new parser.</caption>\n * var jsdocParser = new (require('jsdoc/src/parser').Parser)();\n */\nvar Parser = exports.Parser = function(builderInstance, visitorInstance, walkerInstance) {\n    this.clear();\n\n    this._astBuilder = builderInstance || new (require('jsdoc/src/astbuilder')).AstBuilder();\n    this._visitor = visitorInstance || new (require('jsdoc/src/visitor')).Visitor();\n    this._walker = walkerInstance || new (require('jsdoc/src/walker')).Walker();\n\n    this._visitor.setParser(this);\n\n    Object.defineProperties(this, {\n        astBuilder: {\n            get: function() {\n                return this._astBuilder;\n            }\n        },\n        visitor: {\n            get: function() {\n                return this._visitor;\n            }\n        },\n        walker: {\n            get: function() {\n                return this._walker;\n            }\n        }\n    });\n};\nutil.inherits(Parser, events.EventEmitter);\n\n// TODO: docs\nParser.prototype.clear = function() {\n    this._resultBuffer = [];\n    this._byNodeId = new DocletCache();\n    this._byLongname = new DocletCache();\n    this._byLongname.put(jsdoc.name.LONGNAMES.GLOBAL, {\n        meta: {}\n    });\n};\n\n// TODO: update docs\n/**\n * Parse the given source files for JSDoc comments.\n * @param {Array.<string>} sourceFiles An array of filepaths to the JavaScript sources.\n * @param {string} [encoding=utf8]\n *\n * @fires module:jsdoc/src/parser.Parser.parseBegin\n * @fires module:jsdoc/src/parser.Parser.fileBegin\n * @fires module:jsdoc/src/parser.Parser.jsdocCommentFound\n * @fires module:jsdoc/src/parser.Parser.symbolFound\n * @fires module:jsdoc/src/parser.Parser.newDoclet\n * @fires module:jsdoc/src/parser.Parser.fileComplete\n * @fires module:jsdoc/src/parser.Parser.parseComplete\n *\n * @example <caption>Parse two source files.</caption>\n * var myFiles = ['file1.js', 'file2.js'];\n * var docs = jsdocParser.parse(myFiles);\n */\nParser.prototype.parse = function(sourceFiles, encoding) {\n    encoding = encoding || jsdoc.env.conf.encoding || 'utf8';\n\n    var filename = '';\n    var sourceCode = '';\n    var parsedFiles = [];\n    var e = {};\n\n    if (typeof sourceFiles === 'string') {\n        sourceFiles = [sourceFiles];\n    }\n\n    e.sourcefiles = sourceFiles;\n    logger.debug('Parsing source files: %j', sourceFiles);\n\n    this.emit('parseBegin', e);\n\n    for (var i = 0, l = sourceFiles.length; i < l; i++) {\n        sourceCode = '';\n\n        if (sourceFiles[i].indexOf(SCHEMA) === 0) {\n            sourceCode = sourceFiles[i].substr(SCHEMA.length);\n            filename = '[[string' + i + ']]';\n        }\n        else {\n            filename = sourceFiles[i];\n            try {\n                sourceCode = fs.readFileSync(filename, encoding);\n            }\n            catch (err) {\n                logger.error('Unable to read and parse the source file %s: %s', filename, err);\n            }\n        }\n\n        if (sourceCode.length) {\n            this._parseSourceCode(sourceCode, filename);\n            parsedFiles.push(filename);\n        }\n    }\n\n    this.emit('parseComplete', {\n        sourcefiles: parsedFiles,\n        doclets: this._resultBuffer\n    });\n    logger.debug('Finished parsing source files.');\n\n    return this._resultBuffer;\n};\n\n// TODO: docs\nParser.prototype.fireProcessingComplete = function(doclets) {\n    this.emit('processingComplete', { doclets: doclets });\n};\n\n// TODO: docs\nParser.prototype.results = function() {\n    return this._resultBuffer;\n};\n\n// TODO: update docs\n/**\n * @param {Object} o The parse result to add to the result buffer.\n */\nParser.prototype.addResult = function(o) {\n    this._resultBuffer.push(o);\n};\n\n// TODO: docs\nParser.prototype.addAstNodeVisitor = function(visitor) {\n    this._visitor.addAstNodeVisitor(visitor);\n};\n\n// TODO: docs\nParser.prototype.getAstNodeVisitors = function() {\n    return this._visitor.getAstNodeVisitors();\n};\n\n// TODO: docs\nfunction pretreat(code) {\n    return code\n        // comment out hashbang at the top of the file, like: #!/usr/bin/env node\n        .replace(/^(\\#\\![\\S \\t]+\\r?\\n)/, '// $1')\n\n        // to support code minifiers that preserve /*! comments, treat /*!* as equivalent to /**\n        .replace(/\\/\\*\\!\\*/g, '/**')\n        // merge adjacent doclets\n        .replace(/\\*\\/\\/\\*\\*+/g, '@also');\n}\n\n/** @private */\nParser.prototype._parseSourceCode = function(sourceCode, sourceName) {\n    var ast;\n    var globalScope;\n\n    var e = {\n        filename: sourceName\n    };\n\n    this.emit('fileBegin', e);\n    logger.info('Parsing %s ...', sourceName);\n\n    if (!e.defaultPrevented) {\n        e = {\n            filename: sourceName,\n            source: sourceCode\n        };\n        this.emit('beforeParse', e);\n        sourceCode = e.source;\n        sourceName = e.filename;\n\n        sourceCode = pretreat(e.source);\n\n        ast = this._astBuilder.build(sourceCode, sourceName);\n        if (ast) {\n            this._walkAst(ast, this._visitor, sourceName);\n        }\n    }\n\n    this.emit('fileComplete', e);\n};\n\n/** @private */\nParser.prototype._walkAst = function(ast, visitor, sourceName) {\n    this._walker.recurse(ast, visitor, sourceName);\n};\n\n// TODO: docs\nParser.prototype.addDocletRef = function(e) {\n    var fakeDoclet;\n    var node;\n\n    if (e && e.code && e.code.node) {\n        node = e.code.node;\n        if (e.doclet) {\n            // allow lookup from node ID => doclet\n            this._byNodeId.put(node.nodeId, e.doclet);\n            this._byLongname.put(e.doclet.longname, e.doclet);\n        }\n        // keep references to undocumented anonymous functions, too, as they might have scoped vars\n        else if (\n            (node.type === Syntax.FunctionDeclaration || node.type === Syntax.FunctionExpression ||\n                node.type === Syntax.ArrowFunctionExpression) &&\n                !this._getDocletById(node.nodeId) ) {\n            fakeDoclet = {\n                longname: jsdoc.name.LONGNAMES.ANONYMOUS,\n                meta: {\n                    code: e.code\n                }\n            };\n            this._byNodeId.put(node.nodeId, fakeDoclet);\n            this._byLongname.put(fakeDoclet.longname, fakeDoclet);\n        }\n    }\n};\n\n// TODO: docs\nParser.prototype._getDocletById = function(id) {\n    return this._byNodeId.get(id);\n};\n\n/**\n * Retrieve the most recently seen doclet that has the given longname.\n *\n * @param {string} longname - The longname to search for.\n * @return {module:jsdoc/doclet.Doclet?} The most recent doclet for the longname.\n */\nParser.prototype._getDocletByLongname = function(longname) {\n    return this._byLongname.get(longname);\n};\n\n// TODO: docs\n/**\n * @param {string} name - The symbol's longname.\n * @return {string} The symbol's basename.\n */\nParser.prototype.getBasename = function(name) {\n    if (name !== undefined) {\n        return name.replace(/^([$a-z_][$a-z_0-9]*).*?$/i, '$1');\n    }\n    return undefined;\n};\n\n// TODO: docs\nfunction definedInScope(doclet, basename) {\n    return !!doclet && !!doclet.meta && !!doclet.meta.vars && !!basename &&\n        hasOwnProp.call(doclet.meta.vars, basename);\n}\n\n// TODO: docs\n/**\n * Given a node, determine what the node is a member of.\n * @param {node} node\n * @returns {string} The long name of the node that this is a member of.\n */\nParser.prototype.astnodeToMemberof = function(node) {\n    var basename;\n    var doclet;\n    var scope;\n\n    var result = {};\n    var type = node.type;\n\n    if ( (type === Syntax.FunctionDeclaration || type === Syntax.FunctionExpression ||\n        type === Syntax.ArrowFunctionExpression || type === Syntax.VariableDeclarator) &&\n        node.enclosingScope ) {\n        doclet = this._getDocletById(node.enclosingScope.nodeId);\n\n        if (!doclet) {\n            result.memberof = jsdoc.name.LONGNAMES.ANONYMOUS + jsdoc.name.SCOPE.PUNC.INNER;\n       }\n        else {\n            result.memberof = doclet.longname + jsdoc.name.SCOPE.PUNC.INNER;\n        }\n    }\n    else {\n        // check local references for aliases\n        scope = node;\n        basename = this.getBasename( jsdoc.src.astnode.nodeToValue(node) );\n\n        // walk up the scope chain until we find the scope in which the node is defined\n        while (scope.enclosingScope) {\n            doclet = this._getDocletById(scope.enclosingScope.nodeId);\n            if ( doclet && definedInScope(doclet, basename) ) {\n                result.memberof = doclet.meta.vars[basename];\n                result.basename = basename;\n                break;\n            }\n            else {\n                // move up\n                scope = scope.enclosingScope;\n            }\n        }\n\n        // do we know that it's a global?\n        doclet = this._getDocletByLongname(jsdoc.name.LONGNAMES.GLOBAL);\n        if ( doclet && definedInScope(doclet, basename) ) {\n            result.memberof = doclet.meta.vars[basename];\n            result.basename = basename;\n        }\n        else {\n            doclet = this._getDocletById(node.parent.nodeId);\n\n            // set the result if we found a doclet. (if we didn't, the AST node may describe a\n            // global symbol.)\n            if (doclet) {\n                result.memberof = doclet.longname || doclet.name;\n            }\n        }\n    }\n\n    return result;\n};\n\n/**\n * Get the doclet for the lowest-level class, if any, that is in the scope chain for a given node.\n *\n * @param {Object} node - The node whose scope chain will be searched.\n * @return {module:jsdoc/doclet.Doclet?} The doclet for the lowest-level class in the node's scope\n * chain.\n */\nParser.prototype._getParentClass = function(node) {\n    var doclet;\n    var nameAtoms;\n    var scope = node.enclosingScope;\n\n    function isClass(d) {\n        return d && d.kind === 'class';\n    }\n\n    while (scope) {\n        // get the doclet, if any, for the parent scope\n        doclet = this._getDocletById(scope.nodeId);\n\n        if (doclet) {\n            // is the doclet for a class? if so, we're done\n            if ( isClass(doclet) ) {\n                break;\n            }\n\n            // is the doclet for an instance member of a class? if so, try to get the doclet for the\n            // owning class\n            nameAtoms = jsdoc.name.shorten(doclet.longname);\n            if (nameAtoms.scope === jsdoc.name.SCOPE.PUNC.INSTANCE) {\n                doclet = this._getDocletByLongname(nameAtoms.memberof);\n                if ( isClass(doclet) ) {\n                    break;\n                }\n            }\n        }\n\n        // move up to the next parent scope\n        scope = scope.enclosingScope;\n    }\n\n    return (isClass(doclet) ? doclet : null);\n};\n\n// TODO: docs\n/**\n * Resolve what \"this\" refers to relative to a node.\n * @param {node} node - The \"this\" node\n * @returns {string} The longname of the enclosing node.\n */\nParser.prototype.resolveThis = function(node) {\n    var doclet;\n    var parentClass;\n    var result;\n\n    // In general, if there's an enclosing scope, we use the enclosing scope to resolve `this`.\n    // For object properties, we use the node's parent (the object) instead.\n    if (node.type !== Syntax.Property && node.enclosingScope) {\n        doclet = this._getDocletById(node.enclosingScope.nodeId);\n\n        if (!doclet) {\n            result = jsdoc.name.LONGNAMES.ANONYMOUS; // TODO handle global this?\n        }\n        else if (doclet.this) {\n            result = doclet.this;\n        }\n        else if (doclet.kind === 'function' && doclet.memberof) {\n            parentClass = this._getParentClass(node);\n\n            // like: function Foo() { this.bar = function(n) { /** blah */ this.name = n; };\n            // or:   Foo.prototype.bar = function(n) { /** blah */ this.name = n; };\n            // or:   var Foo = exports.Foo = function(n) { /** blah */ this.name = n; };\n            // or:   Foo.constructor = function(n) { /** blah */ this.name = n; }\n            if ( parentClass || /\\.constructor$/.test(doclet.longname) ) {\n                result = doclet.memberof;\n            }\n            // like: function notAClass(n) { /** global this */ this.name = n; }\n            else {\n                result = doclet.longname;\n            }\n        }\n        // like: var foo = function(n) { /** blah */ this.bar = n; }\n        else if ( doclet.kind === 'member' && jsdoc.src.astnode.isAssignment(node) ) {\n            result = doclet.longname;\n        }\n        // walk up to the closest class we can find\n        else if (doclet.kind === 'class' || doclet.kind === 'module') {\n            result = doclet.longname;\n        }\n        else if (node.enclosingScope) {\n            result = this.resolveThis(node.enclosingScope);\n        }\n    }\n    else {\n        doclet = this._getDocletById(node.parent.nodeId);\n\n        // TODO: is this behavior correct? when do we get here?\n        if (!doclet) {\n            result = ''; // global?\n        }\n        else {\n            result = doclet.longname;\n        }\n    }\n\n    return result;\n};\n\n/**\n * Given an AST node representing an object property, find the doclets for the parent object or\n * objects.\n *\n * If the object is part of a simple assignment (for example, `var foo = { x: 1 }`), this method\n * returns a single doclet (in this case, the doclet for `foo`).\n *\n * If the object is part of a chained assignment (for example, `var foo = exports.FOO = { x: 1 }`,\n * this method returns multiple doclets (in this case, the doclets for `foo` and `exports.FOO`).\n *\n * @param {Object} node - An AST node representing an object property.\n * @return {Array.<module:jsdoc/doclet.Doclet>} An array of doclets for the parent object or objects, or\n * an empty array if no doclets are found.\n */\nParser.prototype.resolvePropertyParents = function(node) {\n    var currentAncestor = node.parent;\n    var nextAncestor = currentAncestor.parent;\n    var doclet;\n    var doclets = [];\n\n    while (currentAncestor) {\n        doclet = this._getDocletById(currentAncestor.nodeId);\n        if (doclet) {\n            doclets.push(doclet);\n        }\n\n        // if the next ancestor is an assignment expression (for example, `exports.FOO` in\n        // `var foo = exports.FOO = { x: 1 }`, keep walking upwards\n        if (nextAncestor && nextAncestor.type === Syntax.AssignmentExpression) {\n            nextAncestor = nextAncestor.parent;\n            currentAncestor = currentAncestor.parent;\n        }\n        // otherwise, we're done\n        else {\n            currentAncestor = null;\n        }\n    }\n\n    return doclets;\n};\n\n// TODO: docs\n/**\n * Resolve what function a var is limited to.\n * @param {astnode} node\n * @param {string} basename The leftmost name in the long name: in foo.bar.zip the basename is foo.\n */\nParser.prototype.resolveVar = function(node, basename) {\n    var doclet;\n    var result;\n    var scope = node.enclosingScope;\n\n    // HACK: return an empty string for function declarations so they don't end up in anonymous\n    // scope (see #685 and #693)\n    if (node.type === Syntax.FunctionDeclaration) {\n        result = '';\n    }\n    else if (!scope) {\n        result = ''; // global\n    }\n    else {\n        doclet = this._getDocletById(scope.nodeId);\n        if ( definedInScope(doclet, basename) ) {\n            result = doclet.longname;\n        }\n        else {\n            result = this.resolveVar(scope, basename);\n        }\n    }\n\n    return result;\n};\n\n// TODO: docs\nParser.prototype.resolveEnum = function(e) {\n    var doclets = this.resolvePropertyParents(e.code.node.parent);\n\n    doclets.forEach(function(doclet) {\n        if (doclet && doclet.isEnum) {\n            doclet.properties = doclet.properties || [];\n\n            // members of an enum inherit the enum's type\n            if (doclet.type && !e.doclet.type) {\n                // clone the type to prevent circular refs\n                e.doclet.type = jsdoc.util.doop(doclet.type);\n            }\n\n            delete e.doclet.undocumented;\n            e.doclet.defaultvalue = e.doclet.meta.code.value;\n\n            // add the doclet to the parent's properties\n            doclet.properties.push(e.doclet);\n        }\n    });\n};\n\n// TODO: document other events\n/**\n * Fired once for each JSDoc comment in the current source code.\n * @event jsdocCommentFound\n * @memberof module:jsdoc/src/parser.Parser\n * @type {Object}\n * @property {string} comment The text content of the JSDoc comment\n * @property {number} lineno The line number associated with the found comment.\n * @property {string} filename The file name associated with the found comment.\n */\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/src/syntax.js":"'use strict';\n\n// TODO: docs\nexports.Syntax = {\n    ArrayExpression: 'ArrayExpression',\n    ArrayPattern: 'ArrayPattern',\n    ArrowFunctionExpression: 'ArrowFunctionExpression',\n    AssignmentExpression: 'AssignmentExpression',\n    AssignmentPattern: 'AssignmentPattern',\n    BinaryExpression: 'BinaryExpression',\n    BlockStatement: 'BlockStatement',\n    BreakStatement: 'BreakStatement',\n    CallExpression: 'CallExpression',\n    CatchClause: 'CatchClause',\n    ClassBody: 'ClassBody',\n    ClassDeclaration: 'ClassDeclaration',\n    ClassExpression: 'ClassExpression',\n    ComprehensionBlock: 'ComprehensionBlock',\n    ComprehensionExpression: 'ComprehensionExpression',\n    ConditionalExpression: 'ConditionalExpression',\n    ContinueStatement: 'ContinueStatement',\n    DebuggerStatement: 'DebuggerStatement',\n    DoWhileStatement: 'DoWhileStatement',\n    EmptyStatement: 'EmptyStatement',\n    ExperimentalRestProperty: 'ExperimentalRestProperty',\n    ExperimentalSpreadProperty: 'ExperimentalSpreadProperty',\n    ExportAllDeclaration: 'ExportAllDeclaration',\n    ExportDefaultDeclaration: 'ExportDefaultDeclaration',\n    ExportNamedDeclaration: 'ExportNamedDeclaration',\n    ExportSpecifier: 'ExportSpecifier',\n    ExpressionStatement: 'ExpressionStatement',\n    ForInStatement: 'ForInStatement',\n    ForOfStatement: 'ForOfStatement',\n    ForStatement: 'ForStatement',\n    FunctionDeclaration: 'FunctionDeclaration',\n    FunctionExpression: 'FunctionExpression',\n    Identifier: 'Identifier',\n    IfStatement: 'IfStatement',\n    ImportDeclaration: 'ImportDeclaration',\n    ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n    ImportSpecifier: 'ImportSpecifier',\n    JSXAttribute: 'JSXAttribute',\n    JSXClosingElement: 'JSXClosingElement',\n    JSXElement: 'JSXElement',\n    JSXEmptyExpression: 'JSXEmptyExpression',\n    JSXExpressionContainer: 'JSXExpressionContainer',\n    JSXIdentifier: 'JSXIdentifier',\n    JSXMemberExpression: 'JSXMemberExpression',\n    JSXNamespacedName: 'JSXNamespacedName',\n    JSXOpeningElement: 'JSXOpeningElement',\n    JSXSpreadAttribute: 'JSXSpreadAttribute',\n    JSXText: 'JSXText',\n    LabeledStatement: 'LabeledStatement',\n    LetStatement: 'LetStatement',\n    Literal: 'Literal',\n    LogicalExpression: 'LogicalExpression',\n    MemberExpression: 'MemberExpression',\n    MetaProperty: 'MetaProperty',\n    MethodDefinition: 'MethodDefinition',\n    NewExpression: 'NewExpression',\n    ObjectExpression: 'ObjectExpression',\n    ObjectPattern: 'ObjectPattern',\n    Program: 'Program',\n    Property: 'Property',\n    RestElement: 'RestElement',\n    ReturnStatement: 'ReturnStatement',\n    SequenceExpression: 'SequenceExpression',\n    SpreadElement: 'SpreadElement',\n    Super: 'Super',\n    SwitchCase: 'SwitchCase',\n    SwitchStatement: 'SwitchStatement',\n    TaggedTemplateExpression: 'TaggedTemplateExpression',\n    TemplateElement: 'TemplateElement',\n    TemplateLiteral: 'TemplateLiteral',\n    ThisExpression: 'ThisExpression',\n    ThrowStatement: 'ThrowStatement',\n    TryStatement: 'TryStatement',\n    UnaryExpression: 'UnaryExpression',\n    UpdateExpression: 'UpdateExpression',\n    VariableDeclaration: 'VariableDeclaration',\n    VariableDeclarator: 'VariableDeclarator',\n    WhileStatement: 'WhileStatement',\n    WithStatement: 'WithStatement',\n    YieldExpression: 'YieldExpression'\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/src/visitor.js":"/**\n * @module jsdoc/src/visitor\n */\n'use strict';\n\n// TODO: consider exporting more stuff so users can override it\n\nvar jsdoc = {\n    doclet: require('jsdoc/doclet'),\n    name: require('jsdoc/name'),\n    src: {\n        astnode: require('jsdoc/src/astnode'),\n        syntax: require('jsdoc/src/syntax')\n    },\n    util: {\n        logger: require('jsdoc/util/logger')\n    }\n};\nvar util = require('util');\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\nvar Syntax = jsdoc.src.syntax.Syntax;\n\n// TODO: docs\nfunction getLeadingComment(node) {\n    var comment = null;\n    var leadingComments = node.leadingComments;\n\n    if (Array.isArray(leadingComments) && leadingComments.length && leadingComments[0].raw) {\n        comment = leadingComments[0].raw;\n    }\n\n    return comment;\n}\n\n// TODO: docs\nfunction makeVarsFinisher(scopeDoclet) {\n    return function(e) {\n        // no need to evaluate all things related to scopeDoclet again, just use it\n        if ( scopeDoclet && e.doclet && (e.doclet.alias || e.doclet.memberof) ) {\n            scopeDoclet.meta.vars[e.code.name] = e.doclet.longname;\n        }\n    };\n}\n\n// Given an event, get the parent node's doclet.\nfunction getParentDocletFromEvent(parser, e) {\n    if (e.doclet && e.doclet.meta && e.doclet.meta.code && e.doclet.meta.code.node &&\n        e.doclet.meta.code.node.parent) {\n        return parser._getDocletById(e.doclet.meta.code.node.parent.nodeId);\n    }\n\n    return null;\n}\n\n/**\n * For function parameters that have inline documentation, create a function that will merge the\n * inline documentation into the function's doclet. If the parameter is already documented in the\n * function's doclet, the inline documentation will be ignored.\n *\n * @private\n * @param {module:jsdoc/src/parser.Parser} parser - The JSDoc parser.\n * @return {function} A function that merges a parameter's inline documentation into the function's\n * doclet.\n */\nfunction makeInlineParamsFinisher(parser) {\n    return function(e) {\n        var documentedParams;\n        var knownParams;\n        var param;\n        var parentDoclet;\n\n        var i = 0;\n\n        parentDoclet = getParentDocletFromEvent(parser, e);\n        if (!parentDoclet) {\n            return;\n        }\n\n        // we only want to use the doclet if it's param-specific (but not, for example, if it's\n        // a param tagged with `@exports` in an AMD module)\n        if (e.doclet.kind !== 'param') {\n            return;\n        }\n\n        parentDoclet.params = parentDoclet.params || [];\n        documentedParams = parentDoclet.params;\n        knownParams = parentDoclet.meta.code.paramnames || [];\n\n        while (true) {\n            param = documentedParams[i];\n\n            // is the param already documented? if so, we don't need to use the doclet\n            if (param && param.name === e.doclet.name) {\n                e.doclet.undocumented = true;\n                break;\n            }\n\n            // if we ran out of documented params, or we're at the parameter's actual position,\n            // splice in the param at the current index\n            if ( !param || i === knownParams.indexOf(e.doclet.name) ) {\n                documentedParams.splice(i, 0, {\n                    type: e.doclet.type || {},\n                    description: '',\n                    name: e.doclet.name\n                });\n\n                // the doclet is no longer needed\n                e.doclet.undocumented = true;\n\n                break;\n            }\n\n            i++;\n        }\n    };\n}\n\n/**\n * Given an array of nodes that represent function parameters, find the node for the rest parameter,\n * if any.\n *\n * @private\n * @param {Array.<Object>} params - An array of nodes that represent function parameters.\n * @return {Object?} The node for the rest parameter.\n */\nfunction findRestParam(params) {\n    var restParam = null;\n\n    params.some(function(param) {\n        if (param.type === Syntax.RestElement) {\n            restParam = param;\n            return true;\n        }\n        return false;\n    });\n\n    return restParam;\n}\n\n/**\n * For functions that may include a rest parameter, create a function that will automatically update\n * the rest parameter's documentation to indicate that the parameter is repeatable. If the parameter\n * is not documented, the function's doclet will remain unchanged.\n *\n * @private\n * @param {module:jsdoc/src/parser.Parser} parser - The JSDoc parser.\n * @return {function} A function that updates the rest parameter's documentation to indicate that\n * the parameter is repeatable.\n */\nfunction makeRestParamFinisher(parser) {\n    return function(e) {\n        var doclet = e.doclet;\n        var documentedParams;\n        var restNode;\n\n        if (!doclet) {\n            return;\n        }\n\n        documentedParams = doclet.params = doclet.params || [];\n        restNode = findRestParam(e.code.node.params || e.code.node.value.params);\n\n        if (restNode) {\n            for (var i = documentedParams.length - 1; i >= 0; i--) {\n                if (documentedParams[i].name === restNode.argument.name) {\n                    documentedParams[i].variable = true;\n                    break;\n                }\n            }\n        }\n    };\n}\n\n/**\n * Given an array of nodes that represent function parameters, find the nodes for the default\n * parameters, if any.\n *\n * @private\n * @param {Array.<Object>} params - An array of nodes that represent function parameters.\n * @return {Array.<Object>} The nodes for the default parameters.\n */\nfunction findDefaultParams(params) {\n    var defaultParams = [];\n\n    params.forEach(function(param) {\n        if (param.type === Syntax.AssignmentPattern) {\n            defaultParams.push(param);\n        }\n        else {\n            defaultParams.push(null);\n        }\n    });\n\n    return defaultParams;\n}\n\n/**\n * For functions that may have at least one parameter with default values, create a function that\n * will automatically add the parameters' default values to the function's documentation. If any\n * default value is already documented, the function's doclet will remain unchanged.\n *\n * This function is only intended to handle default parameters whose node type is `Syntax.Literal`\n * (string, numeric, and boolean literals). This is because more complex default values may include,\n * for example, references to internal variables, which it may not make sense to include in\n * documentation.\n *\n * @private\n * @param {module:jsdoc/src/parser.Parser} parser - The JSDoc parser.\n * @return {function} A function that updates the function doclet to include the default values of\n * parameters.\n */\nfunction makeDefaultParamFinisher(parser) {\n    return function(e) {\n        var defaultValues;\n        var doclet = e.doclet;\n        var documentedParams;\n        var paramName;\n        var params;\n\n        if (!doclet) {\n            return;\n        }\n\n        documentedParams = doclet.params = doclet.params || [];\n        params = e.code.node.params || e.code.node.value.params;\n        defaultValues = findDefaultParams(params);\n\n        for (var i = 0, j = 0, l = params.length; i < l; i++) {\n            // bail out if we ran out of documented params\n            if (!documentedParams[j]) {\n                break;\n            }\n\n            // if the current parameter doesn't appear to be documented, move to the next one\n            paramName = params[i].type === Syntax.AssignmentPattern ?\n                params[i].left.name :\n                params[i].name;\n            if (paramName !== documentedParams[j].name) {\n                continue;\n            }\n\n            // add the default value iff a) a literal default value is defined in the code,\n            // b) no default value is documented, and c) the default value is not an empty string\n            if (defaultValues[i] &&\n                defaultValues[i].right &&\n                defaultValues[i].right.type === Syntax.Literal &&\n                typeof documentedParams[j].defaultvalue === 'undefined' &&\n                defaultValues[i].right.value !== '') {\n                documentedParams[j].defaultvalue =\n                    jsdoc.src.astnode.nodeToValue(defaultValues[i].right);\n            }\n\n            // move to the next documented param\n            j++;\n        }\n    };\n}\n\n/**\n * For method definitions that are constructors, create a function that will merge portions of the\n * constructor's doclet into the class's doclet, provided that a doclet exists for the class.\n * Merging the constructor's documentation allows ES 2015 classes to be documented in a natural way,\n * with separate JSDoc comments for the class and its constructor.\n *\n * @private\n * @param {module:jsdoc/src/parser.Parser} parser - The JSDoc parser.\n * @return {function} A function that merges the constructor's doclet into the class's doclet.\n */\nfunction makeConstructorFinisher(parser) {\n    return function(e) {\n        var doclet = e.doclet;\n        var parentDoclet = parser._getDocletById(e.code.node.parent.parent.nodeId);\n\n        if (!doclet || !parentDoclet || parentDoclet.undocumented) {\n            return;\n        }\n\n        if (!parentDoclet.description && doclet.description) {\n            parentDoclet.description = doclet.description;\n        }\n        if (!parentDoclet.params && doclet.params) {\n            parentDoclet.params = doclet.params.slice(0);\n        }\n\n        doclet.undocumented = true;\n    };\n}\n\n// TODO: docs\nfunction SymbolFound(node, filename, extras) {\n    var self = this;\n    extras = extras || {};\n\n    this.id = extras.id || node.nodeId;\n    this.comment = extras.comment || getLeadingComment(node) || '@undocumented';\n    this.lineno = extras.lineno || node.loc.start.line;\n    this.range = extras.range || node.range;\n    this.filename = extras.filename || filename;\n    this.astnode = extras.astnode || node;\n    this.code = extras.code;\n    this.event = extras.event || 'symbolFound';\n    this.finishers = extras.finishers || [];\n\n    // make sure the event includes properties that don't have default values\n    Object.keys(extras).forEach(function(key) {\n        self[key] = extras[key];\n    });\n}\n\n// TODO: docs\nfunction JsdocCommentFound(comment, filename) {\n    this.comment = comment.raw;\n    this.lineno = comment.loc.start.line;\n    this.filename = filename;\n    this.range = comment.range;\n\n    Object.defineProperty(this, 'event', {\n        value: 'jsdocCommentFound'\n    });\n}\n\n// TODO: docs\nvar Visitor = exports.Visitor = function() {\n    this._parser = null;\n\n    // Mozilla Parser API node visitors added by plugins\n    this._nodeVisitors = [];\n    // built-in visitors\n    this._visitors = [\n        this.visitNodeComments,\n        this.visitNode\n    ];\n};\n\n/**\n * Set the parser instance that visitors can use.\n *\n * @param {module:jsdoc/src/parser.Parser} parser - The parser instance.\n */\nVisitor.prototype.setParser = function(parser) {\n    this._parser = parser;\n};\n\n// TODO: docs\nVisitor.prototype.addAstNodeVisitor = function(visitor) {\n    this._nodeVisitors.push(visitor);\n};\n\n// TODO: docs\nVisitor.prototype.removeAstNodeVisitor = function(visitor) {\n    var idx = this._nodeVisitors.indexOf(visitor);\n    if (idx !== -1) {\n        this._nodeVisitors.splice(idx, 1);\n    }\n};\n\n// TODO: docs\nVisitor.prototype.getAstNodeVisitors = function() {\n    return this._nodeVisitors;\n};\n\n// TODO: docs; visitor signature is (node, parser, filename)\nVisitor.prototype.visit = function(node, filename) {\n    var i;\n    var l;\n\n    for (i = 0, l = this._visitors.length; i < l; i++) {\n        this._visitors[i].call(this, node, this._parser, filename);\n    }\n\n    return true;\n};\n\n// TODO: docs\n/**\n * Verify that a block comment exists and that its leading delimiter does not contain three or more\n * asterisks.\n *\n * @private\n * @memberof module:jsdoc/src/parser.Parser\n */\nfunction isValidJsdoc(commentSrc) {\n    return commentSrc && commentSrc.indexOf('/***') !== 0;\n}\n\n// TODO: docs\nfunction hasJsdocComments(node) {\n    return (node && node.leadingComments && node.leadingComments.length) ||\n        (node && node.trailingComments && node.trailingComments.length);\n}\n\n// TODO: docs\nfunction removeCommentDelimiters(comment) {\n    return comment.substring(2, comment.length - 2);\n}\n\n// TODO: docs\nfunction updateCommentNode(commentNode, comment) {\n    commentNode.raw = comment;\n    commentNode.value = removeCommentDelimiters(comment);\n}\n\n// TODO: docs\nVisitor.prototype.visitNodeComments = function(node, parser, filename) {\n    var comment;\n    var comments;\n    var e;\n\n    var BLOCK_COMMENT = 'Block';\n\n    if ( !hasJsdocComments(node) && (!node.type || node.type !== BLOCK_COMMENT) ) {\n        return true;\n    }\n\n    comments = (node.type === BLOCK_COMMENT) ? [node] : [];\n\n    if (node.leadingComments && node.leadingComments.length) {\n        comments = comments.concat( node.leadingComments.slice(0) );\n    }\n\n    if (node.trailingComments && node.trailingComments.length) {\n        comments = comments.concat( node.trailingComments.slice(0) );\n    }\n\n    for (var i = 0, l = comments.length; i < l; i++) {\n        comment = comments[i];\n        if ( isValidJsdoc(comment.raw) ) {\n            e = new JsdocCommentFound(comment, filename);\n\n            parser.emit(e.event, e, parser);\n\n            if (e.comment !== comment.raw) {\n                updateCommentNode(comment, e.comment);\n            }\n        }\n    }\n\n    return true;\n};\n\n// TODO: docs\nVisitor.prototype.visitNode = function(node, parser, filename) {\n    var i;\n    var l;\n\n    var e = this.makeSymbolFoundEvent(node, parser, filename);\n\n    if (this._nodeVisitors && this._nodeVisitors.length) {\n        for (i = 0, l = this._nodeVisitors.length; i < l; i++) {\n            this._nodeVisitors[i].visitNode(node, e, parser, filename);\n            if (e.stopPropagation) {\n                break;\n            }\n        }\n    }\n\n    if (!e.preventDefault && e.comment && isValidJsdoc(e.comment)) {\n        parser.emit(e.event, e, parser);\n    }\n\n    // add the node to the parser's lookup table\n    parser.addDocletRef(e);\n\n    for (i = 0, l = e.finishers.length; i < l; i++) {\n        e.finishers[i].call(parser, e);\n    }\n\n    return true;\n};\n\n// TODO: docs\n// TODO: note that it's essential to call this function before you try to resolve names!\nfunction trackVars(parser, node, e) {\n    var doclet;\n    var enclosingScopeId = node.enclosingScope ? node.enclosingScope.nodeId : null;\n\n    if (enclosingScopeId) {\n        doclet = parser._getDocletById(enclosingScopeId);\n    }\n    else {\n        doclet = parser._getDocletByLongname(jsdoc.name.LONGNAMES.GLOBAL);\n    }\n\n    if (doclet) {\n        doclet.meta.vars = doclet.meta.vars || {};\n        doclet.meta.vars[e.code.name] = null;\n        e.finishers.push( makeVarsFinisher(doclet) );\n    }\n}\n\n// TODO: docs\nVisitor.prototype.makeSymbolFoundEvent = function(node, parser, filename) {\n    var logger = jsdoc.util.logger;\n\n    var e;\n    var basename;\n    var i;\n    var l;\n    var parent;\n\n    var extras = {\n        code: jsdoc.src.astnode.getInfo(node)\n    };\n\n    switch (node.type) {\n        // like: i = 0;\n        case Syntax.AssignmentExpression:\n            e = new SymbolFound(node, filename, extras);\n\n            trackVars(parser, node, e);\n\n            basename = parser.getBasename(e.code.name);\n            if (basename !== 'this') {\n                e.code.funcscope = parser.resolveVar(node, basename);\n            }\n\n            break;\n\n        // like `bar='baz'` in: function foo(bar='baz') {}\n        case Syntax.AssignmentPattern:\n            parent = node.parent;\n\n            if ( node.leadingComments && parent && jsdoc.src.astnode.isFunction(parent) ) {\n                extras.finishers = [makeInlineParamsFinisher(parser)];\n                e = new SymbolFound(node, filename, extras);\n\n                trackVars(parser, node, e);\n            }\n\n            break;\n\n        // like: class foo {}\n        case Syntax.ClassDeclaration:\n            // falls through\n\n        // like: let MyClass = class {}\n        case Syntax.ClassExpression:\n            e = new SymbolFound(node, filename, extras);\n\n            trackVars(parser, node, e);\n\n            basename = parser.getBasename(e.code.name);\n\n            break;\n\n        // like: export * from 'foo'\n        case Syntax.ExportAllDeclaration:\n            e = new SymbolFound(node, filename, extras);\n\n            break;\n\n        // like: export default 'foo'\n        case Syntax.ExportDefaultDeclaration:\n            // falls through\n\n        // like: export var foo;\n        // or:   export {foo}\n        case Syntax.ExportNamedDeclaration:\n            // falls through\n\n        // like `foo as bar` in: export {foo as bar}\n        case Syntax.ExportSpecifier:\n            e = new SymbolFound(node, filename, extras);\n\n            trackVars(parser, node, e);\n\n            break;\n\n        // like: var foo = () => {};\n        case Syntax.ArrowFunctionExpression:\n            // falls through\n\n        // like: function foo() {}\n        case Syntax.FunctionDeclaration:\n            // falls through\n\n        // like: var foo = function() {};\n        case Syntax.FunctionExpression:\n            extras.finishers = [\n                // handle cases where at least one parameter has a default value\n                makeDefaultParamFinisher(parser),\n                // handle rest parameters\n                makeRestParamFinisher(parser)\n            ];\n\n            e = new SymbolFound(node, filename, extras);\n\n            trackVars(parser, node, e);\n\n            basename = parser.getBasename(e.code.name);\n            e.code.funcscope = parser.resolveVar(node, basename);\n\n            break;\n\n        // like `bar` in: function foo(/** @type {string} */ bar) {}\n        // or `module` in: define(\"MyModule\", function(/** @exports MyModule */ module) {}\n        // This is an extremely common type of node; we only care about function parameters with\n        // inline comments. No need to fire an event in other cases.\n        case Syntax.Identifier:\n            parent = node.parent;\n\n            // function parameters with inline comments\n            if ( node.leadingComments && parent && jsdoc.src.astnode.isFunction(parent) ) {\n                extras.finishers = [makeInlineParamsFinisher(parser)];\n                e = new SymbolFound(node, filename, extras);\n\n                trackVars(parser, node, e);\n            }\n\n            break;\n\n        // like `obj.prop` in: /** @typedef {string} */ obj.prop;\n        // Closure Compiler uses this pattern extensively for enums.\n        // No need to fire an event unless the node is already commented.\n        case Syntax.MemberExpression:\n            if (node.leadingComments) {\n                e = new SymbolFound(node, filename, extras);\n            }\n\n            break;\n\n        // like: foo() {}\n        // or:   constructor() {}\n        case Syntax.MethodDefinition:\n            extras.finishers = [\n                // handle cases where at least one parameter has a default value\n                makeDefaultParamFinisher(parser),\n                // handle rest parameters\n                makeRestParamFinisher(parser)\n            ];\n            // for constructors, we attempt to merge the constructor's docs into the class's docs\n            if (node.kind === 'constructor') {\n                extras.finishers.push( makeConstructorFinisher(parser) );\n            }\n\n            e = new SymbolFound(node, filename, extras);\n\n            break;\n\n        // like `{}` in: function Foo = Class.create(/** @lends Foo */ {});\n        case Syntax.ObjectExpression:\n            e = new SymbolFound(node, filename, extras);\n\n            break;\n\n        // like `bar: true` in: var foo = { bar: true };\n        // like `get bar() {}` in: var foo = { get bar() {} };\n        case Syntax.Property:\n            if (node.kind !== 'get' && node.kind !== 'set') {\n                extras.finishers = [parser.resolveEnum];\n            }\n\n            e = new SymbolFound(node, filename, extras);\n\n            break;\n\n        // like `...bar` in: function foo(...bar) {}\n        case Syntax.RestElement:\n            parent = node.parent;\n\n            if ( node.leadingComments && parent && jsdoc.src.astnode.isFunction(parent) ) {\n                extras.finishers = [makeInlineParamsFinisher(parser)];\n                e = new SymbolFound(node, filename, extras);\n\n                trackVars(parser, node, e);\n            }\n\n            break;\n\n        // like: var i = 0;\n        case Syntax.VariableDeclarator:\n            e = new SymbolFound(node, filename, extras);\n\n            trackVars(parser, node, e);\n\n            basename = parser.getBasename(e.code.name);\n            // auto-detect constants\n            if (node.parent.kind === 'const') {\n                e.code.kind = 'constant';\n            }\n\n            break;\n\n        default:\n            // ignore\n    }\n\n    if (!e) {\n        e = {\n            finishers: []\n        };\n    }\n\n    return e;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/src/walker.js":"/**\n * Traversal utilities for ASTs that are compatible with the Mozilla Parser API. Adapted from\n * [Acorn](http://marijnhaverbeke.nl/acorn/).\n *\n * @module jsdoc/src/walker\n * @license MIT\n */\n'use strict';\n\nvar astnode = require('jsdoc/src/astnode');\nvar doclet = require('jsdoc/doclet');\nvar Syntax = require('jsdoc/src/syntax').Syntax;\n\n/**\n * Check whether an AST node creates a new scope.\n *\n * @private\n * @param {Object} node - The AST node to check.\n * @return {Boolean} Set to `true` if the node creates a new scope, or `false` in all other cases.\n */\nfunction isScopeNode(node) {\n    // TODO: handle blocks with \"let\" declarations\n    return node && typeof node === 'object' && (node.type === Syntax.CatchClause ||\n        node.type === Syntax.FunctionDeclaration || node.type === Syntax.FunctionExpression ||\n        node.type === Syntax.ArrowFunctionExpression);\n}\n\n// TODO: docs\nfunction getCurrentScope(scopes) {\n    return scopes[scopes.length - 1] || null;\n}\n\n// TODO: docs\nfunction moveComments(source, target) {\n    if (source.leadingComments) {\n        target.leadingComments = source.leadingComments.slice(0);\n        source.leadingComments = [];\n    }\n}\n\nfunction leafNode(node, parent, state, cb) {}\n\n// TODO: docs\nvar walkers = exports.walkers = {};\n\nwalkers[Syntax.ArrayExpression] = function(node, parent, state, cb) {\n    for (var i = 0, l = node.elements.length; i < l; i++) {\n        var e = node.elements[i];\n        if (e) {\n            cb(e, node, state);\n        }\n    }\n};\n\n// TODO: verify correctness\nwalkers[Syntax.ArrayPattern] = function(node, parent, state, cb) {\n    for (var i = 0, l = node.elements.length; i < l; i++) {\n        var e = node.elements[i];\n        // must be an identifier or an expression\n        if (e && e.type !== Syntax.Identifier) {\n            cb(e, node, state);\n        }\n    }\n};\n\nwalkers[Syntax.ArrowFunctionExpression] = function(node, parent, state, cb) {\n    var i;\n    var l;\n\n    if (node.id) {\n        cb(node.id, node, state);\n    }\n\n    for (i = 0, l = node.params.length; i < l; i++) {\n        cb(node.params[i], node, state);\n    }\n\n    cb(node.body, node, state);\n};\n\nwalkers[Syntax.AssignmentExpression] = function(node, parent, state, cb) {\n    cb(node.left, node, state);\n    cb(node.right, node, state);\n};\n\nwalkers[Syntax.AssignmentPattern] = walkers[Syntax.AssignmentExpression];\n\nwalkers[Syntax.BinaryExpression] = function(node, parent, state, cb) {\n    cb(node.left, node, state);\n    cb(node.right, node, state);\n};\n\nwalkers[Syntax.BlockStatement] = function(node, parent, state, cb) {\n    for (var i = 0, l = node.body.length; i < l; i++) {\n        cb(node.body[i], node, state);\n    }\n};\n\nwalkers[Syntax.BreakStatement] = leafNode;\n\nwalkers[Syntax.CallExpression] = function(node, parent, state, cb) {\n    var i;\n    var l;\n\n    cb(node.callee, node, state);\n    if (node.arguments) {\n        for (i = 0, l = node.arguments.length; i < l; i++) {\n            cb(node.arguments[i], node, state);\n        }\n    }\n};\n\nwalkers[Syntax.CatchClause] = leafNode;\n\nwalkers[Syntax.ClassBody] = walkers[Syntax.BlockStatement];\n\nwalkers[Syntax.ClassDeclaration] = function(node, parent, state, cb) {\n    if (node.id) {\n        cb(node.id, node, state);\n    }\n\n    if (node.superClass) {\n        cb(node.superClass, node, state);\n    }\n\n    if (node.body) {\n        cb(node.body, node, state);\n    }\n};\n\nwalkers[Syntax.ClassExpression] = walkers[Syntax.ClassDeclaration];\n\n// TODO: verify correctness\nwalkers[Syntax.ComprehensionBlock] = walkers[Syntax.AssignmentExpression];\n\n// TODO: verify correctness\nwalkers[Syntax.ComprehensionExpression] = function(node, parent, state, cb) {\n    cb(node.body, node, state);\n\n    if (node.filter) {\n        cb(node.filter, node, state);\n    }\n\n    for (var i = 0, l = node.blocks.length; i < l; i++) {\n        cb(node.blocks[i], node, state);\n    }\n};\n\nwalkers[Syntax.ConditionalExpression] = function(node, parent, state, cb) {\n    cb(node.test, node, state);\n    cb(node.consequent, node, state);\n    cb(node.alternate, node, state);\n};\n\nwalkers[Syntax.ContinueStatement] = leafNode;\n\nwalkers[Syntax.DebuggerStatement] = leafNode;\n\nwalkers[Syntax.DoWhileStatement] = function(node, parent, state, cb) {\n    cb(node.test, node, state);\n    cb(node.body, node, state);\n};\n\nwalkers[Syntax.EmptyStatement] = leafNode;\n\nwalkers[Syntax.ExperimentalRestProperty] = function(node, parent, state, cb) {\n    cb(node.argument, node, state);\n};\n\nwalkers[Syntax.ExperimentalSpreadProperty] = walkers[Syntax.ExperimentalRestProperty];\n\nwalkers[Syntax.ExportAllDeclaration] = function(node, parent, state, cb) {\n    if (node.source) {\n        cb(node.source, node, state);\n    }\n};\n\nwalkers[Syntax.ExportDefaultDeclaration] = function(node, parent, state, cb) {\n    // if the declaration target is a class, move leading comments to the declaration target\n    if (node.declaration && node.declaration.type === Syntax.ClassDeclaration) {\n        moveComments(node, node.declaration);\n    }\n\n    if (node.declaration) {\n        cb(node.declaration, node, state);\n    }\n};\n\nwalkers[Syntax.ExportNamedDeclaration] = function(node, parent, state, cb) {\n    var i;\n    var l;\n\n    if (node.declaration) {\n        cb(node.declaration, node, state);\n    }\n\n    for (i = 0, l = node.specifiers.length; i < l; i++) {\n        cb(node.specifiers[i], node, state);\n    }\n\n    if (node.source) {\n        cb(node.source, node, state);\n    }\n};\n\nwalkers[Syntax.ExportSpecifier] = function(node, parent, state, cb) {\n    if (node.exported) {\n        cb(node.exported, node, state);\n    }\n\n    if (node.local) {\n        cb(node.local, node, state);\n    }\n};\n\nwalkers[Syntax.ExpressionStatement] = function(node, parent, state, cb) {\n    cb(node.expression, node, state);\n};\n\nwalkers[Syntax.ForInStatement] = function(node, parent, state, cb) {\n    cb(node.left, node, state);\n    cb(node.right, node, state);\n    cb(node.body, node, state);\n};\n\nwalkers[Syntax.ForOfStatement] = walkers[Syntax.ForInStatement];\n\nwalkers[Syntax.ForStatement] = function(node, parent, state, cb) {\n    if (node.init) {\n        cb(node.init, node, state);\n    }\n\n    if (node.test) {\n        cb(node.test, node, state);\n    }\n\n    if (node.update) {\n        cb(node.update, node, state);\n    }\n\n    cb(node.body, node, state);\n};\n\nwalkers[Syntax.FunctionDeclaration] = walkers[Syntax.ArrowFunctionExpression];\n\nwalkers[Syntax.FunctionExpression] = walkers[Syntax.ArrowFunctionExpression];\n\nwalkers[Syntax.Identifier] = leafNode;\n\nwalkers[Syntax.IfStatement] = function(node, parent, state, cb) {\n    cb(node.test, node, state);\n    cb(node.consequent, node, state);\n    if (node.alternate) {\n        cb(node.alternate, node, state);\n    }\n};\n\nwalkers[Syntax.ImportDeclaration] = function(node, parent, state, cb) {\n    if (node.specifiers) {\n        for (var i = 0, l = node.specifiers.length; i < l; i++) {\n            cb(node.specifiers[i], node, state);\n        }\n    }\n\n    if (node.source) {\n        cb(node.source, node, state);\n    }\n};\n\nwalkers[Syntax.ImportDefaultSpecifier] = function(node, parent, state, cb) {\n    if (node.local) {\n        cb(node.local, node, state);\n    }\n};\n\nwalkers[Syntax.ImportNamespaceSpecifier] = walkers[Syntax.ImportDefaultSpecifier];\n\nwalkers[Syntax.ImportSpecifier] = walkers[Syntax.ExportSpecifier];\n\nwalkers[Syntax.JSXAttribute] = function(node, parent, state, cb) {\n    cb(node.name, node, state);\n\n    if (node.value) {\n        cb(node.value, node, state);\n    }\n};\n\nwalkers[Syntax.JSXClosingElement] = function(node, parent, state, cb) {\n    cb(node.name, node, state);\n};\n\nwalkers[Syntax.JSXElement] = function(node, parent, state, cb) {\n    cb(node.openingElement, node, state);\n\n    if (node.closingElement) {\n        cb(node.closingElement, node, state);\n    }\n\n    for (var i = 0, l = node.children.length; i < l; i++) {\n        cb(node.children[i], node, state);\n    }\n};\n\nwalkers[Syntax.JSXEmptyExpression] = leafNode;\n\nwalkers[Syntax.JSXExpressionContainer] = function(node, parent, state, cb) {\n    cb(node.expression, node, state);\n};\n\nwalkers[Syntax.JSXIdentifier] = leafNode;\n\nwalkers[Syntax.JSXMemberExpression] = function(node, parent, state, cb) {\n    cb(node.object, node, state);\n\n    cb(node.property, node, state);\n};\n\nwalkers[Syntax.JSXNamespacedName] = function(node, parent, state, cb) {\n    cb(node.namespace, node, state);\n\n    cb(node.name, node, state);\n};\n\nwalkers[Syntax.JSXOpeningElement] = function(node, parent, state, cb) {\n    cb(node.name, node, state);\n\n    for (var i = 0, l = node.attributes.length; i < l; i++) {\n        cb(node.attributes[i], node, state);\n    }\n};\n\nwalkers[Syntax.JSXSpreadAttribute] = function(node, parent, state, cb) {\n    cb(node.argument, node, state);\n};\n\nwalkers[Syntax.JSXText] = leafNode;\n\nwalkers[Syntax.LabeledStatement] = function(node, parent, state, cb) {\n    cb(node.body, node, state);\n};\n\n// TODO: add scope info??\nwalkers[Syntax.LetStatement] = function(node, parent, state, cb) {\n    for (var i = 0, l = node.head.length; i < l; i++) {\n        var head = node.head[i];\n        cb(head.id, node, state);\n        if (head.init) {\n            cb(head.init, node, state);\n        }\n    }\n\n    cb(node.body, node, state);\n};\n\nwalkers[Syntax.Literal] = leafNode;\n\nwalkers[Syntax.LogicalExpression] = walkers[Syntax.BinaryExpression];\n\nwalkers[Syntax.MemberExpression] = function(node, parent, state, cb) {\n    cb(node.object, node, state);\n    if (node.property) {\n        cb(node.property, node, state);\n    }\n};\n\nwalkers[Syntax.MetaProperty] = leafNode;\n\nwalkers[Syntax.MethodDefinition] = function(node, parent, state, cb) {\n    if (node.key) {\n        cb(node.key, node, state);\n    }\n\n    if (node.value) {\n        cb(node.value, node, state);\n    }\n};\n\nwalkers[Syntax.ModuleDeclaration] = function(node, parent, state, cb) {\n    if (node.id) {\n        cb(node.id, node, state);\n    }\n\n    if (node.source) {\n        cb(node.source, node, state);\n    }\n\n    if (node.body) {\n        cb(node.body, node, state);\n    }\n};\n\nwalkers[Syntax.NewExpression] = walkers[Syntax.CallExpression];\n\nwalkers[Syntax.ObjectExpression] = function(node, parent, state, cb) {\n    for (var i = 0, l = node.properties.length; i < l; i++) {\n        cb(node.properties[i], node, state);\n    }\n};\n\nwalkers[Syntax.ObjectPattern] = walkers[Syntax.ObjectExpression];\n\nwalkers[Syntax.Program] = walkers[Syntax.BlockStatement];\n\nwalkers[Syntax.Property] = function(node, parent, state, cb) {\n    // move leading comments from key to property node\n    moveComments(node.key, node);\n\n    cb(node.value, node, state);\n};\n\nwalkers[Syntax.RestElement] = function(node, parent, state, cb) {\n    if (node.argument) {\n        cb(node.argument, node, state);\n    }\n};\n\nwalkers[Syntax.ReturnStatement] = function(node, parent, state, cb) {\n    if (node.argument) {\n        cb(node.argument, node, state);\n    }\n};\n\nwalkers[Syntax.SequenceExpression] = function(node, parent, state, cb) {\n    for (var i = 0, l = node.expressions.length; i < l; i++) {\n        cb(node.expressions[i], node, state);\n    }\n};\n\nwalkers[Syntax.SpreadElement] = function(node, parent, state, cb) {\n    if (node.argument) {\n        cb(node.argument, node, state);\n    }\n};\n\nwalkers[Syntax.Super] = leafNode;\n\nwalkers[Syntax.SwitchCase] = function(node, parent, state, cb) {\n    if (node.test) {\n        cb(node.test, node, state);\n    }\n\n    for (var i = 0, l = node.consequent.length; i < l; i++) {\n        cb(node.consequent[i], node, state);\n    }\n};\n\nwalkers[Syntax.SwitchStatement] = function(node, parent, state, cb) {\n    cb(node.discriminant, node, state);\n\n    for (var i = 0, l = node.cases.length; i < l; i++) {\n        cb(node.cases[i], node, state);\n    }\n};\n\nwalkers[Syntax.TaggedTemplateExpression] = function(node, parent, state, cb) {\n    if (node.tag) {\n        cb(node.tag, node, state);\n    }\n    if (node.quasi) {\n        cb(node.quasi, node, state);\n    }\n};\n\nwalkers[Syntax.TemplateElement] = leafNode;\n\nwalkers[Syntax.TemplateLiteral] = function(node, parent, state, cb) {\n    var i;\n    var l;\n\n    if (node.quasis && node.quasis.length) {\n        for (i = 0, l = node.quasis.length; i < l; i++) {\n            cb(node.quasis[i], node, state);\n        }\n    }\n\n    if (node.expressions && node.expressions.length) {\n        for (i = 0, l = node.expressions.length; i < l; i++) {\n            cb(node.expressions[i], node, state);\n        }\n    }\n};\n\nwalkers[Syntax.ThisExpression] = leafNode;\n\nwalkers[Syntax.ThrowStatement] = function(node, parent, state, cb) {\n    cb(node.argument, node, state);\n};\n\nwalkers[Syntax.TryStatement] = function(node, parent, state, cb) {\n    var i;\n    var l;\n\n    cb(node.block, node, state);\n\n    if (node.handler) {\n        cb(node.handler.body, node, state);\n    }\n\n    if (node.finalizer) {\n        cb(node.finalizer, node, state);\n    }\n};\n\nwalkers[Syntax.UnaryExpression] = function(node, parent, state, cb) {\n    cb(node.argument, node, state);\n};\n\nwalkers[Syntax.UpdateExpression] = walkers[Syntax.UnaryExpression];\n\nwalkers[Syntax.VariableDeclaration] = function(node, parent, state, cb) {\n    // move leading comments to first declarator\n    moveComments(node, node.declarations[0]);\n\n    for (var i = 0, l = node.declarations.length; i < l; i++) {\n        cb(node.declarations[i], node, state);\n    }\n};\n\nwalkers[Syntax.VariableDeclarator] = function(node, parent, state, cb) {\n    cb(node.id, node, state);\n\n    if (node.init) {\n        cb(node.init, node, state);\n    }\n};\n\nwalkers[Syntax.WhileStatement] = walkers[Syntax.DoWhileStatement];\n\nwalkers[Syntax.WithStatement] = function(node, parent, state, cb) {\n    cb(node.object, node, state);\n    cb(node.body, node, state);\n};\n\nwalkers[Syntax.YieldExpression] = function(node, parent, state, cb) {\n    if (node.argument) {\n        cb(node.argument, node, state);\n    }\n};\n\n/**\n * Create a walker that can traverse an AST that is consistent with the Mozilla Parser API.\n *\n * @todo docs\n * @memberof module:jsdoc/src/walker\n */\nvar Walker = exports.Walker = function(walkerFuncs) {\n    this._walkers = walkerFuncs || walkers;\n};\n\n// TODO: docs\nWalker.prototype._recurse = function(filename, ast) {\n    var self = this;\n    var state = {\n        filename: filename,\n        nodes: [],\n        scopes: []\n    };\n\n    function cb(node, parent, cbState) {\n        var currentScope;\n\n        var isScope = astnode.isScope(node);\n\n        astnode.addNodeProperties(node);\n        node.parent = parent || null;\n\n        currentScope = getCurrentScope(cbState.scopes);\n        if (currentScope) {\n            node.enclosingScope = currentScope;\n        }\n\n        if (isScope) {\n            cbState.scopes.push(node);\n        }\n        cbState.nodes.push(node);\n\n        self._walkers[node.type](node, parent, cbState, cb);\n\n        if (isScope) {\n            cbState.scopes.pop();\n        }\n    }\n\n    cb(ast, null, state);\n\n    return state;\n};\n\n// TODO: docs\nWalker.prototype.recurse = function(ast, visitor, filename) {\n    var shouldContinue;\n    var state = this._recurse(filename, ast);\n\n    if (visitor) {\n        for (var i = 0, l = state.nodes.length; i < l; i++) {\n            shouldContinue = visitor.visit.call(visitor, state.nodes[i], filename);\n            if (!shouldContinue) {\n                break;\n            }\n        }\n    }\n\n    return ast;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/tag/dictionary.js":"/** @module jsdoc/tag/dictionary */\n'use strict';\n\nvar definitions = require('jsdoc/tag/dictionary/definitions');\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\nvar dictionary;\n\n/** @private */\nfunction TagDefinition(dict, title, etc) {\n    var self = this;\n    etc = etc || {};\n\n    this.title = dict.normalise(title);\n\n    Object.defineProperty(this, '_dictionary', {\n        value: dict\n    });\n\n    Object.keys(etc).forEach(function(p) {\n        self[p] = etc[p];\n    });\n}\n\n/** @private */\nTagDefinition.prototype.synonym = function(synonymName) {\n    this._dictionary.defineSynonym(this.title, synonymName);\n    return this; // chainable\n};\n\n/**\n * @class\n * @alias module:jsdoc/tag/dictionary.Dictionary\n */\nfunction Dictionary() {\n    this._tags = {};\n    this._tagSynonyms = {};\n    // The longnames for `Package` objects include a `package` namespace. There's no `package` tag,\n    // though, so we declare the namespace here.\n    this._namespaces = ['package'];\n}\n\n/** @function */\nDictionary.prototype._defineNamespace = function defineNamespace(title) {\n    title = this.normalise(title || '');\n\n    if (title && this._namespaces.indexOf(title) === -1) {\n        this._namespaces.push(title);\n    }\n\n    return this;\n};\n\n/** @function */\nDictionary.prototype.defineTag = function defineTag(title, opts) {\n    var tagDef = new TagDefinition(this, title, opts);\n    this._tags[tagDef.title] = tagDef;\n\n    if (opts && opts.isNamespace) {\n        this._defineNamespace(tagDef.title);\n    }\n\n    return this._tags[tagDef.title];\n};\n\n/** @function */\nDictionary.prototype.defineSynonym = function defineSynonym(title, synonym) {\n    this._tagSynonyms[synonym.toLowerCase()] = this.normalise(title);\n};\n\n/** @function */\nDictionary.prototype.getNamespaces = function getNamespaces() {\n    return this._namespaces.slice(0);\n};\n\n/** @function */\nDictionary.prototype.lookUp = function lookUp(title) {\n    title = this.normalise(title);\n\n    if ( hasOwnProp.call(this._tags, title) ) {\n       return this._tags[title];\n    }\n\n    return false;\n};\n\n/** @function */\nDictionary.prototype.isNamespace = function isNamespace(kind) {\n    if (kind) {\n        kind = this.normalise(kind);\n        if (this._namespaces.indexOf(kind) !== -1) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n/** @function */\nDictionary.prototype.normalise = function normalise(title) {\n    var canonicalName = title.toLowerCase();\n\n    if ( hasOwnProp.call(this._tagSynonyms, canonicalName) ) {\n        return this._tagSynonyms[canonicalName];\n    }\n\n    return canonicalName;\n};\n\n/** @function */\nDictionary.prototype.normalize = Dictionary.prototype.normalise;\n\n// initialize the default dictionary\ndictionary = new Dictionary();\ndefinitions.defineTags(dictionary);\n\n// make the constructor available for unit-testing purposes\ndictionary.Dictionary = Dictionary;\n\n/** @type {module:jsdoc/tag/dictionary.Dictionary} */\nmodule.exports = dictionary;\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/tag/inline.js":"/**\n * @module jsdoc/tag/inline\n *\n * @author Jeff Williams <jeffrey.l.williams@gmail.com>\n * @license Apache License 2.0 - See file 'LICENSE.md' in this project.\n */\n'use strict';\n\n/**\n * Information about an inline tag that was found within a string.\n *\n * @typedef {Object} InlineTagInfo\n * @memberof module:jsdoc/tag/inline\n * @property {?string} completeTag - The entire inline tag, including its enclosing braces.\n * @property {?string} tag - The tag whose text was found.\n * @property {?string} text - The tag text that was found.\n */\n\n/**\n * Information about the results of replacing inline tags within a string.\n *\n * @typedef {Object} InlineTagResult\n * @memberof module:jsdoc/tag/inline\n * @property {Array.<module:jsdoc/tag/inline.InlineTagInfo>} tags - The inline tags that were found.\n * @property {string} newString - The updated text string after extracting or replacing the inline\n * tags.\n */\n\n/**\n * Text-replacing function for strings that contain an inline tag.\n *\n * @callback InlineTagReplacer\n * @memberof module:jsdoc/tag/inline\n * @param {string} string - The complete string containing the inline tag.\n * @param {module:jsdoc/tag/inline.InlineTagInfo} tagInfo - Information about the inline tag.\n * @return {string} An updated version of the complete string.\n */\n\n/**\n * Create a regexp that matches a specific inline tag, or all inline tags.\n *\n * @private\n * @memberof module:jsdoc/tag/inline\n * @param {?string} tagName - The inline tag that the regexp will match. May contain regexp\n * characters. If omitted, matches any string.\n * @param {?string} prefix - A prefix for the regexp. Defaults to an empty string.\n * @param {?string} suffix - A suffix for the regexp. Defaults to an empty string.\n * @returns {RegExp} A regular expression that matches the requested inline tag.\n */\nfunction regExpFactory(tagName, prefix, suffix) {\n    tagName = tagName || '\\\\S+';\n    prefix = prefix || '';\n    suffix = suffix || '';\n\n    return new RegExp(prefix + '\\\\{@' + tagName + '\\\\s+((?:.|\\n)+?)\\\\}' + suffix, 'i');\n}\n\n/**\n * Check whether a string is an inline tag. You can check for a specific inline tag or for any valid\n * inline tag.\n *\n * @param {string} string - The string to check.\n * @param {?string} tagName - The inline tag to match. May contain regexp characters. If this\n * parameter is omitted, this method returns `true` for any valid inline tag.\n * @returns {boolean} Set to `true` if the string is a valid inline tag or `false` in all other\n * cases.\n */\nexports.isInlineTag = function(string, tagName) {\n    return regExpFactory(tagName, '^', '$').test(string);\n};\n\n/**\n * Replace all instances of multiple inline tags with other text.\n *\n * @param {string} string - The string in which to replace the inline tags.\n * @param {Object} replacers - The functions that are used to replace text in the string. The keys\n * must contain tag names (for example, `link`), and the values must contain functions with the\n * type {@link module:jsdoc/tag/inline.InlineTagReplacer}.\n * @return {module:jsdoc/tag/inline.InlineTagResult} The updated string, as well as information\n * about the inline tags that were found.\n */\nexports.replaceInlineTags = function(string, replacers) {\n    var tagInfo = [];\n\n    function replaceMatch(replacer, tag, match, text) {\n        var matchedTag = {\n            completeTag: match,\n            tag: tag,\n            text: text\n        };\n        tagInfo.push(matchedTag);\n\n        return replacer(string, matchedTag);\n    }\n\n    string = string || '';\n\n    Object.keys(replacers).forEach(function(replacer) {\n        var tagRegExp = regExpFactory(replacer);\n        var matches;\n        var previousString;\n\n        // call the replacer once for each match\n        do {\n            matches = tagRegExp.exec(string);\n            if (matches) {\n                previousString = string;\n                string = replaceMatch(replacers[replacer], replacer, matches[0], matches[1]);\n            }\n        } while (matches && previousString !== string);\n    });\n\n    return {\n        tags: tagInfo,\n        newString: string.trim()\n    };\n};\n\n/**\n * Replace all instances of an inline tag with other text.\n *\n * @param {string} string - The string in which to replace the inline tag.\n * @param {string} tag - The name of the inline tag to replace.\n * @param {module:jsdoc/tag/inline.InlineTagReplacer} replacer - The function that is used to\n * replace text in the string.\n * @return {module:jsdoc/tag/inline.InlineTagResult} The updated string, as well as information\n * about the inline tags that were found.\n */\nexports.replaceInlineTag = function(string, tag, replacer) {\n    var replacers = {};\n    replacers[tag] = replacer;\n\n    return exports.replaceInlineTags(string, replacers);\n};\n\n/**\n * Extract inline tags from a string, replacing them with an empty string.\n *\n * @param {string} string - The string from which to extract text.\n * @param {?string} tag - The inline tag to extract.\n * @return {module:jsdoc/tag/inline.InlineTagResult} The updated string, as well as information\n * about the inline tags that were found.\n */\nexports.extractInlineTag = function(string, tag) {\n    return exports.replaceInlineTag(string, tag, function(str, tagInfo) {\n        return str.replace(tagInfo.completeTag, '');\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/tag/type.js":"/**\n * @module jsdoc/tag/type\n *\n * @author Michael Mathews <micmath@gmail.com>\n * @author Jeff Williams <jeffrey.l.williams@gmail.com>\n * @license Apache License 2.0 - See file 'LICENSE.md' in this project.\n */\n'use strict';\n\nvar catharsis = require('catharsis');\nvar jsdoc = {\n    name: require('jsdoc/name'),\n    tag: {\n        inline: require('jsdoc/tag/inline')\n    },\n    util: {\n        cast: require('jsdoc/util/cast')\n    }\n};\nvar util = require('util');\n\n/**\n * Information about a type expression extracted from tag text.\n *\n * @typedef TypeExpressionInfo\n * @memberof module:jsdoc/tag/type\n * @property {string} expression - The type expression.\n * @property {string} text - The updated tag text.\n */\n\n/** @private */\nfunction unescapeBraces(text) {\n    return text.replace(/\\\\\\{/g, '{')\n        .replace(/\\\\\\}/g, '}');\n}\n\n/**\n * Extract a type expression from the tag text.\n *\n * @private\n * @param {string} string - The tag text.\n * @return {module:jsdoc/tag/type.TypeExpressionInfo} The type expression and updated tag text.\n */\n function extractTypeExpression(string) {\n    var completeExpression;\n    var count = 0;\n    var position = 0;\n    var expression = '';\n    var startIndex = string.search(/\\{[^@]/);\n    var textStartIndex;\n\n    if (startIndex !== -1) {\n        // advance to the first character in the type expression\n        position = textStartIndex = startIndex + 1;\n        count++;\n\n        while (position < string.length) {\n            switch (string[position]) {\n                case '\\\\':\n                    // backslash is an escape character, so skip the next character\n                    position++;\n                    break;\n                case '{':\n                    count++;\n                    break;\n                case '}':\n                    count--;\n                    break;\n                default:\n                    // do nothing\n            }\n\n            if (count === 0) {\n                completeExpression = string.slice(startIndex, position + 1);\n                expression = string.slice(textStartIndex, position).trim();\n                break;\n            }\n\n            position++;\n        }\n    }\n\n    string = completeExpression ? string.replace(completeExpression, '') : string;\n\n    return {\n        expression: unescapeBraces(expression),\n        newString: string.trim()\n    };\n}\n\n/** @private */\nfunction getTagInfo(tagValue, canHaveName, canHaveType) {\n    var name = '';\n    var typeExpression = '';\n    var text = tagValue;\n    var expressionAndText;\n    var nameAndDescription;\n    var typeOverride;\n\n    if (canHaveType) {\n        expressionAndText = extractTypeExpression(text);\n        typeExpression = expressionAndText.expression;\n        text = expressionAndText.newString;\n    }\n\n    if (canHaveName) {\n        nameAndDescription = jsdoc.name.splitName(text);\n        name = nameAndDescription.name;\n        text = nameAndDescription.description;\n    }\n\n    // an inline @type tag, like {@type Foo}, overrides the type expression\n    if (canHaveType) {\n        typeOverride = jsdoc.tag.inline.extractInlineTag(text, 'type');\n        if (typeOverride.tags && typeOverride.tags[0]) {\n            typeExpression = typeOverride.tags[0].text;\n        }\n        text = typeOverride.newString;\n    }\n\n    return {\n        name: name,\n        typeExpression: typeExpression,\n        text: text\n    };\n}\n\n/**\n * Information provided in a JSDoc tag.\n *\n * @typedef {Object} TagInfo\n * @memberof module:jsdoc/tag/type\n * @property {string} TagInfo.defaultvalue - The default value of the member.\n * @property {string} TagInfo.name - The name of the member (for example, `myParamName`).\n * @property {boolean} TagInfo.nullable - Indicates whether the member can be set to `null` or\n * `undefined`.\n * @property {boolean} TagInfo.optional - Indicates whether the member is optional.\n * @property {string} TagInfo.text - Descriptive text for the member (for example, `The user's email\n * address.`).\n * @property {Array.<string>} TagInfo.type - The type or types that the member can contain (for\n * example, `string` or `MyNamespace.MyClass`).\n * @property {string} TagInfo.typeExpression - The type expression that was parsed to identify the\n * types.\n * @property {boolean} TagInfo.variable - Indicates whether the number of members that are provided\n * can vary (for example, in a function that accepts any number of parameters).\n */\n\n// TODO: move to module:jsdoc/name?\n/**\n * Extract JSDoc-style type information from the name specified in the tag info, including the\n * member name; whether the member is optional; and the default value of the member.\n *\n * @private\n * @param {module:jsdoc/tag/type.TagInfo} tagInfo - Information contained in the tag.\n * @return {module:jsdoc/tag/type.TagInfo} Updated information from the tag.\n */\nfunction parseName(tagInfo) {\n    // like '[foo]' or '[ foo ]' or '[foo=bar]' or '[ foo=bar ]' or '[ foo = bar ]'\n    // or 'foo=bar' or 'foo = bar'\n    if ( /^(\\[)?\\s*(.+?)\\s*(\\])?$/.test(tagInfo.name) ) {\n        tagInfo.name = RegExp.$2;\n        // were the \"optional\" brackets present?\n        if (RegExp.$1 && RegExp.$3) {\n            tagInfo.optional = true;\n        }\n\n        // like 'foo=bar' or 'foo = bar'\n        if ( /^(.+?)\\s*=\\s*(.+)$/.test(tagInfo.name) ) {\n            tagInfo.name = RegExp.$1;\n            tagInfo.defaultvalue = jsdoc.util.cast.cast(RegExp.$2);\n        }\n    }\n\n    return tagInfo;\n}\n\n/** @private */\nfunction getTypeStrings(parsedType, isOutermostType) {\n    var applications;\n    var typeString;\n\n    var types = [];\n\n    var TYPES = catharsis.Types;\n\n    switch (parsedType.type) {\n        case TYPES.AllLiteral:\n            types.push('*');\n            break;\n        case TYPES.FunctionType:\n            types.push('function');\n            break;\n        case TYPES.NameExpression:\n            types.push(parsedType.name);\n            break;\n        case TYPES.NullLiteral:\n            types.push('null');\n            break;\n        case TYPES.RecordType:\n            types.push('Object');\n            break;\n        case TYPES.TypeApplication:\n            // if this is the outermost type, we strip the modifiers; otherwise, we keep them\n            if (isOutermostType) {\n                applications = parsedType.applications.map(function(application) {\n                    return catharsis.stringify(application);\n                }).join(', ');\n                typeString = util.format( '%s.<%s>', getTypeStrings(parsedType.expression),\n                    applications );\n\n                types.push(typeString);\n            }\n            else {\n                types.push( catharsis.stringify(parsedType) );\n            }\n            break;\n        case TYPES.TypeUnion:\n            parsedType.elements.forEach(function(element) {\n                types = types.concat( getTypeStrings(element) );\n            });\n            break;\n        case TYPES.UndefinedLiteral:\n            types.push('undefined');\n            break;\n        case TYPES.UnknownLiteral:\n            types.push('?');\n            break;\n        default:\n            // this shouldn't happen\n            throw new Error( util.format('unrecognized type %s in parsed type: %j', parsedType.type,\n                parsedType) );\n    }\n\n    return types;\n}\n\n/**\n * Extract JSDoc-style and Closure Compiler-style type information from the type expression\n * specified in the tag info.\n *\n * @private\n * @param {module:jsdoc/tag/type.TagInfo} tagInfo - Information contained in the tag.\n * @return {module:jsdoc/tag/type.TagInfo} Updated information from the tag.\n */\nfunction parseTypeExpression(tagInfo) {\n    var errorMessage;\n    var parsedType;\n\n    // don't try to parse empty type expressions\n    if (!tagInfo.typeExpression) {\n        return tagInfo;\n    }\n\n    try {\n        parsedType = catharsis.parse(tagInfo.typeExpression, {jsdoc: true});\n    }\n    catch (e) {\n        // always re-throw so the caller has a chance to report which file was bad\n        throw new Error( util.format('Invalid type expression \"%s\": %s', tagInfo.typeExpression,\n            e.message) );\n    }\n\n    tagInfo.type = tagInfo.type.concat( getTypeStrings(parsedType, true) );\n    tagInfo.parsedType = parsedType;\n\n    // Catharsis and JSDoc use the same names for 'optional' and 'nullable'...\n    ['optional', 'nullable'].forEach(function(key) {\n        if (parsedType[key] !== null && parsedType[key] !== undefined) {\n            tagInfo[key] = parsedType[key];\n        }\n    });\n\n    // ...but not 'variable'.\n    if (parsedType.repeatable !== null && parsedType.repeatable !== undefined) {\n        tagInfo.variable = parsedType.repeatable;\n    }\n\n    return tagInfo;\n}\n\n// TODO: allow users to add/remove type parsers (perhaps via plugins)\nvar typeParsers = [parseName, parseTypeExpression];\n\n/**\n * Parse the value of a JSDoc tag.\n *\n * @param {string} tagValue - The value of the tag. For example, the tag `@param {string} name` has\n * a value of `{string} name`.\n * @param {boolean} canHaveName - Indicates whether the value can include a symbol name.\n * @param {boolean} canHaveType - Indicates whether the value can include a type expression that\n * describes the symbol.\n * @return {module:jsdoc/tag/type.TagInfo} Information obtained from the tag.\n * @throws {Error} Thrown if a type expression cannot be parsed.\n */\nexports.parse = function(tagValue, canHaveName, canHaveType) {\n    if (typeof tagValue !== 'string') { tagValue = ''; }\n\n    var tagInfo = getTagInfo(tagValue, canHaveName, canHaveType);\n    tagInfo.type = tagInfo.type || [];\n\n    typeParsers.forEach(function(parser) {\n        tagInfo = parser.call(this, tagInfo);\n    });\n\n    // if we wanted a type, but the parsers didn't add any type names, use the type expression\n    if (canHaveType && !tagInfo.type.length && tagInfo.typeExpression) {\n        tagInfo.type = [tagInfo.typeExpression];\n    }\n\n    return tagInfo;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/tag/validator.js":"/**\n    @module jsdoc/tag/validator\n    @requires jsdoc/tag/dictionary\n\n    @author Michael Mathews <micmath@gmail.com>\n    @license Apache License 2.0 - See file 'LICENSE.md' in this project.\n */\n'use strict';\n\nvar dictionary = require('jsdoc/tag/dictionary');\nvar env = require('jsdoc/env');\nvar format = require('util').format;\nvar logger = require('jsdoc/util/logger');\n\nfunction buildMessage(tagName, meta, desc) {\n    var result = format('The @%s tag %s. File: %s, line: %s', tagName, desc, meta.filename,\n        meta.lineno);\n    if (meta.comment) {\n        result += '\\n' + meta.comment;\n    }\n    return result;\n}\n\n/**\n * Validate the given tag.\n */\nexports.validate = function(tag, tagDef, meta) {\n    // handle cases where the tag definition does not exist\n    if (!tagDef) {\n        // log an error if unknown tags are not allowed\n        var allowUnknownTags = env.conf.tags.allowUnknownTags;\n        if (!allowUnknownTags ||\n            (Array.isArray(allowUnknownTags) &&\n             allowUnknownTags.indexOf(tag.title) < 0)) {\n            logger.error( buildMessage(tag.title, meta, 'is not a known tag') );\n        }\n\n        // stop validation, since there's nothing to validate against\n        return;\n    }\n\n    // check for errors that make the tag useless\n    if (!tag.text && tagDef.mustHaveValue) {\n        logger.error( buildMessage(tag.title, meta, 'requires a value') );\n    }\n\n    // check for minor issues that are usually harmless\n    else if (tag.text && tagDef.mustNotHaveValue) {\n        logger.warn( buildMessage(tag.title, meta,\n            'does not permit a value; the value will be ignored') );\n    }\n    else if (tag.value && tag.value.description && tagDef.mustNotHaveDescription) {\n        logger.warn( buildMessage(tag.title, meta,\n            'does not permit a description; the description will be ignored') );\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/tutorial/resolver.js":"/**\n    @overview\n    @author Rafa&#322; Wrzeszcz <rafal.wrzeszcz@wrzasq.pl>\n    @license Apache License 2.0 - See file 'LICENSE.md' in this project.\n */\n\n/**\n    @module jsdoc/tutorial/resolver\n */\n'use strict';\n\nvar env = require('jsdoc/env');\nvar fs = require('jsdoc/fs');\nvar logger = require('jsdoc/util/logger');\nvar path = require('path');\nvar tutorial = require('jsdoc/tutorial');\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\n// TODO: make this an instance member of `RootTutorial`?\nvar conf = {};\nvar finder = /^(.*)\\.(x(?:ht)?ml|html?|md|markdown|json)$/i;\n\n/** checks if `conf` is the metadata for a single tutorial.\n * A tutorial's metadata has a property 'title' and/or a property 'children'.\n * @param {object} json - the object we want to test (typically from JSON.parse)\n * @returns {boolean} whether `json` could be the metadata for a tutorial.\n */\nfunction isTutorialJSON(json) {\n    // if conf.title exists or conf.children exists, it is metadata for a tutorial\n    return (hasOwnProp.call(json, 'title') || hasOwnProp.call(json, 'children'));\n}\n\n/**\n * Root tutorial.\n * @type {module:jsdoc/tutorial.Root}\n */\nexports.root = new tutorial.RootTutorial();\n\n/** Helper function that adds tutorial configuration to the `conf` variable.\n * This helps when multiple tutorial configurations are specified in one object,\n * or when a tutorial's children are specified as tutorial configurations as\n * opposed to an array of tutorial names.\n *\n * Recurses as necessary to ensure all tutorials are added.\n *\n * @param {string} name - if `meta` is a configuration for a single tutorial,\n *                        this is that tutorial's name.\n * @param {object} meta - object that contains tutorial information.\n *                        Can either be for a single tutorial, or for multiple\n *                        (where each key in `meta` is the tutorial name and each\n *                         value is the information for a single tutorial).\n *                        Additionally, a tutorial's 'children' property may\n *                        either be an array of strings (names of the child tutorials),\n *                        OR an object giving the configuration for the child tutorials.\n */\nfunction addTutorialConf(name, meta) {\n    var i;\n    var l;\n    var names;\n\n    if (isTutorialJSON(meta)) {\n        // if the children are themselves tutorial defintions as opposed to an\n        // array of strings, add each child.\n        if (hasOwnProp.call(meta, 'children') && !Array.isArray(meta.children)) {\n            names = Object.keys(meta.children);\n            for (i = 0, l = names.length; i < l; ++i) {\n                addTutorialConf(names[i], meta.children[names[i]]);\n            }\n            // replace with an array of names.\n            meta.children = names;\n        }\n        // check if the tutorial has already been defined...\n        if (hasOwnProp.call(conf, name)) {\n            logger.warn('Metadata for the tutorial %s is defined more than once. Only the first definition will be used.', name );\n        } else {\n            conf[name] = meta;\n        }\n    } else {\n        // keys are tutorial names, values are `Tutorial` instances\n        names = Object.keys(meta);\n        for (i = 0, l = names.length; i < l; ++i) {\n            addTutorialConf(names[i], meta[names[i]]);\n        }\n    }\n}\n\n/**\n * Add a tutorial.\n * @param {module:jsdoc/tutorial.Tutorial} current - Tutorial to add.\n */\nexports.addTutorial = function(current) {\n    if (exports.root.getByName(current.name)) {\n        logger.warn('The tutorial %s is defined more than once. Only the first definition will be used.', current.name);\n    } else {\n        // by default, the root tutorial is the parent\n        current.setParent(exports.root);\n\n        exports.root._addTutorial(current);\n    }\n};\n\n/**\n * Load tutorials from the given path.\n * @param {string} filepath - Tutorials directory.\n */\nexports.load = function(filepath) {\n    var content;\n    var current;\n    var files = fs.ls(filepath, env.opts.recurse ? 10 : undefined);\n    var name;\n    var match;\n    var type;\n\n    // tutorials handling\n    files.forEach(function(file) {\n        match = file.match(finder);\n\n        // any filetype that can apply to tutorials\n        if (match) {\n            name = path.basename(match[1]);\n            content = fs.readFileSync(file, env.opts.encoding);\n\n            switch (match[2].toLowerCase()) {\n                // HTML type\n                case 'xml':\n                case 'xhtml':\n                case 'html':\n                case 'htm':\n                    type = tutorial.TYPES.HTML;\n                    break;\n\n                // Markdown typs\n                case 'md':\n                case 'markdown':\n                    type = tutorial.TYPES.MARKDOWN;\n                    break;\n\n                // configuration file\n                case 'json':\n                    var meta = JSON.parse(content);\n                    addTutorialConf(name, meta);\n                    // don't add this as a tutorial\n                    return;\n\n                // how can it be? check `finder' regexp\n                default:\n                    // not a file we want to work with\n                    return;\n            }\n\n            current = new tutorial.Tutorial(name, content, type);\n            exports.addTutorial(current);\n        }\n    });\n};\n\n/** Resolves hierarchical structure.\n */\nexports.resolve = function() {\n    var item;\n    var current;\n\n    Object.keys(conf).forEach(function(name) {\n        current = exports.root.getByName(name);\n\n        // TODO: should we complain about this?\n        if (!current) {\n            return;\n        }\n\n        item = conf[name];\n\n        // set title\n        if (item.title) {\n            current.title = item.title;\n        }\n\n        // add children\n        if (item.children) {\n            item.children.forEach(function(child) {\n                var childTutorial = exports.root.getByName(child);\n\n                if (!childTutorial) {\n                    logger.error('Missing child tutorial: %s', child);\n                }\n                else {\n                    childTutorial.setParent(current);\n                }\n            });\n        }\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/util/doop.js":"/* global Set */\n\n/**\n    Deep clone a simple object. Ignores non-enumerable properties.\n    @private\n */\n'use strict';\n\nvar setDefined = typeof Set !== 'undefined';\n\nfunction addItem(set, item) {\n    if (setDefined) {\n        set.add(item);\n    }\n    else if (set.indexOf(item) === -1) {\n        set.push(item);\n    }\n}\n\nfunction hasItem(set, item) {\n    if (setDefined) {\n        return set.has(item);\n    }\n    else {\n        return set.indexOf(item) !== -1;\n    }\n}\n\n// TODO: can we remove the circular-ref checking? pretty sure it's not needed anymore...\n// if we need this here for some reason I'm forgetting, we should share code with jsdoc/util/dumper\nfunction doop(o, seen) {\n    var clone;\n    var descriptor;\n    var props;\n    var i;\n    var l;\n\n    if (!seen) {\n        seen = setDefined ? new Set() : [];\n    }\n\n    if (o instanceof Object && o.constructor !== Function) {\n        if ( hasItem(seen, o) ) {\n            clone = '<CircularRef>';\n        }\n        else {\n            addItem(seen, o);\n\n            if ( Array.isArray(o) ) {\n                clone = [];\n                for (i = 0, l = o.length; i < l; i++) {\n                    clone[i] = (o[i] instanceof Object) ? doop(o[i], seen) : o[i];\n                }\n            }\n            else {\n                clone = Object.create( Object.getPrototypeOf(o) );\n                props = Object.keys(o);\n                for (i = 0, l = props.length; i < l; i++) {\n                    descriptor = Object.getOwnPropertyDescriptor(o, props[i]);\n                    if (descriptor.value) {\n                        descriptor.value = doop(descriptor.value, seen);\n                    }\n\n                    Object.defineProperty(clone, props[i], descriptor);\n                }\n            }\n        }\n\n        return clone;\n    }\n\n    return o;\n}\n\n// Wrapper to avoid exposing the 'seen' parameter outside of this module.\nfunction doopWrapper(o) {\n    return doop(o);\n}\n\n// for backwards compatibility\ndoopWrapper.doop = doopWrapper;\n\nmodule.exports = doopWrapper;\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/util/dumper.js":"/* global Set */\n/**\n * Recursively print out all names and values in a data structure.\n * @module jsdoc/util/dumper\n * @author Michael Mathews <micmath@gmail.com>\n * @license Apache License 2.0 - See file 'LICENSE.md' in this project.\n */\n'use strict';\n\nvar util = require('util');\n\nvar OBJECT_WALKER_KEY = 'hasBeenSeenByWalkerDumper';\nvar SET_DEFINED = (typeof Set !== 'undefined');\n\nfunction ObjectWalker() {\n    this.seenItems = SET_DEFINED ? new Set() : [];\n}\n\nObjectWalker.prototype.seen = function(object) {\n    var result;\n\n    if (SET_DEFINED) {\n        result = this.seenItems.has(object);\n    }\n    else {\n        result = object[OBJECT_WALKER_KEY];\n    }\n    return result;\n};\n\nObjectWalker.prototype.markAsSeen = function(object) {\n    if (SET_DEFINED) {\n        this.seenItems.add(object);\n    }\n    else {\n        object[OBJECT_WALKER_KEY] = true;\n        this.seenItems.push(object);\n    }\n};\n\nObjectWalker.prototype.removeSeenFlag = function(obj) {\n    if (SET_DEFINED) {\n        this.seenItems.delete(obj);\n    }\n    else {\n        delete obj[OBJECT_WALKER_KEY];\n    }\n};\n\n// some objects are unwalkable, like Java native objects\nObjectWalker.prototype.isUnwalkable = function(o) {\n    return (o && typeof o === 'object' && typeof o.constructor === 'undefined');\n};\n\nObjectWalker.prototype.isFunction = function(o) {\n    return (o && typeof o === 'function' || o instanceof Function);\n};\n\nObjectWalker.prototype.isObject = function(o) {\n    return o && o instanceof Object ||\n        (o && typeof o.constructor !== 'undefined' && o.constructor.name === 'Object');\n};\n\nObjectWalker.prototype.checkCircularRefs = function(o, func) {\n    if ( this.seen(o) ) {\n        return '<CircularRef>';\n    }\n    else {\n        this.markAsSeen(o);\n        return func(o);\n    }\n};\n\nObjectWalker.prototype.walk = function(o) {\n    var result;\n\n    var self = this;\n\n    if ( this.isUnwalkable(o) ) {\n        result = '<Object>';\n    }\n    else if ( o === undefined ) {\n        result = null;\n    }\n    else if ( Array.isArray(o) ) {\n        result = this.checkCircularRefs(o, function(arr) {\n            var newArray = [];\n\n            arr.forEach(function(item) {\n                newArray.push( self.walk(item) );\n            });\n\n            self.removeSeenFlag(arr);\n\n            return newArray;\n        });\n    }\n    else if ( util.isRegExp(o) ) {\n        result = '<RegExp ' + o + '>';\n    }\n    else if ( util.isDate(o) ) {\n        result = '<Date ' + o.toUTCString() + '>';\n    }\n    else if ( util.isError(o) ) {\n        result = { message: o.message };\n    }\n    else if ( this.isFunction(o) ) {\n        result = '<Function' + (o.name ? ' ' + o.name : '') + '>';\n    }\n    else if ( this.isObject(o) && o !== null ) {\n        result = this.checkCircularRefs(o, function(obj) {\n            var newObj = {};\n\n            Object.keys(obj).forEach(function(key) {\n                if (!SET_DEFINED && key === OBJECT_WALKER_KEY) { return; }\n                newObj[key] = self.walk(obj[key]);\n            });\n\n            self.removeSeenFlag(obj);\n\n            return newObj;\n        });\n    }\n    // should be safe to JSON.stringify() everything else\n    else {\n        result = o;\n    }\n\n    return result;\n};\n\n/**\n * @param {*} object\n */\nexports.dump = function() {\n    var args = Array.prototype.slice.call(arguments, 0);\n    var result = [];\n    var walker;\n\n    for (var i = 0, l = args.length; i < l; i++) {\n        walker = new ObjectWalker();\n        result.push( JSON.stringify(walker.walk(args[i]), null, 4) );\n    }\n\n    return result.join('\\n');\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/util/error.js":"/**\n * Helper functions for handling errors.\n *\n * @deprecated As of JSDoc 3.3.0. This module may be removed in a future release. Use the module\n * {@link module:jsdoc/util/logger} to log warnings and errors.\n * @module jsdoc/util/error\n */\n'use strict';\n\n/**\n * Log an exception as an error.\n *\n * Prior to JSDoc 3.3.0, this method would either log the exception (if lenient mode was enabled) or\n * re-throw the exception (default).\n *\n * In JSDoc 3.3.0 and later, lenient mode has been replaced with strict mode, which is disabled by\n * default. If strict mode is enabled, calling the `handle` method causes JSDoc to exit immediately,\n * just as if the exception had been re-thrown.\n *\n * @deprecated As of JSDoc 3.3.0. This module may be removed in a future release.\n * @param {Error} e - The exception to log.\n * @memberof module:jsdoc/util/error\n */\nexports.handle = function(e) {\n    var logger = require('jsdoc/util/logger');\n    var msg = e ? ( e.message || JSON.stringify(e) ) : '';\n\n    // include the error type if it's an Error object\n    if (e instanceof Error) {\n        msg = e.name + ': ' + msg;\n    }\n\n    logger.error(msg);\n};\n","/home/travis/build/npmtest/node-npmtest-jsdoc/node_modules/jsdoc/lib/jsdoc/util/templateHelper.js":"/**\n * @module jsdoc/util/templateHelper\n */\n'use strict';\n\nvar catharsis = require('catharsis');\nvar dictionary = require('jsdoc/tag/dictionary');\nvar env = require('jsdoc/env');\nvar name = require('jsdoc/name');\nvar util = require('util');\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\nvar MODULE_NAMESPACE = 'module:';\n\nvar files = {};\nvar ids = {};\n\n// each container gets its own html file\nvar containers = ['class', 'module', 'external', 'namespace', 'mixin', 'interface'];\n\nvar tutorials;\n\n/** Sets tutorials map.\n    @param {jsdoc.tutorial.Tutorial} root - Root tutorial node.\n */\nexports.setTutorials = function(root) {\n    tutorials = root;\n};\n\nexports.globalName = name.SCOPE.NAMES.GLOBAL;\nexports.fileExtension = '.html';\nexports.scopeToPunc = name.scopeToPunc;\n\nvar linkMap = {\n    // two-way lookup\n    longnameToUrl: {},\n    urlToLongname: {},\n\n    // one-way lookup (IDs are only unique per file)\n    longnameToId: {}\n};\n\n// two-way lookup\nvar tutorialLinkMap = {\n    nameToUrl: {},\n    urlToName: {}\n};\n\nvar longnameToUrl = exports.longnameToUrl = linkMap.longnameToUrl;\nvar longnameToId = exports.longnameToId = linkMap.longnameToId;\n\nvar registerLink = exports.registerLink = function(longname, fileUrl) {\n    linkMap.longnameToUrl[longname] = fileUrl;\n    linkMap.urlToLongname[fileUrl] = longname;\n};\n\nvar registerId = exports.registerId = function(longname, fragment) {\n    linkMap.longnameToId[longname] = fragment;\n};\n\nfunction getNamespace(kind) {\n    if (dictionary.isNamespace(kind)) {\n        return kind + ':';\n    }\n    return '';\n}\n\nfunction formatNameForLink(doclet, options) {\n    var newName = getNamespace(doclet.kind) + (doclet.name || '') + (doclet.variation || '');\n    var scopePunc = exports.scopeToPunc[doclet.scope] || '';\n\n    // Only prepend the scope punctuation if it's not the same character that marks the start of a\n    // fragment ID. Using `#` in HTML5 fragment IDs is legal, but URLs like `foo.html##bar` are\n    // just confusing.\n    if (scopePunc !== '#') {\n        newName = scopePunc + newName;\n    }\n\n    return newName;\n}\n\nfunction makeUniqueFilename(filename, str) {\n    var key = filename.toLowerCase();\n    var nonUnique = true;\n\n    // don't allow filenames to begin with an underscore\n    if (!filename.length || filename[0] === '_') {\n        filename = '-' + filename;\n        key = filename.toLowerCase();\n    }\n\n    // append enough underscores to make the filename unique\n    while (nonUnique) {\n        if ( hasOwnProp.call(files, key) ) {\n            filename += '_';\n            key = filename.toLowerCase();\n        } else {\n            nonUnique = false;\n        }\n    }\n\n    files[key] = str;\n    return filename;\n}\n\n/**\n * Convert a string to a unique filename, including an extension.\n *\n * Filenames are cached to ensure that they are used only once. For example, if the same string is\n * passed in twice, two different filenames will be returned.\n *\n * Also, filenames are not considered unique if they are capitalized differently but are otherwise\n * identical.\n * @param {string} str The string to convert.\n * @return {string} The filename to use for the string.\n */\nvar getUniqueFilename = exports.getUniqueFilename = function(str) {\n    var namespaces = dictionary.getNamespaces().join('|');\n    var basename = (str || '')\n        // use - instead of : in namespace prefixes\n        .replace(new RegExp('^(' + namespaces + '):'), '$1-')\n        // replace characters that can cause problems on some filesystems\n        .replace(/[\\\\\\/?*:|'\"<>]/g, '_')\n        // use - instead of ~ to denote 'inner'\n        .replace(/~/g, '-')\n        // use _ instead of # to denote 'instance'\n        .replace(/\\#/g, '_')\n        // use _ instead of / (for example, in module names)\n        .replace(/\\//g, '_')\n        // remove the variation, if any\n        .replace(/\\([\\s\\S]*\\)$/, '')\n        // make sure we don't create hidden files, or files whose names start with a dash\n        .replace(/^[\\.\\-]/, '');\n\n    // in case we've now stripped the entire basename (uncommon, but possible):\n    basename = basename.length ? basename : '_';\n\n    return makeUniqueFilename(basename, str) + exports.fileExtension;\n};\n\n/**\n * Get a longname's filename if one has been registered; otherwise, generate a unique filename, then\n * register the filename.\n * @private\n */\nfunction getFilename(longname) {\n    var fileUrl;\n\n    if ( hasOwnProp.call(longnameToUrl, longname) ) {\n        fileUrl = longnameToUrl[longname];\n    }\n    else {\n        fileUrl = getUniqueFilename(longname);\n        registerLink(longname, fileUrl);\n    }\n\n    return fileUrl;\n}\n\n/**\n * Check whether a symbol is the only symbol exported by a module (as in\n * `module.exports = function() {};`).\n *\n * @private\n * @param {module:jsdoc/doclet.Doclet} doclet - The doclet for the symbol.\n * @return {boolean} `true` if the symbol is the only symbol exported by a module; otherwise,\n * `false`.\n */\nfunction isModuleExports(doclet) {\n    return doclet.longname && doclet.longname === doclet.name &&\n        doclet.longname.indexOf(MODULE_NAMESPACE) === 0 && doclet.kind !== 'module';\n}\n\nfunction makeUniqueId(filename, id) {\n    var key;\n    var nonUnique = true;\n\n    key = id.toLowerCase();\n\n    // HTML5 IDs cannot contain whitespace characters\n    id = id.replace(/\\s/g, '');\n\n    // append enough underscores to make the identifier unique\n    while (nonUnique) {\n        if ( hasOwnProp.call(ids, filename) && hasOwnProp.call(ids[filename], key) ) {\n            id += '_';\n            key = id.toLowerCase();\n        }\n        else {\n            nonUnique = false;\n        }\n    }\n\n    ids[filename] = ids[filename] || {};\n    ids[filename][key] = id;\n\n    return id;\n}\n\n/**\n * Get a doclet's ID if one has been registered; otherwise, generate a unique ID, then register\n * the ID.\n * @private\n */\nfunction getId(longname, id) {\n    if ( hasOwnProp.call(longnameToId, longname) ) {\n        id = longnameToId[longname];\n    }\n    else if (!id) {\n        // no ID required\n        return '';\n    }\n    else {\n        id = makeUniqueId(longname, id);\n        registerId(longname, id);\n    }\n\n    return id;\n}\n\n/**\n * Convert a doclet to an identifier that is unique for a specified filename.\n *\n * Identifiers are not considered unique if they are capitalized differently but are otherwise\n * identical.\n *\n * @method\n * @param {string} filename - The file in which the identifier will be used.\n * @param {string} doclet - The doclet to convert.\n * @return {string} A unique identifier based on the file and doclet.\n */\nvar getUniqueId = exports.getUniqueId = makeUniqueId;\n\nvar htmlsafe = exports.htmlsafe = function(str) {\n    if (typeof str !== 'string') {\n        str = String(str);\n    }\n\n    return str.replace(/&/g, '&amp;')\n        .replace(/</g, '&lt;');\n};\n\nfunction parseType(longname) {\n    var err;\n\n    try {\n        return catharsis.parse(longname, {jsdoc: true});\n    }\n    catch (e) {\n        err = new Error('unable to parse ' + longname + ': ' + e.message);\n        require('jsdoc/util/logger').error(err);\n        return longname;\n    }\n}\n\nfunction stringifyType(parsedType, cssClass, stringifyLinkMap) {\n    return require('catharsis').stringify(parsedType, {\n        cssClass: cssClass,\n        htmlSafe: true,\n        links: stringifyLinkMap\n    });\n}\n\nfunction hasUrlPrefix(text) {\n    return (/^(http|ftp)s?:\\/\\//).test(text);\n}\n\nfunction isComplexTypeExpression(expr) {\n    // record types, type unions, and type applications all count as \"complex\"\n    return /^{.+}$/.test(expr) || /^.+\\|.+$/.test(expr) || /^.+<.+>$/.test(expr);\n}\n\nfunction fragmentHash(fragmentId) {\n    if (!fragmentId) {\n        return '';\n    }\n\n    return '#' + fragmentId;\n}\n\n/**\n * Build an HTML link to the symbol with the specified longname. If the longname is not\n * associated with a URL, this method simply returns the link text, if provided, or the longname.\n *\n * The `longname` parameter can also contain a URL rather than a symbol's longname.\n *\n * This method supports type applications that can contain one or more types, such as\n * `Array.<MyClass>` or `Array.<(MyClass|YourClass)>`. In these examples, the method attempts to\n * replace `Array`, `MyClass`, and `YourClass` with links to the appropriate types. The link text\n * is ignored for type applications.\n *\n * @param {string} longname - The longname (or URL) that is the target of the link.\n * @param {string=} linkText - The text to display for the link, or `longname` if no text is\n * provided.\n * @param {Object} options - Options for building the link.\n * @param {string=} options.cssClass - The CSS class (or classes) to include in the link's `<a>`\n * tag.\n * @param {string=} options.fragmentId - The fragment identifier (for example, `name` in\n * `foo.html#name`) to append to the link target.\n * @param {string=} options.linkMap - The link map in which to look up the longname.\n * @param {boolean=} options.monospace - Indicates whether to display the link text in a monospace\n * font.\n * @return {string} The HTML link, or the link text if the link is not available.\n */\nfunction buildLink(longname, linkText, options) {\n    var classString = options.cssClass ? util.format(' class=\"%s\"', options.cssClass) : '';\n    var fileUrl;\n    var fragmentString = fragmentHash(options.fragmentId);\n    var stripped;\n    var text;\n\n    var parsedType;\n\n    // handle cases like:\n    // @see <http://example.org>\n    // @see http://example.org\n    stripped = longname ? longname.replace(/^<|>$/g, '') : '';\n    if ( hasUrlPrefix(stripped) ) {\n        fileUrl = stripped;\n        text = linkText || stripped;\n    }\n    // handle complex type expressions that may require multiple links\n    // (but skip anything that looks like an inline tag or HTML tag)\n    else if (longname && isComplexTypeExpression(longname) && /\\{\\@.+\\}/.test(longname) === false &&\n        /^<[\\s\\S]+>/.test(longname) === false) {\n        parsedType = parseType(longname);\n        return stringifyType(parsedType, options.cssClass, options.linkMap);\n    }\n    else {\n        fileUrl = hasOwnProp.call(options.linkMap, longname) ? options.linkMap[longname] : '';\n        text = linkText || longname;\n    }\n\n    text = options.monospace ? '<code>' + text + '</code>' : text;\n\n    if (!fileUrl) {\n        return text;\n    }\n    else {\n        return util.format('<a href=\"%s\"%s>%s</a>', encodeURI(fileUrl + fragmentString),\n            classString, text);\n    }\n}\n\n/**\n * Retrieve an HTML link to the symbol with the specified longname. If the longname is not\n * associated with a URL, this method simply returns the link text, if provided, or the longname.\n *\n * The `longname` parameter can also contain a URL rather than a symbol's longname.\n *\n * This method supports type applications that can contain one or more types, such as\n * `Array.<MyClass>` or `Array.<(MyClass|YourClass)>`. In these examples, the method attempts to\n * replace `Array`, `MyClass`, and `YourClass` with links to the appropriate types. The link text\n * is ignored for type applications.\n *\n * @param {string} longname - The longname (or URL) that is the target of the link.\n * @param {string=} linkText - The text to display for the link, or `longname` if no text is\n * provided.\n * @param {string=} cssClass - The CSS class (or classes) to include in the link's `<a>` tag.\n * @param {string=} fragmentId - The fragment identifier (for example, `name` in `foo.html#name`) to\n * append to the link target.\n * @return {string} The HTML link, or a plain-text string if the link is not available.\n */\nvar linkto = exports.linkto = function(longname, linkText, cssClass, fragmentId) {\n    return buildLink(longname, linkText, {\n        cssClass: cssClass,\n        fragmentId: fragmentId,\n        linkMap: longnameToUrl\n    });\n};\n\nfunction useMonospace(tag, text) {\n    var cleverLinks;\n    var monospaceLinks;\n    var result;\n\n    if ( hasUrlPrefix(text) ) {\n        result = false;\n    }\n    else if (tag === 'linkplain') {\n        result = false;\n    }\n    else if (tag === 'linkcode') {\n        result = true;\n    }\n    else {\n        cleverLinks = env.conf.templates.cleverLinks;\n        monospaceLinks = env.conf.templates.monospaceLinks;\n\n        if (monospaceLinks || cleverLinks) {\n            result = true;\n        }\n    }\n\n    return result || false;\n}\n\nfunction splitLinkText(text) {\n    var linkText;\n    var target;\n    var splitIndex;\n\n    // if a pipe is not present, we split on the first space\n    splitIndex = text.indexOf('|');\n    if (splitIndex === -1) {\n        splitIndex = text.search(/\\s/);\n    }\n\n    if (splitIndex !== -1) {\n        linkText = text.substr(splitIndex + 1);\n        // Normalize subsequent newlines to a single space.\n        linkText = linkText.replace(/\\n+/, ' ');\n        target = text.substr(0, splitIndex);\n    }\n\n    return {\n        linkText: linkText,\n        target: target || text\n    };\n}\n\nvar tutorialToUrl = exports.tutorialToUrl = function(tutorial) {\n    var fileUrl;\n    var node = tutorials.getByName(tutorial);\n\n    // no such tutorial\n    if (!node) {\n        require('jsdoc/util/logger').error( new Error('No such tutorial: ' + tutorial) );\n        return null;\n    }\n\n    // define the URL if necessary\n    if (!hasOwnProp.call(tutorialLinkMap.nameToUrl, node.name)) {\n        fileUrl = 'tutorial-' + getUniqueFilename(node.name);\n        tutorialLinkMap.nameToUrl[node.name] = fileUrl;\n        tutorialLinkMap.urlToName[fileUrl] = node.name;\n    }\n\n    return tutorialLinkMap.nameToUrl[node.name];\n};\n\n/**\n * Retrieve a link to a tutorial, or the name of the tutorial if the tutorial is missing. If the\n * `missingOpts` parameter is supplied, the names of missing tutorials will be prefixed by the\n * specified text and wrapped in the specified HTML tag and CSS class.\n *\n * @todo Deprecate missingOpts once we have a better error-reporting mechanism.\n * @param {string} tutorial The name of the tutorial.\n * @param {string} content The link text to use.\n * @param {object} [missingOpts] Options for displaying the name of a missing tutorial.\n * @param {string} missingOpts.classname The CSS class to wrap around the tutorial name.\n * @param {string} missingOpts.prefix The prefix to add to the tutorial name.\n * @param {string} missingOpts.tag The tag to wrap around the tutorial name.\n * @return {string} An HTML link to the tutorial, or the name of the tutorial with the specified\n * options.\n */\nvar toTutorial = exports.toTutorial = function(tutorial, content, missingOpts) {\n    if (!tutorial) {\n        require('jsdoc/util/logger').error( new Error('Missing required parameter: tutorial') );\n        return null;\n    }\n\n    var node = tutorials.getByName(tutorial);\n    // no such tutorial\n    if (!node) {\n        missingOpts = missingOpts || {};\n        var tag = missingOpts.tag;\n        var classname = missingOpts.classname;\n\n        var link = tutorial;\n        if (missingOpts.prefix) {\n            link = missingOpts.prefix + link;\n        }\n        if (tag) {\n            link = '<' + tag + (classname ? (' class=\"' + classname + '\">') : '>') + link;\n            link += '</' + tag + '>';\n        }\n        return link;\n    }\n\n    content = content || node.title;\n\n    return '<a href=\"' + tutorialToUrl(tutorial) + '\">' + content + '</a>';\n};\n\n/** Find symbol {@link ...} and {@tutorial ...} strings in text and turn into html links */\nexports.resolveLinks = function(str) {\n    var replaceInlineTags = require('jsdoc/tag/inline').replaceInlineTags;\n\n    function extractLeadingText(string, completeTag) {\n        var tagIndex = string.indexOf(completeTag);\n        var leadingText = null;\n        var leadingTextRegExp = /\\[(.+?)\\]/g;\n        var leadingTextInfo = leadingTextRegExp.exec(string);\n\n        // did we find leading text, and if so, does it immediately precede the tag?\n        while (leadingTextInfo && leadingTextInfo.length) {\n            if (leadingTextInfo.index + leadingTextInfo[0].length === tagIndex) {\n                string = string.replace(leadingTextInfo[0], '');\n                leadingText = leadingTextInfo[1];\n                break;\n            }\n\n            leadingTextInfo = leadingTextRegExp.exec(string);\n        }\n\n        return {\n            leadingText: leadingText,\n            string: string\n        };\n    }\n\n    function processLink(string, tagInfo) {\n        var leading = extractLeadingText(string, tagInfo.completeTag);\n        var linkText = leading.leadingText;\n        var monospace;\n        var split;\n        var target;\n        string = leading.string;\n\n        split = splitLinkText(tagInfo.text);\n        target = split.target;\n        linkText = linkText || split.linkText;\n\n        monospace = useMonospace(tagInfo.tag, tagInfo.text);\n\n        return string.replace( tagInfo.completeTag, buildLink(target, linkText, {\n            linkMap: longnameToUrl,\n            monospace: monospace\n        }) );\n    }\n\n    function processTutorial(string, tagInfo) {\n        var leading = extractLeadingText(string, tagInfo.completeTag);\n        string = leading.string;\n\n        return string.replace( tagInfo.completeTag, toTutorial(tagInfo.text, leading.leadingText) );\n    }\n\n    var replacers = {\n        link: processLink,\n        linkcode: processLink,\n        linkplain: processLink,\n        tutorial: processTutorial\n    };\n\n    return replaceInlineTags(str, replacers).newString;\n};\n\n/** Convert tag text like \"Jane Doe <jdoe@example.org>\" into a mailto link */\nexports.resolveAuthorLinks = function(str) {\n    var author;\n    var matches = str.match(/^\\s?([\\s\\S]+)\\b\\s+<(\\S+@\\S+)>\\s?$/);\n    if (matches && matches.length === 3) {\n        author = '<a href=\"mailto:' + matches[2] + '\">' + htmlsafe(matches[1]) + '</a>';\n    }\n    else {\n        author = htmlsafe(str);\n    }\n\n    return author;\n};\n\n/**\n * Find items in a TaffyDB database that match the specified key-value pairs.\n * @param {TAFFY} data The TaffyDB database to search.\n * @param {object|function} spec Key-value pairs to match against (for example,\n * `{ longname: 'foo' }`), or a function that returns `true` if a value matches or `false` if it\n * does not match.\n * @return {array<object>} The matching items.\n */\nvar find = exports.find = function(data, spec) {\n    return data(spec).get();\n};\n\n/**\n * Retrieve all of the following types of members from a set of doclets:\n *\n * + Classes\n * + Externals\n * + Globals\n * + Mixins\n * + Modules\n * + Namespaces\n * + Events\n * @param {TAFFY} data The TaffyDB database to search.\n * @return {object} An object with `classes`, `externals`, `globals`, `mixins`, `modules`,\n * `events`, and `namespaces` properties. Each property contains an array of objects.\n */\nexports.getMembers = function(data) {\n    var members = {\n        classes: find( data, {kind: 'class'} ),\n        externals: find( data, {kind: 'external'} ),\n        events: find( data, {kind: 'event'} ),\n        globals: find(data, {\n            kind: ['member', 'function', 'constant', 'typedef'],\n            memberof: { isUndefined: true }\n        }),\n        mixins: find( data, {kind: 'mixin'} ),\n        modules: find( data, {kind: 'module'} ),\n        namespaces: find( data, {kind: 'namespace'} ),\n        interfaces: find( data, {kind: 'interface'} )\n    };\n\n    // strip quotes from externals, since we allow quoted names that would normally indicate a\n    // namespace hierarchy (as in `@external \"jquery.fn\"`)\n    // TODO: we should probably be doing this for other types of symbols, here or elsewhere; see\n    // jsdoc3/jsdoc#396\n    members.externals = members.externals.map(function(doclet) {\n        doclet.name = doclet.name.replace(/(^\"|\"$)/g, '');\n        return doclet;\n    });\n\n    // functions that are also modules (as in `module.exports = function() {};`) are not globals\n    members.globals = members.globals.filter(function(doclet) {\n        return !isModuleExports(doclet);\n    });\n\n    return members;\n};\n\n/**\n * Retrieve the member attributes for a doclet (for example, `virtual`, `static`, and\n * `readonly`).\n * @param {object} d The doclet whose attributes will be retrieved.\n * @return {array<string>} The member attributes for the doclet.\n */\nexports.getAttribs = function(d) {\n    var attribs = [];\n\n    if (!d) {\n        return attribs;\n    }\n\n    if (d.virtual) {\n        attribs.push('abstract');\n    }\n\n    if (d.access && d.access !== 'public') {\n        attribs.push(d.access);\n    }\n\n    if (d.scope && d.scope !== 'instance' && d.scope !== name.SCOPE.NAMES.GLOBAL) {\n        if (d.kind === 'function' || d.kind === 'member' || d.kind === 'constant') {\n            attribs.push(d.scope);\n        }\n    }\n\n    if (d.readonly === true) {\n        if (d.kind === 'member') {\n            attribs.push('readonly');\n        }\n    }\n\n    if (d.kind === 'constant') {\n        attribs.push('constant');\n    }\n\n    if (d.nullable === true) {\n        attribs.push('nullable');\n    }\n    else if (d.nullable === false) {\n        attribs.push('non-null');\n    }\n\n    return attribs;\n};\n\n/**\n * Retrieve links to allowed types for the member.\n *\n * @param {Object} d - The doclet whose types will be retrieved.\n * @param {string} [cssClass] - The CSS class to include in the `class` attribute for each link.\n * @return {Array.<string>} HTML links to allowed types for the member.\n */\nexports.getSignatureTypes = function(d, cssClass) {\n    var types = [];\n\n    if (d.type && d.type.names) {\n        types = d.type.names;\n    }\n\n    if (types && types.length) {\n        types = types.map(function(t) {\n            return linkto(t, htmlsafe(t), cssClass);\n        });\n    }\n\n    return types;\n};\n\n/**\n * Retrieve names of the parameters that the member accepts. If a value is provided for `optClass`,\n * the names of optional parameters will be wrapped in a `<span>` tag with that class.\n * @param {object} d The doclet whose parameter names will be retrieved.\n * @param {string} [optClass] The class to assign to the `<span>` tag that is wrapped around the\n * names of optional parameters. If a value is not provided, optional parameter names will not be\n * wrapped with a `<span>` tag. Must be a legal value for a CSS class name.\n * @return {array<string>} An array of parameter names, with or without `<span>` tags wrapping the\n * names of optional parameters.\n */\nexports.getSignatureParams = function(d, optClass) {\n    var pnames = [];\n\n    if (d.params) {\n        d.params.forEach(function(p) {\n            if (p.name && p.name.indexOf('.') === -1) {\n                if (p.optional && optClass) {\n                    pnames.push('<span class=\"' + optClass + '\">' + p.name + '</span>');\n                }\n                else {\n                    pnames.push(p.name);\n                }\n            }\n        });\n    }\n\n    return pnames;\n};\n\n/**\n * Retrieve links to types that the member can return.\n *\n * @param {Object} d - The doclet whose types will be retrieved.\n * @param {string} [cssClass] - The CSS class to include in the `class` attribute for each link.\n * @return {Array.<string>} HTML links to types that the member can return.\n */\nexports.getSignatureReturns = function(d, cssClass) {\n    var returnTypes = [];\n\n    if (d.returns) {\n        d.returns.forEach(function(r) {\n            if (r && r.type && r.type.names) {\n                if (!returnTypes.length) {\n                    returnTypes = r.type.names;\n                }\n            }\n        });\n    }\n\n    if (returnTypes && returnTypes.length) {\n        returnTypes = returnTypes.map(function(r) {\n            return linkto(r, htmlsafe(r), cssClass);\n        });\n    }\n\n    return returnTypes;\n};\n\n/**\n * Retrieve an ordered list of doclets for a symbol's ancestors.\n *\n * @param {TAFFY} data - The TaffyDB database to search.\n * @param {Object} doclet - The doclet whose ancestors will be retrieved.\n * @return {Array.<module:jsdoc/doclet.Doclet>} A array of ancestor doclets, sorted from most to\n * least distant.\n */\nexports.getAncestors = function(data, doclet) {\n    var ancestors = [];\n    var doc = doclet;\n    var previousDoc;\n\n    while (doc) {\n        previousDoc = doc;\n        doc = find(data, {longname: doc.memberof})[0];\n\n        // prevent infinite loop that can be caused by duplicated module definitions\n        if (previousDoc === doc) {\n            break;\n        }\n\n        if (doc) {\n            ancestors.unshift(doc);\n        }\n    }\n\n    return ancestors;\n};\n\n/**\n * Retrieve links to a member's ancestors.\n *\n * @param {TAFFY} data - The TaffyDB database to search.\n * @param {Object} doclet - The doclet whose ancestors will be retrieved.\n * @param {string} [cssClass] - The CSS class to include in the `class` attribute for each link.\n * @return {Array.<string>} HTML links to a member's ancestors.\n */\nexports.getAncestorLinks = function(data, doclet, cssClass) {\n    var ancestors = exports.getAncestors(data, doclet);\n    var links = [];\n\n    ancestors.forEach(function(ancestor) {\n        var linkText = (exports.scopeToPunc[ancestor.scope] || '') + ancestor.name;\n        var link = linkto(ancestor.longname, linkText, cssClass);\n        links.push(link);\n    });\n\n    if (links.length) {\n        links[links.length - 1] += (exports.scopeToPunc[doclet.scope] || '');\n    }\n\n    return links;\n};\n\n/**\n * Iterates through all the doclets in `data`, ensuring that if a method\n * @listens to an event, then that event has a 'listeners' array with the\n * longname of the listener in it.\n *\n * @param {TAFFY} data - The TaffyDB database to search.\n */\nexports.addEventListeners = function(data) {\n    // TODO: do this on the *pruned* data\n    // find all doclets that @listen to something.\n    var listeners = find(data, function () { return this.listens && this.listens.length; });\n\n    if (!listeners.length) {\n        return;\n    }\n\n    var doc,\n        l,\n        _events = {}; // just a cache to prevent me doing so many lookups\n\n    listeners.forEach(function (listener) {\n        l = listener.listens;\n        l.forEach(function (eventLongname) {\n            doc = _events[eventLongname] || find(data, {longname: eventLongname, kind: 'event'})[0];\n            if (doc) {\n                if (!doc.listeners) {\n                    doc.listeners = [listener.longname];\n                } else {\n                    doc.listeners.push(listener.longname);\n                }\n                _events[eventLongname] = _events[eventLongname] || doc;\n            }\n        });\n    });\n};\n\n/**\n * Remove members that will not be included in the output, including:\n *\n * + Undocumented members.\n * + Members tagged `@ignore`.\n * + Members of anonymous classes.\n * + Members tagged `@private`, unless the `private` option is enabled.\n * + Members tagged with anything other than specified by the `access` options.\n * @param {TAFFY} data The TaffyDB database to prune.\n * @return {TAFFY} The pruned database.\n */\nexports.prune = function(data) {\n    data({undocumented: true}).remove();\n    data({ignore: true}).remove();\n    data({memberof: '<anonymous>'}).remove();\n\n    if (!env.opts.access || (env.opts.access && env.opts.access.indexOf('all') === -1)) {\n        if (env.opts.access && env.opts.access.indexOf('public') === -1) {\n            data({access: 'public'}).remove();\n        }\n        if (env.opts.access && env.opts.access.indexOf('protected') === -1) {\n            data({access: 'protected'}).remove();\n        }\n        if (!env.opts.private && (!env.opts.access || (env.opts.access && env.opts.access.indexOf('private') === -1))) {\n            data({access: 'private'}).remove();\n        }\n        if (env.opts.access && env.opts.access.indexOf('undefined') === -1) {\n            data({access: {isUndefined: true}}).remove();\n        }\n    }\n\n    return data;\n};\n\n/**\n * Create a URL that points to the generated documentation for the doclet.\n *\n * If a doclet corresponds to an output file (for example, if the doclet represents a class), the\n * URL will consist of a filename.\n *\n * If a doclet corresponds to a smaller portion of an output file (for example, if the doclet\n * represents a method), the URL will consist of a filename and a fragment ID.\n *\n * @param {module:jsdoc/doclet.Doclet} doclet - The doclet that will be used to create the URL.\n * @return {string} The URL to the generated documentation for the doclet.\n */\nexports.createLink = function(doclet) {\n    var fakeContainer;\n    var filename;\n    var fileUrl;\n    var fragment = '';\n    var longname = doclet.longname;\n    var match;\n\n    // handle doclets in which doclet.longname implies that the doclet gets its own HTML file, but\n    // doclet.kind says otherwise. this happens due to mistagged JSDoc (for example, a module that\n    // somehow has doclet.kind set to `member`).\n    // TODO: generate a warning (ideally during parsing!)\n    if (containers.indexOf(doclet.kind) === -1) {\n        match = /(\\S+):/.exec(longname);\n        if (match && containers.indexOf(match[1]) !== -1) {\n            fakeContainer = match[1];\n        }\n    }\n\n    // the doclet gets its own HTML file\n    if ( containers.indexOf(doclet.kind) !== -1 || isModuleExports(doclet) ) {\n        filename = getFilename(longname);\n    }\n    // mistagged version of a doclet that gets its own HTML file\n    else if ( containers.indexOf(doclet.kind) === -1 && fakeContainer ) {\n        filename = getFilename(doclet.memberof || longname);\n        if (doclet.name !== doclet.longname) {\n            fragment = formatNameForLink(doclet);\n            fragment = getId(longname, fragment);\n        }\n    }\n    // the doclet is within another HTML file\n    else {\n        filename = getFilename(doclet.memberof || exports.globalName);\n        if ( (doclet.name !== doclet.longname) || (doclet.scope === name.SCOPE.NAMES.GLOBAL) ) {\n            fragment = formatNameForLink(doclet);\n            fragment = getId(longname, fragment);\n        }\n    }\n\n    fileUrl = encodeURI( filename + fragmentHash(fragment) );\n\n    return fileUrl;\n};\n\n// TODO: docs\nexports.longnamesToTree = name.longnamesToTree;\n\n/**\n * Replace the existing tag dictionary with a new tag dictionary.\n *\n * Used for testing only. Do not call this method directly. Instead, call\n * {@link module:jsdoc/doclet._replaceDictionary}, which also updates this module's tag dictionary.\n *\n * @private\n * @param {module:jsdoc/tag/dictionary.Dictionary} dict - The new tag dictionary.\n */\nexports._replaceDictionary = function _replaceDictionary(dict) {\n    dictionary = dict;\n};\n"}